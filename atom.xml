<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Roc Zhang&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.roczhang.com/"/>
  <updated>2017-03-28T15:12:04.000Z</updated>
  <id>http://www.roczhang.com/</id>
  
  <author>
    <name>Roc Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&#39;===&#39; &amp; &#39;!==&#39; in Swift</title>
    <link href="http://www.roczhang.com/in-Swift.html"/>
    <id>http://www.roczhang.com/in-Swift.html</id>
    <published>2017-03-28T14:21:43.000Z</published>
    <updated>2017-03-28T15:12:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>一篇简短的小记。<br><a id="more"></a></p>
<h1 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h1><p>由于最近比较多的用了 IGListKit 来写新的模块和重构旧的模块，其中 IGListKit 要求模型遵遁 IGListDiffable 协议，其中需要你实现一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public func isEqual(toDiffableObject object: IGListDiffable?) -&gt; Bool</div></pre></td></tr></table></figure>
<p>来告诉 IGList 接收到的和给定的 object 是否相等。一般情况用模型里的 hash id 来判断就可以解决，但今天和师傅讨论到如果是一个数组，而且数组里的模型又没有 ID 属性，该如何判断相等。</p>
<p>由此想到了 ‘===’ &amp; ‘!==’ 运算符。</p>
<h1 id="‘-’-amp-‘-’"><a href="#‘-’-amp-‘-’" class="headerlink" title="‘===’ &amp; ‘!==’"></a>‘===’ &amp; ‘!==’</h1><p>比起常用的 == 和 != ，这两个运算貌似使用的频度非常低，其实用法倒是很简单的， === 和 !== 用于比较 引用类型（Reference Type）是否是相同的引用。</p>
<p>不过随便查看几个搜索结果会发现好像有这么一段说法：</p>
<p>“Check whether two arrays or subarrays share the same storage and elements by comparing them with the identity operators (=== and !==).”</p>
<p>嗯嗯嗯？还可以比较数组或者子数组的？原生支持？如此方便？<br>在 Playground 中简单一试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let array1 = [1, 2, 3]</div><div class="line">var array2 = array1</div><div class="line"></div><div class="line">array1 !== array2</div></pre></td></tr></table></figure>
<p>马上就会 “Error: binary operator ‘!==’ cannot be applied to…”。</p>
<p>不过等等，Swift 中的 Array 不是 Value Type 吗，是应该不能用这个啊，那为什么会有可以比较数组这种说法？难道记错了？</p>
<p>“Array and Dictionary in Swift are implemented as structs.”</p>
<p>没记错， Array 是 Value Type.</p>
<p>后来发现，之所以有比较数组这种说法是因为，在 2014 年 Swift beta 3 之前，Swift 中的 Array 有一些小小的不同，引用喵神以前的博客里的一句话：</p>
<p>“Swift 考虑到实际使用的情景，对 Array 做了特殊的处理。除非需要（比如 Array 的大小发生改变，或者显式地要求进行复制），否则 Array 在传递的时候会使用参照。”</p>
<p>而之后</p>
<p>“对于 Array 中元素的改变，在 beta 3 中发生了变化。现在不再存在作为一个值类型但是却在赋值和改变时表现为参照类型的 Array 的特例，而是彻头彻尾表现出了值类型的特点。”</p>
<p>所以， ‘===’ &amp; ‘!==’ 用于比较数组的这种说法也是很早之前的老文档中存在的，现在并不能用啦。</p>
<p>等等，谁说不能？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let array1 = NSArray(array: [A, B])</div><div class="line">var array2 = array1</div><div class="line"></div><div class="line">array1 !== array2</div></pre></td></tr></table></figure>
<p>用 Cocoa 中的容器类自然没问题，因为是引用类嘛。</p>
<p>但这就没有 Swift 的 “钦定” 感了! 🙃</p>
<p>善变的 Swift! 🙃</p>
<h1 id="Swift-3-1"><a href="#Swift-3-1" class="headerlink" title="Swift 3.1"></a>Swift 3.1</h1><p>Xcode 8.3 出来了！ Swift 3.1 出来了！<br>Apple 还说 “Faster builds for large projects that mix Objective-C and Swift code”!<br>赶紧一试！</p>
<p><img src="http://i1.piimg.com/577817/dc057c7c28ef5d73.jpg" alt="Markdown preferences pane"></p>
<p>120 秒… 还有 Swift 3.1 附赠的爆炸多的警告… 🙃<br>也许还是在提示我电脑不行了。 🙃</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-ID82" target="_blank" rel="external">Apple - Classes and Structures</a><br><a href="https://onevcat.com/2014/06/walk-in-swift/" target="_blank" rel="external">OneV’s Den - 行走于 Swift 的世界中</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇简短的小记。&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>3D Touch for iOS 10 适配指南</title>
    <link href="http://www.roczhang.com/3D-Touch-for-iOS-10-%E9%80%82%E9%85%8D%E6%8C%87%E5%8D%97.html"/>
    <id>http://www.roczhang.com/3D-Touch-for-iOS-10-适配指南.html</id>
    <published>2017-03-26T02:31:03.000Z</published>
    <updated>2017-03-26T16:11:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>好不容易起个大早的居然就突然停电了，翻看到好久之前的 WWDC 学习笔记，想起来之前好像打算稍稍整理一下 3D Touch 相关内容的，趁着 MacBook 还有电顺手写一下。<br><a id="more"></a></p>
<p>对应的是 WWDC 16 - Session 228。先记录 Session 上的相关内容。</p>
<h1 id="Home-Screen-Quick-Actions"><a href="#Home-Screen-Quick-Actions" class="headerlink" title="Home Screen Quick Actions"></a>Home Screen Quick Actions</h1><p>这就是 iOS SpringBoard 上用力点按 App Icon 弹出的快捷操作菜单了。此类菜单分为两类，静态和动态。</p>
<h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><p>静态 action 被定义在 app 的 info.plist 文件中。定义之后，用户在安装了你的 app 后就可以生效使用。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-UIApplicationShortcutItems</div><div class="line">--Item 0</div><div class="line">---UIApplicationShortcutItemType      String    com.company.app.XXX</div><div class="line">---UIApplicationShortcutItemTitle    String    New Chat</div><div class="line">---UIApplicationShortcutItemIconType  String    UIApplicationShortcutIconTypeMessage(system type)</div></pre></td></tr></table></figure>
<p>最后的 ShortcutIconType 可以使用系统提供的一些类型。而关于 Item 总数的问题，除去 iOS 10 开始系统增加的 “分享” 项外，最多只能设置 4 个（包括动静态项全部）。顺带一提，貌似大多数 app 的做法都是一个静态项外加三个动态生成项。</p>
<h2 id="Dynamic"><a href="#Dynamic" class="headerlink" title="Dynamic"></a>Dynamic</h2><p>与上面静态项所对应的就是 dynamic item，动态项是你的 App 在运行时创建的，所以只有在你的 app 第一次启动后才可以生成并可用。并且顺序上 dynamic item 是展示在 static item（看 action 列表展开的方向嘛，动态项会比静态项离手指更远）。但是动态项除了可以使用上面提到的系统提供的 icon 外，还可以使用自定义的 icon，以及通讯录中联系人的头像👦。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">let contactName = &quot;RocZhang&quot;</div><div class="line">var contactIcon: UIApplicationShortcutIcon? = nil</div><div class="line"></div><div class="line">// Make sure to request access to the user&apos;s contacts first</div><div class="line">if CNContactStore.authorizationStatue(for: .contacts) == .authorized &#123;</div><div class="line">    let predicate = CNContact.predicateForContacts(matchingName: contactName)</div><div class="line">    let contacts = try? CNContactStore().unifiedContacts(matching: predicate, keysToFecth: [])</div><div class="line"></div><div class="line">    if let contact = contacts?.first &#123;</div><div class="line">        contactIcon = UIApplicationShortcutIcon(contact: contact)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Fallback</div><div class="line">let icon = contactIcon ??  UIApplicationShortcutIcon(type: .message)</div><div class="line"></div><div class="line">// Create a Dynamic quick action using the icon</div><div class="line">let type = &quot;com.company.app.sendMessageTo&quot;</div><div class="line">let subtitle = &quot;Send a message&quot;</div><div class="line">let shortcutItem1 = UIApplicationShortcutItem(type: type, localizedTitle: contactName, localizedSubTitle: subtitle, icon: icon)</div><div class="line"></div><div class="line">// Repeat ...</div><div class="line"></div><div class="line">let shortcutItems = [shortcutItem1, shortcutItem2, shortcutItem3]</div><div class="line"></div><div class="line">// Register the Dynamic quick actions to display on the home Screen</div><div class="line">UIApplication.shared.shortcutItems = shortcutItems</div></pre></td></tr></table></figure>
<h2 id="Handing"><a href="#Handing" class="headerlink" title="Handing"></a>Handing</h2><p>设置好这些快捷操作项后我们当然要处理相应点击后的操作。没啥特别好说的，两种情况：</p>
<h3 id="On-app-activation"><a href="#On-app-activation" class="headerlink" title="On app activation"></a>On app activation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func application(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: Bool -&gt; Void) &#123;</div><div class="line">    let didHandle: Bool =  handle the quick action using shortcutItem</div><div class="line">    completionHandler(didHandle)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="On-app-launch"><a href="#On-app-launch" class="headerlink" title="On app launch"></a>On app launch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool &#123;</div><div class="line">    var performAdditionalHandling = true</div><div class="line">    if let shortcutItem = launchOptions?[UIApplicationLaunchOptionsShortcutItemKey] as? UIApplicationShortcutItem &#123;</div><div class="line">        handle the quick action using shortcutItem</div><div class="line">        performAdditionalHandling = false</div><div class="line">    &#125;</div><div class="line">    return performAdditionalHandling</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Best-Practices"><a href="#Best-Practices" class="headerlink" title="Best Practices"></a>Best Practices</h2><p>关于上述的 Quick Actions，Apple 提供了一些建议：</p>
<ul>
<li>每个 app 都应该提供 quick actions(我想这可能就是 iOS 10 系统全部加上 “分享” 的原因之一🤗)</li>
<li>好钢用在刀刃上（因为总数只有 4 个，所以 Apple 建议应该给具有高价值的任务创建快捷进入项）</li>
<li>确保你设置的项目是可被用户预知的（嗯我感觉我用力按了这个图标应该会出现…诶诶诶你怎么不按套路出牌！）</li>
<li>做好版本升级后依然能处理前一个版本生成的动态快捷项的准备</li>
</ul>
<h1 id="Peek-amp-Pop"><a href="#Peek-amp-Pop" class="headerlink" title="Peek &amp; Pop"></a>Peek &amp; Pop</h1><p>如果你还不太了解 peek pop 是什么，建议去看一下超炫酷的 iPhone 6s 发布时介绍 3D Touch 的视频。<br><a href="https://www.youtube.com/watch?v=IfXB7SPbg9A" target="_blank" rel="external">iPhone 6s 3D touch feature video</a><br>简单说来，Peek &amp; Pop 提供了一种可供用户快速预览和在内容之间导航的方式。</p>
<h2 id="Adding-Peek-amp-Pop-to-your-app"><a href="#Adding-Peek-amp-Pop-to-your-app" class="headerlink" title="Adding Peek &amp; Pop to your app"></a>Adding Peek &amp; Pop to your app</h2><p>适配 Peek &amp; Pop 非常简单，但首先需要了解一下，CocoaTouch 中把这两个动作先后称之为 Preview 和 Commit。</p>
<p>适配的过程可分为以下几步：<br>一，让 ViewController 遵循 UIViewControllerPreviewingDelegate:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// MARK: - UIViewControllerPreviewingDelegate Methods</div><div class="line"></div><div class="line">extension ViewController: UIViewControllerPreviewingDelegate &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>二，是把 ViewController 注册 Previewing:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">override func viewDidLoad() &#123;</div><div class="line">    super.viewDidLoad()</div><div class="line"></div><div class="line">    registerForPreviewing(with: self, sourceView: tableView)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>三，实现 UIViewControllerPreviewingDelegate 中的 preview 和 commit 方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// MARK: - UIViewControllerPreviewingDelegate Methods</div><div class="line"></div><div class="line">extension ViewController: UIViewControllerPreviewingDelegate &#123;</div><div class="line">  func previewingContext(_ previewingContext: UIViewControllerPreviewing, viewControllerForLocation locatin: CGPoint) -&gt; UIViewContrller? &#123;</div><div class="line">    guard let indexPath = tableView.indexPathForRow(at: location) else &#123; return nil &#125;</div><div class="line"></div><div class="line">    let chatDetailViewController = ...</div><div class="line">    chatDetailViewController.chatItem = chatItem(at: indexPath)</div><div class="line">    let cellRect = tableView.rectForRow(at: indexPath)</div><div class="line">    let sourceRect = previewingContext.sourceView.convert(cellRect, from: tableView)</div><div class="line">    previewingContext.sourceRect = sourceRect</div><div class="line"></div><div class="line">    return chatDetailViewController</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  func previewingContext(_ previewingContext: UIViewControllerPreviewing, commit viewControllerToCommit: UIViewContrller) &#123;</div><div class="line">    show(viewControllerToCommit, sender: self)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Preview-quick-actions"><a href="#Preview-quick-actions" class="headerlink" title="Preview quick actions"></a>Preview quick actions</h2><p>这里你可以自己决定是否要提供一些预览时的快捷操作。并不是最开始说的主屏幕上的快捷操作，而是这里的：</p>
<p><img src="http://i4.buimg.com/577817/330ac8dc3e144f43.png" alt="Markdown preferences pane"></p>
<p>这里需要 override 一个 previewActionItems 的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">override func previewActionItems() -&gt; [UIPreviewActionItem] &#123;</div><div class="line">    let heart = UIPreviewAction(title: &quot;&quot;, style: .default) &#123; (action, viewController) in</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return [heart]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中的 style 除了 .default 还有 .selected 代表被选中，以及 .destructive 代表具有破坏性的操作。</p>
<h2 id="Best-Practices-1"><a href="#Best-Practices-1" class="headerlink" title="Best Practices"></a>Best Practices</h2><p>同样，关于 Peek &amp; Pop ，Apple 提供了一些建议：</p>
<ul>
<li>可以被点击的内容应该要考虑支持 Peek &amp; Pop （和上面那条 每个 app 都应该提供 quick actions 差不多，毕竟 3D Touch 用力点按之前用户并不知道会发生什么，有些可以响应 3D Touch 有些又不能就可能会让用户很不爽，久而久之就不愿意去使用 3D Touch 了）</li>
<li>不要在 previewing delegate 中花费太长的时间，因为是需要 peek 一下就显示出来，不能做太过费时的操作。</li>
</ul>
<h1 id="UIPreviewInteraction"><a href="#UIPreviewInteraction" class="headerlink" title="UIPreviewInteraction"></a>UIPreviewInteraction</h1><p>UIPreviewInteraction 似乎是用的比较少的，这是一个可以让我们的视图提供响应 3D Touch 交互动作的类。刚才提到 preview 和 commit，实际上这是使用 3D Touch preview 中包括的两个过程。由于从开始点按屏幕到响应 peek（preview 阶段结束） 再到响应 pop (commit 阶段结束)，力度是有变化的。通过 UIPreviewInteraction 我们就可以获取当前用户点按力度分别在这两个阶段中的进度（0-1），这两个阶段的关系使用 API 官网中的一张图就可以表示清楚：</p>
<p><img src="http://i2.buimg.com/577817/ee50a5a22bc56521.png" alt="Markdown preferences pane"></p>
<p>适配过程同样很简单，大致如下：<br>一，遵循 UIPreviewInteractionDelegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extension xxViewController: UIPreviewInteractionDelegate</div></pre></td></tr></table></figure></p>
<p>二，创建 UIPreviewInteraction 并设置 delegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private var previewInteraction: UIPreviewInteraction?</div><div class="line"></div><div class="line">override func viewDidLoad &#123;</div><div class="line">    super.viewDidLoad()</div><div class="line"></div><div class="line">    previewInteraction = UIPreviewInteraction(view: view)</div><div class="line">    previewInteraction?.delegate = self</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>三，就可以通过代理方法获取到当前的进度，然后做你需要的事情了。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func previewInteraction(_ previewInteraction: UIPreviewInteraction, didUpdatePreviewTransition  transitionProgress: CGFloat, ended: Bool) &#123;</div><div class="line">    // Do something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为通过 progress 获取到进度，所以我们可以通过这个值来驱动一些动画之类的，仔细想想这个应该会是蛮好玩的。</p>
<h1 id="Low-Level-Force-API"><a href="#Low-Level-Force-API" class="headerlink" title="Low-Level Force API"></a>Low-Level Force API</h1><p>此外，session 228 的最后也提及了一下低层级力度 API ，在支持 3D Touch 或 Apple Pencil 的设备上，你可以获取到规范化的力度数据。关于这方面的内容，可以参见另一个 session: Leveraging Touch input on iOS.</p>
<h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><p>下面是一些 session 中并没有提及的内容。<br>除去上面通过 UIViewControllerPreviewingDelegate 适配常见的 UITableView, UICollectionView 等的 peek 与 pop 操作，还有一种比较常见的场景是，我们希望在 3D Touch 发生在 cell 的每个部分上时，作出不同的响应（比如，3D Touch 了某个 feed 我们希望预览这个 feed 的详情，而点的时 feed 里的头像时，我们希望弹出的预览是 profile）。我们可以在上面的基础上进一步，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public func viewContainsFormSuperview(with view: UIView, location: CGPoint) -&gt; Bool &#123;</div><div class="line">        let location = view.convert(location, from: self)</div><div class="line">        return view.bounds.contains(location)</div><div class="line">&#125;</div><div class="line"></div><div class="line">public func previewingContext(_ previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -&gt; UIViewController? &#123;</div><div class="line">        guard let indexPath = tableView.indexPathForRow(at: location) else &#123; return nil &#125;</div><div class="line">        guard let cell = tableView.cellForRow(at: indexPath) as? xxCell else &#123; return nil &#125;</div><div class="line"></div><div class="line">        let avatarView = cell.avatarView</div><div class="line">        let location = avatarView.convert(location, from: tableView)</div><div class="line">        if avatarView.bounds.contains(location) &#123;</div><div class="line">            let viewRect = tableView.convert(avatarView.frame, from: avatarView.superview)</div><div class="line">            previewingContext.sourceRect = viewRect</div><div class="line"></div><div class="line">            return ProfileViewController()</div><div class="line">        &#125; else &#123;</div><div class="line">            return nil</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结，session 中方提到的适配 3D Touch 主要三个方面 – 主屏幕快捷操作可以使用户直接跳转进对应的动作，Peek &amp; Pop 允许用户快速预览并导航到内容，最后的 UIPreviewInteraction 也为 app 的交互提供了新的可能。这篇文章也就到这里啦，如有问题和疏漏，还请指出。</p>
<p>最后准备提交的时候发现 多说即将关闭 的消息，啊，有点可惜。</p>
<h2 id="See-you"><a href="#See-you" class="headerlink" title="See you"></a>See you</h2><p>Created by ROC Zhang on 2017-03-26.<br>Copyright © 2016-2017 ROC Zhang. All rights reserved.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好不容易起个大早的居然就突然停电了，翻看到好久之前的 WWDC 学习笔记，想起来之前好像打算稍稍整理一下 3D Touch 相关内容的，趁着 MacBook 还有电顺手写一下。&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>遇到的 XC 8 中的两个小坑</title>
    <link href="http://www.roczhang.com/%E9%81%87%E5%88%B0%E7%9A%84%20XC%208%20%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B0%8F%E5%9D%91.html"/>
    <id>http://www.roczhang.com/遇到的 XC 8 中的两个小坑.html</id>
    <published>2016-11-28T16:23:12.000Z</published>
    <updated>2016-11-28T17:54:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天可能时运不济，一次碰到了两个小坑，趁着现在 pod repo update 的时候记一下。<br><a id="more"></a></p>
<h2 id="Background-Fetch"><a href="#Background-Fetch" class="headerlink" title="Background Fetch"></a>Background Fetch</h2><p>今天在一开始在写和 Background Fetch 相关的代码。把 performFetchWithCompletionHandler 写好，然后其他的配置做好之后，连上手机准备测试。因为一般 Background Fetch 发生都需要时间，而且这个调用的时间间隔是系统定的，即使设定了 setMinimumBackgroundFetchInterval(UIApplicationBackgroundFetchIntervalMinimum) 可能也要蛮久一段时间系统才会调用。所以一般都会点 Xcode -&gt; Debug -&gt; Simulate Background Fetch 让 Background Fetch 能立即执行来方便调试。</p>
<p>所以我当然也是要点的。<br>结果我期待的结果并没有和以前一样发生，程序居然奔溃退出了，就像这样。</p>
<p><img src="http://p1.bpimg.com/4851/100d68e61bc45fa2.png" alt="Markdown preferences pane"></p>
<p>我开始以为是自己代码有问题，于是调试了一会儿，最后发现即使我在方法里什么都不做调用的时候还是会奔溃。有点懵。然后我在模拟器上试了一发，结果发现并没有任何问题！调用是成功的！</p>
<p>Google 了一发，在 Apple Developer Forums 里看到了一篇贴 ( <a href="https://forums.developer.apple.com/thread/51361" target="_blank" rel="external">https://forums.developer.apple.com/thread/51361</a> )，也有人在 Xcode 8 上遇到了一样的情况：</p>
<p><img src="http://p1.bpimg.com/4851/544f7a16ca99aeee.png" alt="Markdown preferences pane"></p>
<p>然而最后是怎么解决的呢？当然不是等20分钟让他自然发生调用。你会发现在真机上点击后的奔溃是 Xcode 自己断开的，然后你再轻轻的点一下继续执行按钮，它就把我的 Background Fetch 执行好了。</p>
<p><img src="http://p1.bpimg.com/4851/6cef865f9bef302d.png" alt="Markdown preferences pane"></p>
<p>Fun.</p>
<h2 id="UNNotificationSound"><a href="#UNNotificationSound" class="headerlink" title="UNNotificationSound"></a>UNNotificationSound</h2><p>还有就是关于 UNNotificationSound 的问题。</p>
<p>我在尝试用 iOS 10 新的 UserNotification 来创建通知，一个本地通知，其他的一切都没有问题，然而自定义的提醒通知的声音就是无法播放。并且以前创建通知写法的代码是没有问题可以播放的。</p>
<p><img src="http://p1.bpimg.com/4851/960c9bffa8db51e8.png" alt="Markdown preferences pane"></p>
<p>从苹果的文档 ( <a href="https://developer.apple.com/reference/usernotifications/unnotificationsound" target="_blank" rel="external">https://developer.apple.com/reference/usernotifications/unnotificationsound</a> ) 看到 UNNotificationSound 支持由 Linear PCM ／ MA4 (IMA/ADPCM)／ µLaw ／ aLaw 封装成的 aiff, wav, caf 几种格式的文件。我也转换了几种格式都试了下想确定是不是格式的问题，而无论怎么测试，系统始终播放的是默认的三连音：哒哒哒。</p>
<p>然后我又遇到了一样处境的人（这次的人比较多），还是在 Apple Developer Forums 里的帖子（ <a href="https://forums.developer.apple.com/thread/49512" target="_blank" rel="external">https://forums.developer.apple.com/thread/49512</a> ）。</p>
<p>有人好像找到了暂时解决的方法：重启 iOS 设备，卸载 App ，然后重新安装，自定义的铃声就可以生效了。但是有人说这种方法在你使用 Xcode 再装 App 的时候又会失效了。</p>
<p><img src="http://p1.bpimg.com/4851/313c960e725367c2.png" alt="Markdown preferences pane"></p>
<p>但是无论如何，我的自定义铃声一直没有播出来。<br>Magic.</p>
<h3 id="？？？"><a href="#？？？" class="headerlink" title="？？？"></a>？？？</h3><p>天冷了，Macbook 的散热变好了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天可能时运不济，一次碰到了两个小坑，趁着现在 pod repo update 的时候记一下。&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>我的设计学习之旅</title>
    <link href="http://www.roczhang.com/%E6%88%91%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85.html"/>
    <id>http://www.roczhang.com/我的设计学习之旅.html</id>
    <published>2016-10-28T21:03:38.000Z</published>
    <updated>2016-11-28T17:40:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>今晚逛 Dribbble 的时候突然又点开看了自己悲剧的 Debuts ，于是突然想到理理这个，正好可以也当作自己博客 Design 系列第一篇。<br><a id="more"></a></p>
<h2 id="大学前"><a href="#大学前" class="headerlink" title="大学前"></a>大学前</h2><p>大学前基本应该不懂啥是设计（现在应该也不懂）。</p>
<p>初中的时候机缘巧合参加了网页制作的比赛，那时候第一次开始用 Photoshop，做一些素材，修改排版。当时觉得来回折腾调整，或者这种在“制作／创作”的感觉非常有意思。而初高中时期除了偶尔帮班主任做一些班会的 PPT 也就没什么时间和机会做东西了。那会儿能算的上接触的设计作品也就算是各种主题了。</p>
<h2 id="大学后"><a href="#大学后" class="headerlink" title="大学后"></a>大学后</h2><h3 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h3><p>大一刚进大学那会儿除了日常写程序结果是做各种 PPT，居然还被班上同学嘲笑为 “PPT 小王子”。其实是根本没啥特别的，只不过我没有用 Office 艺术字而已。附上一个那会儿给一个小活动做的 Keynote。</p>
<p><img src="http://p1.bqimg.com/4851/1d90212465a63913.png" alt="Markdown preferences pane"></p>
<p>然后就开始算的上设计了第一个作品了– 真选！那时候还不是会做真正的 App 开发，就在 Photoshop 里面画设计稿。那时候完全不了解 App 设计的准则规范之类，完全凭借着自己的感觉来。从自己觉得丑到爆炸到后来慢慢改成觉得还行之间，也是改了很多个版本。</p>
<p>一开始几个版本是这样的，其实都挺辣眼睛的：<br><img src="http://p1.bqimg.com/4851/8af50bf7b8639892.png" alt="Markdown preferences pane"></p>
<p>最后做成这样了：<br><img src="http://p1.bqimg.com/4851/02ad91ce64021471.png" alt="Markdown preferences pane"></p>
<p>还若有其事的做了一个 MockUp 当 Cover ：<br><img src="http://p1.bqimg.com/4851/03446b2f07a64db4.jpg" alt="Markdown preferences pane"></p>
<p>后来非常幸运的认识了 Martin Waters ， 神奇的白开水兄。大一暑假的时候还和白开水见了面，一起继续做了真选参加了一小比赛。一开始是在一个编程开发的群认识了白开水，后来发现白开水设计的东西都惊人的漂亮。我那时会将我设计的一些不堪入目的东西交给白开水，他总是会画腐朽为神奇一般的 redesign 的非常棒。而且他总是会向我介绍一些非常神奇的工具，比如我第一次了解 Sketch 就是白开水介绍给我的，嗯，真是如同打开了新世界的大门。</p>
<p>当年暑假白开水兄画下的一些 Icon ：<br><img src="http://p1.bqimg.com/4851/d9462b5adac2aef5.png" alt="Markdown preferences pane"></p>
<h3 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h3><p>寒假的时候读了 About Face 和 设计心理学全系列的四册，算是第一次开始看设计类的书籍。后来开学之后大多数时间都在学习写 App，所以就在有了新 App 想法的时候会画上一些:</p>
<p>Roc Daily<br><img src="http://p1.bqimg.com/4851/0c3d66e925cddcac.png" alt="Markdown preferences pane"></p>
<p>教务助手<br><img src="http://p1.bqimg.com/4851/c9781d51894e0e75.png" alt="Markdown preferences pane"></p>
<p>期间还画过一些小东西，比如图标还有小组件之类的：<br><img src="http://i1.piimg.com/4851/79ffe401e3b96d0c.jpg" alt="Markdown preferences pane"><br><img src="http://i1.piimg.com/4851/2533c4dd39e62c61.png" alt="Markdown preferences pane"></p>
<p>实习的时候见到了之前仰慕已久大神们，在一旁观察他们做设计时的章法、理念、创意，还有和我们把 App 用程序写出来之后和设计稿仔细的比对调整，像素级的双眼和对细节的追求。嗯，我在钦佩的同时又开始感概道阻且长啦。</p>
<p>之后还得到了自己心心念念的 Dribbble 邀请码（我要再次再次感谢敬爱的马老师），本打算也画一波 Hello Dribbble 的我尝试了几稿后还是决定在原来的设计稿上修改一个提交，于是这就是我的 Debuts 了:</p>
<p><img src="http://p1.bqimg.com/4851/b3b7defd9c1be893.png" alt="Markdown preferences pane"></p>
<p>Dribbble 上的地址是：<a href="https://dribbble.com/shots/2969219-Hello-Dribbble" target="_blank" rel="external">https://dribbble.com/shots/2969219-Hello-Dribbble</a></p>
<p>现在感觉确实画的不好后悔把这个当 Debuts 啦。</p>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>想起来刚开始练习做设计的时候还怀疑过不写代码自己是不是跑偏了，后来觉得如果是自己想要做一个产品的话，设计和开发都是实现好产品的一种方式，本质是相同的。我想过做设计的目的是什么，嗯，应该是悦心，从设计产品的 look 到 work，好的设计总能让人感到愉悦。这太值得了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今晚逛 Dribbble 的时候突然又点开看了自己悲剧的 Debuts ，于是突然想到理理这个，正好可以也当作自己博客 Design 系列第一篇。&lt;br&gt;
    
    </summary>
    
      <category term="Design" scheme="http://www.roczhang.com/categories/Design/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 中的 Delegate 设计模式</title>
    <link href="http://www.roczhang.com/iOS%20%E4%B8%AD%E7%9A%84%20Delegate%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://www.roczhang.com/iOS 中的 Delegate 设计模式.html</id>
    <published>2016-10-24T15:32:31.000Z</published>
    <updated>2016-11-28T17:40:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近写的 iOS/Swift 代码比较多，很久没动笔又没怎么写过技术类的文章。所以决定从小小的总结一下 Delegate 模式开始写一写，因此这也是一篇入门文章。<br><a id="more"></a></p>
<h2 id="What-is-Delegate"><a href="#What-is-Delegate" class="headerlink" title="What is Delegate ?"></a>What is Delegate ?</h2><p>我想很多同学第一次遇见 Delegate 这个词是在写 tableView 的时候。那时候我也只是每每需要用的时候就照着这种模式写上 tableView.delegate = self, tableView.dataSource = self 也并不理解究竟是什么意思。</p>
<p>应该说 delegate 是 Cocoa/CocoaTouch 中的一种设计模式，正如前面提到的 tableView 一样，Cocoa 框架中很多地方都用到了这种设计模式。这种设计模式中我们可以将一个对象的一些功能委托给另一个对象来实现。因此使用 delegate 模式可以帮助我们设计出更松耦合的代码。</p>
<p>delegate 使用起来非常简单。假设我们现在需要一个电视机和一个音响，我们想要将电视机播放声音的职责委托给外置的音响来实现，我们就可以这样编写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// 首先定义一个 Protocol 协议</div><div class="line">protocol PlayAudioDelegate &#123;</div><div class="line">  func playAudio()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 编写一个遵循 PlayAudioDelegate 协议的音响对象，实现协议中的方法</div><div class="line">class Speaker: PlayAudioDelegate &#123;</div><div class="line">  func playAudio() &#123;</div><div class="line">    printLog(&quot;Start Play!&quot;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 编写电视机</div><div class="line">class TV &#123;</div><div class="line">  // delegate 可以为任何遵守 PlayAudioDelegate 协议的对象</div><div class="line">  var delegate: PlayAudioDelegate?</div><div class="line"></div><div class="line">  func play() &#123;</div><div class="line">    // 当 delegate 对象存在时，调用对象的 playAudio 方法</div><div class="line">    delegate?.playAudio()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let tv = TV()</div><div class="line">let speaker = Speaker()</div><div class="line"></div><div class="line">tv.delegate = speaker</div><div class="line">tv.play()  // printLog 将输出 &quot;Start Play!&quot;</div></pre></td></tr></table></figure>
<p>如上，使用起来并不复杂，但还是存在一些问题的。</p>
<h2 id="可选"><a href="#可选" class="headerlink" title="可选"></a>可选</h2><p>上面的例子里，我们使用 PlayAudioDelegate 这个 Protocol 来定义了一些方法，我们也知道 Swift 中当让一个类遵循某个协议的时候，这个类中必须将 Protocol 中定义的所有属性和方法实现，否则编译器将报错。</p>
<p>但实际情况中，我们可能只需要当前类实现 Protocol 中的部分方法，就好像在使用 tableView 中，我们并不是想要每一次都需要将 UITableViewDelegate 和 UITableViewDataSource 中所有方法都全部实现。</p>
<p>我们有两种方法来实现 Protocol 中的可选。</p>
<h3 id="objc"><a href="#objc" class="headerlink" title="@objc"></a>@objc</h3><p>一种是借用 @objc 关键字来实现。我们可以在定义 Protocol 时在前面加上 @objc 关键字，然后在协议中需要定义为可选的方法前也加上 @objc 和 optional 来定义一个可选方法。如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@objc protocol PlayMediaDelegate &#123;</div><div class="line">  @objc optional func playAudio()</div><div class="line">  @objc optional func playVideo()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样在需要类遵循 PlayMediaDelegate 协议时其中的 playAudio() 和 playVideo() 方法就不再是必须要实现的。</p>
<h3 id="extension-Protocol"><a href="#extension-Protocol" class="headerlink" title="extension Protocol"></a>extension Protocol</h3><p>第二种方法，也是我个人更常用的方法，就是将协议扩展，给出协议中方法的默认实现来达到不需要在遵循 protocol 的类中必须实现所有方法的效果。</p>
<p>我们使用 Swift 中的 extension 来对 Protocol 进行扩展。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// MARK: - PlayMediaDelegate Protocol</div><div class="line">protocol PlayMediaDelegate &#123;</div><div class="line">  func playAudio()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// MARK: - Extension PlayMediaDelegate Protocol</div><div class="line">extension PlayMediaDelegate &#123;</div><div class="line">  func playAudio() &#123;</div><div class="line">    printLog(&quot;Play Audio Now&quot;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，我们通过在扩展中给出需要可选方法的默认实现，也可以达到效果。在使用时，遵循当前 Protocol 的类在不实现方法时将使用 extension 中的默认实现。当然，你也可以再类中给出这个方法重新实现。</p>
<h2 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h2><p>倘若你对内存管理和 ARC 有一定的理解，你可能会发现我们在上面的代码中可能存在一些问题（ 内存管理和 ARC 这里就不展开了）。<br>为了避免循环引用，我们可能会通过尝试在 delegate 前加上 weak 来声明当前类不负责保持 delegate 这个对象，让它的销毁由外部控制。从而利用 ARC 的这个特性帮助我们完成内存管理。如将上面的例子改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">protocol PlayAudioDelegate &#123;</div><div class="line">  func playAudio()</div><div class="line">&#125;</div><div class="line"></div><div class="line">class TV &#123;</div><div class="line">  weak var delegate: PlayAudioDelegate?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但很快就会发现编译器报错了。</p>
<p>为什么？<br>在 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID281" target="_blank" rel="external">Apple 爸爸的这篇文档</a> 里，我们可以知道：</p>
<p>1) Swift 中的 Protocol 是可以 class, struct, enum 这些类型都可以遵循的<br>2) 而 struct, enum 并不通过 ARC 来管理内存，所以 ARC 中的 weak 并不能用来修饰</p>
<p>那应该怎么办？</p>
<p>答案是将 Protocol 限制为 Class-Only Protocol，也就是只能被 class 而不能被其他类型遵循的协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">protocol PlayAudioDelegate: class &#123;</div><div class="line">  func playAudio()</div><div class="line">&#125;</div><div class="line"></div><div class="line">class TV &#123;</div><div class="line">  weak var delegate: PlayAudioDelegate?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就可以啦。</p>
<p>此外，为什么 class TV 中的 delegate 我们用了 optional 类型，因为我们使用了 weak 来修饰 delegate， 这就有可能导致 delegate 在使用过程中变为 nil，所以我们需要使用 optional 类型。否则编译器也将报 “ ‘weak’ variable shoule have optional type ‘…?’ “ 错。</p>
<h2 id="See-you"><a href="#See-you" class="headerlink" title="See you"></a>See you</h2><p>Created by ROC Zhang on 2016-10-24.<br>Copyright © 2016 ROC Zhang. All rights reserved.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近写的 iOS/Swift 代码比较多，很久没动笔又没怎么写过技术类的文章。所以决定从小小的总结一下 Delegate 模式开始写一写，因此这也是一篇入门文章。&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>跨越大二下：（一）</title>
    <link href="http://www.roczhang.com/%E8%B7%A8%E8%B6%8A%E5%A4%A7%E4%BA%8C%E4%B8%8B%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>http://www.roczhang.com/跨越大二下：（一）.html</id>
    <published>2016-08-14T15:49:38.000Z</published>
    <updated>2016-11-28T17:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>北京时间2016年8月14日23点49分。</p>
<p>日子真的过的好快，就这样到了8月中旬。来帝都已经两周多了，实习的日子应该也只剩下两周，之后紧接着又要开学。一直想把从上学期到现在蛮久一段时间的事情理一理，却又一直没能真正坐下来动笔。呼～就今天开始吧。</p>
<p>嗯，还是先闪回到上学期的日子，慢慢开始理吧。<br><a id="more"></a></p>
<h2 id="3月-6月"><a href="#3月-6月" class="headerlink" title="3月-6月"></a>3月-6月</h2><h3 id="在学校的糟糕生活"><a href="#在学校的糟糕生活" class="headerlink" title="在学校的糟糕生活"></a>在学校的糟糕生活</h3><p>说起来大二下这一个学期我过的并不愉快。这一学期似乎我的的确确没有在其他事情上花很多时间，生活方式简单到概括起来除去我在实验室写代码的时间只剩下在寝室弹吉他、去看电影、和好友约饭。而且这些其他的事情占的比例其实很小。然而在学校的日子到后面开始让我越发感到煎熬起来，甚至很多事我也越来越不想参与，有不少课我都没有去上而是在实验室继续做自己的事。总结其原因，我觉得真的可以用 JustZht 说的三观不合来回答。真的开始感觉自己越来越和这个学校很多人三观不合。我并不想而且也没有啥资格去评价别人的生活方式价值取向如何如何，因为每个人的生活完全是自己的事，被自己不认可的人干预和评价并不是一件愉快的事情。</p>
<p>但于我单方面而言，这种三观不合给我在学校的生活带来很多不适。举例来说，就比如之前和寝室里其他同学越发不可调和的冲突，使得这种不合已经逐渐到了开始让我感觉恶心的一步。我对别人生活的选择是无权干涉，但每天每周每月每学期夜里两三点还有音乐播放和台灯照射，每天午休都是打印机的声音与游戏鼠标的劈劈啪啪，这种种的事情已经对我的生活造成了无法回避到无法忍受的困扰。而即便是这种情况居然还会有其他同学的评论是我应该体谅容忍，我对自己胸怀的狭小真是感到抱歉。又或是在技术方面，实际上身处若大的一个计科院，你却很难感受得到对技术的热情。因为并没有太多人热衷于关注和讨论行业相关的事情。本来就没有多少人关心技术，所以更是没多少人关心新技术。并且整个学校也总是会时不时弥漫着面向创业、面向 PPT 编程的氛围，所以在学校也难以找到几个聊得来的同学。可能只有实验室算是要好一些的地方。</p>
<p>于此种种，大事小事，似乎真的只能用三观不合来解释了。我也越来越不愿意和别人理论争论什么，因为很多事说起来似乎都是小事，说大了那就是三观问题，浪费生命在这些事上没有意义。</p>
<p>解决？我已经决定大三开学就搬出去了，学习技术或者准备考研，这种事情放在我的寝室里是永远无法进行下去的事情。而其他的不合，回避。保持和能聊得来的朋友的日常交际，就已尽非常足够了。</p>
<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>这学期开始给自己添了一些新设备。一是从 WASD 定制了一个机械键盘，茶轴无刻，自选配色，看起来漂亮用起来爽。二是买了一个 DELL UltraSharp 25’ 显示器，和 MacBook 用 ThunberBolt 接起来，非常省心。还有其他的一些小东西。我总觉得在干活的家伙上开销是非常值得的，光只是这两样就让我 Coding 时候的效率和心情都高了不少。这学期也是读了不少书，一类是关于设计的书，比如寒假时 Kevin 推荐的 About Face 和设计心里学的4册，剩下的就是技术类的书了。技术上这学期开始学了 React Native，中间趁机学了一小把 Android。Android 说起来好像也就只是摸了一把，写了一个2048，所以也不能算真的学了。然后就是跟着学校点了一些数据库和 JAVA 的技能。说起来上课我是真的没有太仔细听的，到后期好像都在用纸手写代码或者带着 Kindle 去看书。这两门课都是到后来要交课程设计的时候我才开始学的，课程设计我写了一个 MySQL + JAVA + iOS App 的小系统直接当做两门课的课程设计交了两次，写了两天。JAVA 老师最后点评说这个可以当毕业设计了我是有点惊讶不知道是真是假。</p>
<p>说回上课不听的这种方式，这样当然是有不好的地方，期末之前总要体验一把绝望的感觉和被挂科支配的恐惧。但明知如此，我还是更喜欢花时间在自己钻研技术上，只是如果要考研的话，可能以后还要多花很多力气吧。不过还好，这学期依旧延续从前，没有挂科，有些科目考的还算不错。</p>
<p>关于技能除了刚才说的 React Native \ Android \ JAVA \ DataBase 这些，主要时间还是花在 iOS 上了。开始学习了 Apple 的 SpriteKit 和 SceneKit, 然后重新好好读了一些关于 Swift 的文章，感觉起来对很多 Swift 里的概念和特性又有了新的理解，比如函数式的一些有趣的东西。之后写了两个至今难产的 Project， 虽然产品难产，但过程里还是收获了不少，包括 GCD, CA, CG 之类。造了两个小轮子。但我开始感觉自己之前尤其是大一的时候好像走了弯路，浪费了不少时间，对 iOS ，真的是要继续深入不停学习才是，自己还是太嫩了。</p>
<p>其他，这学期体验了一把代教选修课。到最后感觉并不特别愉悦，总让我感觉无论是学校还是学生对待选修课似乎都不是一个严肃的事情，比如选修课时间总是会被各种事情占用，让人感觉似乎就不是一个严肃的教学和学习的地方。不过也无妨，这种事情本来还是看个人自己的呗，靠外面 PUSH 有啥子用。</p>
<p>快期末的时候受一位老师指点去研究一个开源的物联网项目。趁此机会又一次的温故和学习了一些 Linux 相关的，还有部署之类的，最后花了一些时间去了解使用了 MongoDB ／ Maven / MQTT , 也仅限是了解和尝试，并没有深入。</p>
<p>还有不知道算不算是技术上的，这学期去考的那个软件设计师，之前查询结果通过了，所以也是在大二结束了这个事情。我个人对考证的兴趣是不大的，而且这个考试并不会对某一个方面有很深入的考察，但是横向的面却撒的很大。考着玩是可以的，我也没有在准备这个考试上花时间，甚至是交报名表和打印准考证的时间。哈，这要感谢我们实验室被称为小暖男的学弟。</p>
<p>最后，在今年的 WWDC 第二天去注册了 Apple Developer Program。为啥这么晚注册呢，因为之前好像没咋考虑过要上架的事情？所以以后每年 WWDC 续费 Developer Program 的时候还可以提醒自己想想干了啥。然后还有幸去参加了的的确确是 Apple 举办的一个小型研讨会，中途茶歇的时候还和一位 Apple 的人员简单的交流了一会儿，非常棒的体验。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>从开始练习 FingerStyle 的指弹吉他演奏，这学期还是有一直坚持继续练习吉他。这学期弹会的曲子不多，把之前的 Kujira 练熟了，之后学弹了 Little Martha 、Rings 和 Voyage for Ireland，一共换了两幅弦，还是 Elixir 11025 。值得一提的是，5月的时候和阿汪一起去听了 Pierre Bensusan 的武汉场演奏会，坐在内场5排，第一次亲眼见到三叔，印象非常深刻。感觉三叔确实老了，但在现场亲耳听到 So Long Michael 、 WuWei 等等自己听了许久的 DADGAD 名曲的时候确实很感动。想起自己当时学弹 FingerStyle 可能也就是为了演奏三叔的 WuWei …</p>
<p>其实因为说起来在学校好像也没有什么健康有趣适合我的放松方式，加上我又是一个完全玩不转游戏的人，所以写代码和看书之外的放松，我就会去看电影或弹吉他。去看电影的话平均每周可能至少都会抽出时间去看一次，算起来好像上学期也看了20场以上了。其中当然一个人也会去，我想大部分人都会非常享受能有一段完全属于自己而不会被别人打扰的放松时间。</p>
<p>所以这两种放松的方式实在是非常适合我。</p>
<p>惭愧的是本学期依然没有开始好好锻炼身体，以至于现在每当我和班上同学说起我要去锻炼身体一事，他们的脸上总是会透露出让我难以名状的笑容。然而严肃的说，现在可能坐的时间对着屏幕的时间越来越多了，有时候也会通宵 Coding，我有时候能感受到自己身体发出的不舒适的信号。所以剩下能在学校继续呆的一年多的时间，放掉其他的事情之后，锻炼身体是必须的了。而且在学校的日子里，饮食上也总是很难挑选或者控制。</p>
<p>于此乎，2016年6月结束。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;北京时间2016年8月14日23点49分。&lt;/p&gt;
&lt;p&gt;日子真的过的好快，就这样到了8月中旬。来帝都已经两周多了，实习的日子应该也只剩下两周，之后紧接着又要开学。一直想把从上学期到现在蛮久一段时间的事情理一理，却又一直没能真正坐下来动笔。呼～就今天开始吧。&lt;/p&gt;
&lt;p&gt;嗯，还是先闪回到上学期的日子，慢慢开始理吧。&lt;br&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.roczhang.com/categories/Life/"/>
    
    
  </entry>
  
</feed>
