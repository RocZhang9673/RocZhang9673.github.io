<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Roc Zhang&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.roczhang.com/"/>
  <updated>2018-04-18T13:59:21.532Z</updated>
  <id>http://www.roczhang.com/</id>
  
  <author>
    <name>Roc Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018.04.18</title>
    <link href="http://www.roczhang.com/20180418.html"/>
    <id>http://www.roczhang.com/20180418.html</id>
    <published>2018-04-18T13:05:15.000Z</published>
    <updated>2018-04-18T13:59:21.532Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.roczhang.com/images/20180418/01.jpg" alt="Markdown preferences pane"></p>
<p>临近毕业了。一期一会，世当珍惜。 </p>
<a id="more"></a>
<p>‘I thought of all of the time passing by.’ - No One But You</p>
<iframe src="https://open.spotify.com/embed/track/4ae9ASpdH2cpz3aX1TJvsA" width="100%" height="80" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe>


<h3 id="Updates"><a href="#Updates" class="headerlink" title="Updates"></a>Updates</h3><p>上周匆匆忙忙完成了毕业设计和论文，写的是一个最简单的 TensorFlow 模型训练然后应用到 iOS 的 App 里。周五回了学校，答辩还算顺利，后续应该只用提交二次查重再打印成册就完成了。但还有一篇双学位的论文没有写，有些头疼。六月领毕业证，所以理论上还剩最后两个月的学生身份。 </p>
<p>4 月初提交了 Swift Playground 申请 WWDC Scholarship。实际上今年比去年还没有信心，但毕竟这是最后一次机会了，不再试一次总感觉自己以后会后悔。今年总是感觉比去年穷很多，实习工资加上卖 App 的收入基本每个月还是没有结余。如果 Scholarship 没抽中，公司有一个去 WWDC 的机会，但由于目前自己依然是实习生的身份所以不能完全报销。自己是非常想去，然而 3 万块对我现在都是 unaffordable 的状态，实在是有点纠结和伤感了。 </p>
<p>从去年 10 月来流利说到现在不知不觉就已经半年过去了。公司两周一版本的迭代节奏还是挺快的，但和同事相处的都挺愉快，自己的个人生活节奏也比去年稳定了很多。回顾自己技术有进步，但日常工作外的整理和输出还是太少了。</p>
<p>买了 Spotify Premium 之后发现自己近期听歌的口味有变化，居然开始喜欢 Stayin’ Alive 这类复古的 Disco 了… 最近看了黑豹和头号玩家，黑豹除了感觉衣服挺骚气没觉得很好看。但头号玩家看了第一遍之后没忍住又去看了一遍 IMAX 版本。看完之后总会有一种从盛大的梦境中醒来的感觉，上一次看你的名字时也有这种感觉。如果说只有少年才是有梦的那这种梦就是想象力吧。Silicon Valley S5 开播了，E4 里借 Jian Yang 黑中国互联网加上最后的 BGM 实在是黑的太妙了。</p>
<h3 id="Apps"><a href="#Apps" class="headerlink" title="Apps"></a>Apps</h3><p><a href="https://itunes.apple.com/cn/app/adonis/id1281626299?l=en&amp;mt=8" target="_blank" rel="external">Adonis</a> 上架到现在大概卖了几千份，并不算好。我也看到了 Adonis 上存在的一些问题，只能逐渐演进。 </p>
<p><a href="https://itunes.apple.com/cn/app/mr-weather/id1198461086?l=en&amp;mt=8" target="_blank" rel="external">Mr.Weather</a> 去年 5 月份上架，到现在已经有几万的用户，而且虽然很久没有更新，每天还是有挺稳定的增长。我觉得 Mr.Weather 上还有一些想做但没实现的，所以几个月前开始设计 Mr.Weather 2，开发进度比较慢，但争取在今年 5 月 Mr.Weather 上架一周年的时候发布新版本。想了想可能会使用年订阅的方式。剧透一下 Mr.Weather 2: </p>
<p><img src="http://www.roczhang.com/images/20180418/02.jpg" alt="Markdown preferences pane"></p>
<p><a href="https://itunes.apple.com/cn/app/year-timer/id1359786804?l=en&amp;mt=8" target="_blank" rel="external">Year Timer</a> 属于写着好玩的类型吧，本身只花了半天的开发时间，上架之后也没有做任何宣传什么，只是满足个人的一个小需求。</p>
<p>至此就有三个已经上架的个人 App 了。之前建了一个 <a href="https://join.slack.com/t/roczhang/shared_invite/enQtMjgwMDQ5NjM5NDg4LWIxMTQzNmU1NmZkZmUxMDY0Y2ZhYjE4ZDI5M2ZiYTkxMjVmM2E5ZTkyYWNhMTVmMTg2ZjFhNzU0MTY4YzRhZjA" target="_blank" rel="external">Slack Group</a>，三个 app 在 group 里都有独立的 channel。我无法肯定这些 App 本身的价值，但这是我个人想法的延伸与表达的方式。所以我觉得那些抄袭别人作品的实在没有任何意义，抄袭别人的自我表达反而代表着自己没有任何想法。</p>
<h3 id="Thoughts"><a href="#Thoughts" class="headerlink" title="Thoughts"></a>Thoughts</h3><p>回学校的时候和同学与朋友聊了挺多，基本是交换自己的现状，对离开学校有不舍和感伤。我当然也是有一些，但再次去往几处之前去过的地方，便发现自己怀念的并不是单纯的地点或人，只是怀念自己之前的这一段经历罢了。也发现对之前发生的让自己曾感到不爽的事情没有那么在意了，并没有什么必要去感到伤感或愤怒，关注自己收获到了什么就好。但还是提醒自己珍惜每一段经历，虽然有“要珍惜”这种念头本身就影响了全身心投入，而不算是纯粹的珍惜了。</p>
<p>感觉自己是一个挺矛盾的人。看不清未来的时候会很焦虑，看到未来可能没有变化的时候也会很焦虑。平常很少有可以倾诉个人想法的对象，因此独处会是自己绝大多数的处境。虽然这在大多数情况下不会是什么问题，但总会有想要倾诉分享的时候。所以只能观察自己，反思自己在矛盾中的选择。 </p>
<p>发现自己还有一个 Telegram 的 Channel，之前是为了 Mr.Weather 建立的，但显然当时还没有了解 Telegram Channel 的运作方式，所以后来 Mr.Weather 就迁移到 Group 和 Slack 上去了。但 Channel 这种只能广播无法回复的方式确实挺好的，所以把 Channel 改了名，会不定期分享自己的开发和境遇。欢迎关注：<a href="https://t.me/roczhangchannel" target="_blank" rel="external">https://t.me/roczhangchannel</a> 。</p>
<p>今天看到 Kevin 的博客，离开了多点去了青岛，实在非常钦佩。Kevin 哥很多时候给我了精神上的鼓舞，祝福 Kevin！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.roczhang.com/images/20180418/01.jpg&quot; alt=&quot;Markdown preferences pane&quot;&gt;&lt;/p&gt;
&lt;p&gt;临近毕业了。一期一会，世当珍惜。 &lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.roczhang.com/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>翻译：iOS Code Signing (一)、（二）</title>
    <link href="http://www.roczhang.com/%E7%BF%BB%E8%AF%91%EF%BC%9AiOS%20Code%20Signing%20(%E4%B8%80)%E3%80%81%EF%BC%88%E4%BA%8C%EF%BC%89.html"/>
    <id>http://www.roczhang.com/翻译：iOS Code Signing (一)、（二）.html</id>
    <published>2018-03-03T02:16:03.000Z</published>
    <updated>2018-03-03T02:57:03.335Z</updated>
    
    <content type="html"><![CDATA[<p>翻译来自 iOS Code Signing 系列第一、二篇。<br>原作者：SHASHIKANT JAGTAP<br>翻译者：Roc Zhang<br><a id="more"></a><br>如有任何问题还请留言指出。  </p>
<p>E-mail: roczhang9673@gmail.com<br>Weibo: @张鹏roczhang<br>Twitter: @Lighters9673</p>
<hr>
<h1 id="Post-1-入门"><a href="#Post-1-入门" class="headerlink" title="Post 1: 入门"></a>Post 1: 入门</h1><p>这是 iOS 代码签名教程系列的第一部分。此系列涵盖了 iOS 代码签名过程的基础知识，此系列的全部文章为：</p>
<ul>
<li>iOS Code Signing: 1. Getting Started  <a href="http://shashikantjagtap.net/ios-code-signing-1-getting-started/" target="_blank" rel="external">原文</a> <a href="http://www.roczhang.com/%E7%BF%BB%E8%AF%91%EF%BC%9AiOS%20Code%20Signing%20%28%E4%B8%80%29%E3%80%81%EF%BC%88%E4%BA%8C%EF%BC%89.html">译文</a></li>
<li>iOS Code Signing: 2. Certificate Signing Requests  <a href="http://shashikantjagtap.net/ios-code-signing-2-certificate-signing-requests/" target="_blank" rel="external">原文</a> <a href="http://www.roczhang.com/%E7%BF%BB%E8%AF%91%EF%BC%9AiOS%20Code%20Signing%20%28%E4%B8%80%29%E3%80%81%EF%BC%88%E4%BA%8C%EF%BC%89.html">译文</a></li>
<li>iOS Code Signing: 3. Certificates  <a href="http://shashikantjagtap.net/ios-code-signing-3-certificates/" target="_blank" rel="external">原文</a></li>
<li>iOS Code Signing: 4. Provisioning Profiles  <a href="http://shashikantjagtap.net/ios-code-signing-4-provisioning-profiles/" target="_blank" rel="external">原文</a></li>
<li>iOS Code Signing: 5. Signing iOS App  <a href="http://shashikantjagtap.net/ios-code-signing-5-signing-ios-app/" target="_blank" rel="external">原文</a></li>
</ul>
<p>通常，iOS 设备仅能够运行被信任的开发者所签名的 app，除非是对设备进行了越狱。如果你是一个 iOS 工程师，你肯定和代码签名在某些方面打过交道。由于代码签名是每个 iOS 开发者都无法逃避且最让人痛苦和繁琐的工作之一，除非开发者能够完全理解关于代码签名的基础知识，否则代码签名和 Provisioning Profile 将会成为一个一直伴随你的烦恼。这是一篇入门介绍文章，阐述了代码签名的过程及其优点与局限。</p>
<h2 id="关于此系列"><a href="#关于此系列" class="headerlink" title="关于此系列"></a>关于此系列</h2><p>iOS 应用的代码签名对每一个 iOS 开发者来说都是热门话题。尽管网络上已经有很多资源存在，并且 Apple 也给出了清晰的文档，但它看起来仍然像一个谜。在这个系列中，我们将尝试从头开始去理解代码签名，包括代码签名需要什么，以及代码签名自身的处理过程。我们同样会探讨如何使用 GUI 与命令行去实现。我们将从 Certificate Signing Request 开始得到一个 iOS 开发证书，之后我们将聊到证书和其内部组成部分。在理解证书之后，我们将会深入到 Provisioning Profiles，最后我们将能够理解代码签名的整个过程。<br>这个系列的文章是我自己通过研究网上的资料与 Apple 的文档所写出的，我已将这些引用材料列在了最后一篇文章中。同样我也附带了一些来自 Apple Developer 网站与 Xcode 的截图，以便于读者能够理解这些概念。我已经试图隐藏了所以的敏感内容，但如果依然有被不小心暴露出来的，还请不要黑我 🙂。</p>
<h2 id="代码签名"><a href="#代码签名" class="headerlink" title="代码签名"></a>代码签名</h2><p>在我们开始了解 Apple 对 iOS 应用所进行的代码签名方式之前，先让我们大体上探讨一下代码签名。在现实生活中，我们会在各种不同的合同、协议上签名。那么为什么要进行签名？为什么签名对我们而言如此重要？通常这是因为签署合同能在法律上保护我们，并且我们相信合同上的任何条款都不会被篡改。签名同样还能确保合同来自受信任的机构而非诈骗者以确保安全。这就意味着签合同能够带给我们安全、保障与信赖。</p>
<p>同样，代码签名是指对代码进行数字签名，以确保谁编写了代码及代码在签名时没有发生更改或损坏。代码签名使用加密哈希算法来验证软件代码的真实性与完整性。在软件的世界里，代码签名确保了作者的身份、代码的完整、构建系统与版本，使得软件的用户在使用时能感到可靠与安全。代码签名使用了多种安全项如私钥、公钥、证书、数字签名等。不同的代码签名方法会被用在如 Linux、Windows 、macOS 等不同的平台上。</p>
<h2 id="iOS-代码签名"><a href="#iOS-代码签名" class="headerlink" title="iOS 代码签名"></a>iOS 代码签名</h2><p>Apple 据说有着十分强大的安全机制，除去一些你最近可能在新闻中看到的小毛病。对黑客来说很难打破这种安全机制。Apple 同样也使用了非常强大的代码签名机制以保证从 Apple App Store 下载的 iOS App 的安全性与完整性。大多情况下，iOS 的代码签名就好像是发生在幕后的黑魔法。如果它工作良好，每个人都会很开心，然而一旦出现问题则会让每个人都陷入恐慌。大多数 iOS 工程师对这幕后的签名过程都不甚了解。最近 Apple 发布了 ‘Automatic Signing (自动签名)’ 功能以帮助减少代码签名所带来的痛苦，不让代码签名打断主要开发流程。Apple 平台上的代码签名依赖于 X.509 标准的公钥加密，我们稍后将在此系列中讨论这些工具和技术。</p>
<h2 id="为什么要学习-iOS-代码签名"><a href="#为什么要学习-iOS-代码签名" class="headerlink" title="为什么要学习 iOS 代码签名"></a>为什么要学习 iOS 代码签名</h2><p>现如今代码签名的大多数工作都由 Xcode 处理，那么为什么我们应该关心代码签名以及为什么要投入时间去了解它？</p>
<p>这里是一些为什么要学习代码签名内部原理的原因：</p>
<ul>
<li>iOS 工程师直接从安装在本地机器上的 Xcode 部署 iOS 应用的日子已经一去不复返了。现如今的公司正使用 DevOps 和 CI/CD 来构建软件，以便于所以构建工作都能够在无需人力或与 GUI 交互的情况下自动完成。</li>
<li>开发人员因 Xcode 代码签名失败，试图通过重新生成与修复证书和配置文件来修复代码签名问题上耗费了大量的时间。<br>第三方工具如 Fastlane 可以让 iOS 开发者更加轻松地创建 build 脚本。然而，当 Apple 在底层技术上作出更改，Fastlane 将无法使用，开发人员会花费数小时、数天甚至数周时间来修复损坏的部署脚本。在某些情况下，工程师们必须等到 Fastlane 实现了新更改。</li>
<li>如果你是一个 iOS 开发人员或工程师，并只是想一直做一个 iOS 工程师，那么你没有必要去学习这些知识。但如果你想要在你的职业生涯中成长，那么你就必须要详细了解这些底层工具、技术和整个 iOS 生态。如果你不了解这些底层技术，不管你在 iOS 开发技术上有多出色，都无法让你成为一个 iOS 技术主管或一个 iOS 技术架构师之类的角色。作为一个技术架构师，你应该能够在不依赖于 Xcode 或其他第三方工具的情况下快速修复代码签名或类似的基础架构问题。</li>
</ul>
<p>希望这能足以证明代码签名的重要性。要学习还是离开取决于你。</p>
<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>让我们进入 iOS 代码签名的世界。我们将从头开始涵盖全部所需与其在底层所做的事。开始前我们需要以下准备：</p>
<ul>
<li>macOS</li>
<li>Apple Developer Membership</li>
<li>Xcode 9+</li>
</ul>
<p>所有这些你都准备好后，就可以开始深入了解 iOS 代码签名了。</p>
<h2 id="代码签名的好处"><a href="#代码签名的好处" class="headerlink" title="代码签名的好处"></a>代码签名的好处</h2><p>Apple 之所以要我们经历繁琐的代码签名流程是因为这对用户有一定的益处。当用户从 Apple App Store 上下载 app 时他们能感到安全，是因为代码签名保证了：</p>
<ul>
<li>合法的开发者编写了这些代码，且具有 app 作者或签发者的身份</li>
<li>代码签名保证了代码在作者编写之后没有被其他人篡改过。它保证了作者生成的代码是原始的，并且在作者签名之后没有任何其他东西被注入到原始代码中。</li>
<li>用户能够从他们信赖的开发人员那里下载应用，而不必担心太多安全问题。</li>
<li>代码签名是为了保证 iOS 用户的安全，以让他们使用从 AppStore 下载的应用时感到可信赖。</li>
</ul>
<h2 id="代码签名的局限"><a href="#代码签名的局限" class="headerlink" title="代码签名的局限"></a>代码签名的局限</h2><p>尽管代码签名是为了用户的安全，但在有些方面并不总能解决安全问题。</p>
<ul>
<li>代码签名保证了代码来自 Apple 开发者计划成员认证的合法开发者，但不能保证代码本身没有安全漏洞。</li>
<li>代码签名不能保证在 App 运行期间动态加载的插件是安全的。</li>
<li>对已签名的代码没有数字版权管理或拷贝保护技术。</li>
</ul>
<p>现在，我们已经了解了学习代码签名的重要性，以及代码签名的好处和局限。在下一篇文章里，我们将会了解重要概念：代码签名过程是如何开始的，即 Certificate Signing Requests 证书签名请求。</p>
<hr>
<h1 id="Post-2-证书签名请求"><a href="#Post-2-证书签名请求" class="headerlink" title="Post 2: 证书签名请求"></a>Post 2: 证书签名请求</h1><p>在上一篇文章中，我们已经说到了代码签名的基础知识，它所带来的好处及局限。现在我们将开始了解一些代码签名的概念。让我们先从所有代码签名起始的地方—-证书签名请求开始。也许你已经知道我们需要一个 development （开发）和一个 distribution （发布）证书来把一个 app 构建和部署到 AppStore。创建一个 iOS 开发证书是每一个 iOS 开发者都需要做的第一步。创建证书的过程从证书签名请求开始。在这片文章中，我们将会涵盖证书签名请求的概念（Certificate Signing Request，CSR）及使用 CSR 来请求证书的过程。</p>
<h2 id="什么是-CSR"><a href="#什么是-CSR" class="headerlink" title="什么是 CSR"></a>什么是 CSR</h2><p>代码签名请求 CSR 是一个由申请人向证书颁发机构发送的用于申请数字身份证书的消息。它使用了 <a href="https://en.wikipedia.org/wiki/Public_key_infrastructure" target="_blank" rel="external">Public Key Infrastructure</a> 公钥基础设施，是一种用于创建、管理与分发数字证书的策略。创建 CSR 的过程在 PKI 中非常规范化，申请人需要在本地机器上生成公钥和私钥，之后申请人需要将公钥与个人信息如邮箱、县等附在 CSR 中。申请人持有私钥。CSR 需要的典型信息包括：CN（通用名称）、组织、组织单位、国家、邮箱。CSR 包含了证书请求信息、签名算法和请求者的数字签名，以防止请求伪造证书。</p>
<h2 id="将-CSR-发送给-Apple"><a href="#将-CSR-发送给-Apple" class="headerlink" title="将 CSR 发送给 Apple"></a>将 CSR 发送给 Apple</h2><p>Certificate Signing Request（CSR）指的是从证书机构（CA）申请证书的过程，这里的证书机构就是 Apple，以便 Apple 能够在请求者详细信息正确的情况下发放开发者证书。请求需要从本地 macOS 机器上创建。</p>
<h2 id="从-GUI-创建-CSR"><a href="#从-GUI-创建-CSR" class="headerlink" title="从 GUI 创建 CSR"></a>从 GUI 创建 CSR</h2><p>CSR 可以通过 Keychain Access 来创建，Apple 编写了一些<a href="https://support.apple.com/kb/PH20128?locale=en_US" target="_blank" rel="external">文档</a>，但总结起来你需要做的是：</p>
<ul>
<li>在 Spotlight（聚焦搜索）中找到 Keychain Access（钥匙串访问）</li>
<li>选择 Keychain Access（钥匙串访问） &gt; Certificate Assistant（证书助理） &gt; Request a Certificate From a Certificate Authority（从证书颁发机构请求证书）</li>
<li>填写你的详细信息，如邮箱、姓名和国家，通常跟随屏幕上的指示就好</li>
<li>选中选项 “Saved to disk（保存到磁盘）”</li>
<li>指定一个文件名，点击保存</li>
<li>点击继续，之后证书助理会创建一个 CSR 并将其保存在你的电脑上</li>
</ul>
<h2 id="从命令行创建-CSR"><a href="#从命令行创建-CSR" class="headerlink" title="从命令行创建 CSR"></a>从命令行创建 CSR</h2><p>如果觉得用 GUI 麻烦，同样也有使用命令行创建 CSR 的方法。你可以通过运行几个快捷命令来拿到  CSR，只要将你的名字、邮箱与国家填写上去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ openssl genrsa -out mykey.key 2048</div><div class="line">$ openssl req -new -key mykey.key -out CertificateSigningRequest.certSigningRequest -subj &quot;/emailAddress=yourAddress@example.com, CN=Your Name Dev Key, C=GB”</div></pre></td></tr></table></figure>
<p>在过程结束时，你就可以在本地 mac 上看到一个有着奇怪名字的文件：CertificateSigningRequest.certSigningRequest，这就是我们需要上传给 Apple Developer 用于生成开发与发布证书的文件。我们将在稍后介绍证书。</p>
<p>现在，我们的本地机器上就有了我们的 CSR。让我们来了解一下创建 CSR 时发生了些什么：</p>
<ul>
<li>在创建 CSR 时，公钥/私钥对被生成</li>
<li>公钥被附在你的 CSR 上</li>
<li>私钥被保存在你的本地机器中</li>
</ul>
<p>如果你想了解更多有关公钥/私钥的知识以及他们是如何运作的，你可以阅读 <a href="https://cryptography.io/en/latest/hazmat/primitives/asymmetric/" target="_blank" rel="external">Asymmetric Cryptography</a> 非对称加密，但大体上公钥用在公共环境，私钥是私人持有的，你不应该将它分享给任何人。</p>
<p>现在来看一下 CSR 内部有些什么。在你的终端中运行下面的命令，这将会把 CSR 内部的基本信息显示出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openssl asn1parse -i -in CertificateSigningRequest.certSigningRequest</div></pre></td></tr></table></figure>
<p>如果你想看到以文本方式显示 CSR，看到公钥算法 rsaEncryption 和签名算法 sha256WithRSAEncryption，你可以运行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openssl req -text -noout -in CertificateSigningRequest.certSigningRequest</div></pre></td></tr></table></figure>
<p>这个密钥对由 RSA(2048 bit) 生成，公钥附在 CSR 中，私钥被用于实际签名，所以我们必须保持私密。在多个 macOS 上生成 CSR 不是一个好主意，因为用一台 mac 生成的密钥对不能被呈现在另一台 mac 上。直到我们创建 P12 格式的证书之前，最好使用一台 mac 来生成 CSR。</p>
<p>现在，我们已经看到了如何通过钥匙串访问及使用命令行来创建 CSR，在下一篇文章中，我们将会了解 iOS 开发与发布所需证书的细节。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译来自 iOS Code Signing 系列第一、二篇。&lt;br&gt;原作者：SHASHIKANT JAGTAP&lt;br&gt;翻译者：Roc Zhang&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>翻译：Clean Swift iOS Architecture for Fixing Massive View Controller （二）</title>
    <link href="http://www.roczhang.com/%E7%BF%BB%E8%AF%91%EF%BC%9AClean%20Swift%20iOS%20Architecture%20for%20Fixing%20Massive%20View%20Controller%20%EF%BC%88%E4%BA%8C%EF%BC%89.html"/>
    <id>http://www.roczhang.com/翻译：Clean Swift iOS Architecture for Fixing Massive View Controller （二）.html</id>
    <published>2017-12-17T11:37:25.000Z</published>
    <updated>2017-12-17T16:45:03.646Z</updated>
    
    <content type="html"><![CDATA[<p>节选翻译来自 Clean Swift iOS Architecture for Fixing Massive View Controller 系列第二篇。<br>原作者：Raymond<br>翻译者：Roc Zhang<br><a id="more"></a><br>第一次尝试翻译，如有任何问题还请留言指出。  </p>
<p>E-mail: roczhang9673@gmail.com<br>Weibo: @张鹏roczhang<br>Twitter: @Lighters9673</p>
<hr>
<p>本文接<a href="http://www.roczhang.com/%E7%BF%BB%E8%AF%91%EF%BC%9AClean%20Swift%20iOS%20Architecture%20for%20Fixing%20Massive%20View%20Controller%20%EF%BC%88%E4%B8%80%EF%BC%89.html">Clean Swift iOS Architecture for Fixing Massive View Controller 翻译系列第一篇</a>继续。</p>
<h2 id="2-Interactor"><a href="#2-Interactor" class="headerlink" title="2.Interactor"></a>2.Interactor</h2><p>Interactor 包括了你 App 中的业务逻辑。用户在 UI 上点击与滑动是为了和你的 App 进行交互。ViewController 从用户界面中收集用户的输入并将其传给 interactor，然后检索一些模型并要求一些 workers 来完成工作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CreateOrderInteractorInput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(request: CreateOrderRequest)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CreateOrderInteractorOutput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">presentSomething</span><span class="params">(response: CreateOrderResponse)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderInteractor</span>: <span class="title">CreateOrderInteractorInput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">var</span> output: <span class="type">CreateOrderInteractorOutput</span>!</div><div class="line">  <span class="keyword">var</span> worker: <span class="type">CreateOrderWorker</span>!</div><div class="line"></div><div class="line">  <span class="comment">// MARK: Business logic</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(request: CreateOrderRequest)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Create some Worker to do the work</span></div><div class="line"></div><div class="line">    worker = <span class="type">CreateOrderWorker</span>()</div><div class="line">    worker.doSomeWork()</div><div class="line"></div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Pass the result to the Presenter</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> response = <span class="type">CreateOrderResponse</span>()</div><div class="line">    output.presentSomething(response)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CreateOrderInteractorInput-和-CreateOrderInteractorOutput-协议"><a href="#CreateOrderInteractorInput-和-CreateOrderInteractorOutput-协议" class="headerlink" title="CreateOrderInteractorInput 和 CreateOrderInteractorOutput 协议"></a>CreateOrderInteractorInput 和 CreateOrderInteractorOutput 协议</h3><p><strong>CreateOrderInteractorInput</strong> 协议指定了 <strong>CreateOrderInteractor</strong> 组件的输入（它遵循这个协议），<strong>CreateOrderInteractorOutput</strong> 协议则指明了输出。</p>
<p>我们在 <strong>CreateOrderInteractorInput</strong> 协议中看到了与在 <strong>CreateOrderViewControllerOutput</strong> 协议中相同的 <code>doSomething()</code> 方法。<strong>CreateOrderViewController</strong> 的输出连接着 <strong>CreateOrderInteractor</strong> 的输入。</p>
<p><strong>CreateOrderInteractorOutput</strong> 协议包含一个 <code>presentSomething()</code> 方法，<strong>CreateOrderInteractor</strong> 的输出需要支持 <code>presentSomething()</code> 。提示：此处的 output 将是 <strong>VIP Cycle</strong> 中的 <strong>P</strong>。</p>
<p>这里另一件要注意的事情则是 <code>doSomething()</code> 方法的参数是 <strong>CreateOrderRequest</strong> 类型的请求对象，这和 <strong>CreateOrderViewControllerOutput</strong> 协议中的方法签名相同。Interactor 将在这个请求对象中检索出必要的数据来完成工作。<br>同样，<code>presentSomething()</code> 的参数是一个 <code>CreateOrderResponse</code> 类型的响应对象。</p>
<h3 id="output-与-worker-变量"><a href="#output-与-worker-变量" class="headerlink" title="output 与 worker 变量"></a>output 与 worker 变量</h3><p>output 变量是一个遵循 <strong>CreateOrderInteractorOutput</strong> 协议的对象，虽然我们知道这这里它将会成为 presenter，但同样，这也不是必须的。</p>
<p><strong>CreateOrderWorker</strong> 类型的 worker 变量是一个用于创建新订单的特定对象。由于创建订单可能会涉及到 Core Data 的持久化工作以及进行网络请求，这些工作如果全部由 interactor 来完成的话它所要做的任务就太多了。要记住，interactor 还需要去验证订单，这也同样可以被提取出来，成为 interactor 的 worker 来完成。</p>
<p>控制流</p>
<p>当 <strong>CreateOrderInteractor</strong> 的输入 (即 CreateOrderViewController) 调用 <code>doSomething()</code> 时，它将首先创建 worker 对象并通过调用 <code>doSomeWork()</code> 来要求 worker 去做一些工作。然后它将构造一个响应对象并调用输出的 <code>presentSomething()</code> 。</p>
<p>下面我们来快速的了解一下 worker。</p>
<h2 id="3-worker"><a href="#3-worker" class="headerlink" title="3.worker"></a>3.worker</h2><p>一个 Profile View 可能需要从 Core Data 中获取用户，下载照片，允许用户点赞与关注等。你不想让 interactor 陷入这些任务中不知所措，相反，我们可以将其拆解成许多的 workers，每个 worker 完成一件事，之后你还可以在其他地方复用 worker。</p>
<p><strong>CreateOrderWorker</strong> 非常简单，它仅仅提供了一个接口，并实现它可以对 interactor 完成的工作。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderWorker</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">// MARK: Business Logic</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doSomeWork</span><span class="params">()</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Do the work</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-Presenter"><a href="#4-Presenter" class="headerlink" title="4. Presenter"></a>4. Presenter</h2><p>在 interactor 产生出一些结果之后，它会将其传给 presenter，presenter 会将其组织成适合展示的 view model，然后将 view model 传回给 view controll 以展示给用户。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CreateOrderPresenterInput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">presentSomething</span><span class="params">(response: CreateOrderResponse)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CreateOrderPresenterOutput</span>: <span class="title">class</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">displaySomething</span><span class="params">(viewModel: CreateOrderViewModel)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderPresenter</span>: <span class="title">CreateOrderPresenterInput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">CreateOrderPresenterOutput</span>!</div><div class="line"></div><div class="line">  <span class="comment">// MARK: Presentation logic</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">presentSomething</span><span class="params">(response: CreateOrderResponse)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Format the response from the Interactor and pass the result back to the View Controller</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> viewModel = <span class="type">CreateOrderViewModel</span>()</div><div class="line">    output.displaySomething(viewModel)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CreateOrderPresenterInput-与-CreateOrderPresenterOutput-协议"><a href="#CreateOrderPresenterInput-与-CreateOrderPresenterOutput-协议" class="headerlink" title="CreateOrderPresenterInput 与 CreateOrderPresenterOutput 协议"></a>CreateOrderPresenterInput 与 CreateOrderPresenterOutput 协议</h3><p><strong>CreateOrderPresenterInput</strong> 协议指定了 <strong>CreateOrderPresenter</strong> 组件的输入，<strong>CreateOrderPresenterOutput</strong> 则指明输出。</p>
<p>现在，<code>presentSometing()</code> 和 <code>displaySomething()</code> 方法不再需要说明了。<strong>CreateOrderResponse</strong> 参数在 interactor 和 presenter 间的边界中传递，<strong>CreateOrderViewModel</strong> 在 presenter 和 view controller 间的边界中传递，VIP 环完成了。</p>
<h3 id="output-变量"><a href="#output-变量" class="headerlink" title="output 变量"></a>output 变量</h3><p>output 变量是一个遵循 <strong>CreateOrderPresenterOutput</strong> 协议的对象，尽管我们已经知道这里它就是 view controller，但同样它也可以不是。在这里一点细微的差别是，我们需要让 output 作为一个 weak 变量，当 <strong>CreateOrder</strong> 场景不被需要它的组件都要被 deallocate 的时候来避免循环引用。</p>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>当 <strong>CreateOrderInteractor</strong> 的输出被连接到 <strong>CreateOrderPresenter</strong> 的输入时，<code>presentSomthing()</code> 方法将在 interact 完成它的任务时被调用。它会构造 view model 对象，并在 output 上调用 <code>displaySomething()</code>。</p>
<p>之前我们说过会回过头来继续 view controller 中的 <code>displaySomething()</code> 方法，这是 VIP 环中的最后一步。它会将 view model 中任意的数据展示给用户。例如，我们也许想要在文本框中显示客户的姓名：<code>nameTextField.text = viewModel.name</code>。</p>
<p>恭喜！你刚刚学到了 Clean Swift 中的精华，你现在应该能够将业务与展示逻辑从你的用户界面代码中提取出来了。别担心，在介绍例子前我们不会就这样结束，但让我们先来说完 Clean Swift 中的其他组件。</p>
<h2 id="5-Router"><a href="#5-Router" class="headerlink" title="5. Router"></a>5. Router</h2><p>当用户点击 next 按钮导航到 storyboard 中的下一个场景时，一个 segue 将会被触发，一个新的 view controller 会被展示出来。Router 的作用就是将导航逻辑从 view controller 中提取出来，它同样是将数据传给下一个场景的最佳位置。最终的结果就是，view controller 中仅仅剩下控制各类视图的工作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CreateOrderRouterInput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">navigateToSomewhere</span><span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderRouter</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> viewController: <span class="type">CreateOrderViewController</span>!</div><div class="line"></div><div class="line">  <span class="comment">// MARK: Navigation</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">navigateToSomewhere</span><span class="params">()</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Teach the router how to navigate to another scene. Some examples follow:</span></div><div class="line"></div><div class="line">    <span class="comment">// 1. Trigger a storyboard segue</span></div><div class="line">    <span class="comment">// viewController.performSegueWithIdentifier("ShowSomewhereScene", sender: nil)</span></div><div class="line"></div><div class="line">    <span class="comment">// 2. Present another view controller programmatically</span></div><div class="line">    <span class="comment">// viewController.presentViewController(someWhereViewController, animated: true, completion: nil)</span></div><div class="line"></div><div class="line">    <span class="comment">// 3. Ask the navigation controller to push another view controller onto the stack</span></div><div class="line">    <span class="comment">// viewController.navigationController?.pushViewController(someWhereViewController, animated: true)</span></div><div class="line"></div><div class="line">    <span class="comment">// 4. Present a view controller from a different storyboard</span></div><div class="line">    <span class="comment">// let storyboard = UIStoryboard(name: "OtherThanMain", bundle: nil)</span></div><div class="line">    <span class="comment">// let someWhereViewController = storyboard.instantiateInitialViewController() as! SomeWhereViewController</span></div><div class="line">    <span class="comment">// viewController.navigationController?.pushViewController(someWhereViewController, animated: true)</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// MARK: Communication</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">passDataToNextScene</span><span class="params">(segue: UIStoryboardSegue)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Teach the router which scenes it can communicate with</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> segue.identifier == <span class="string">"ShowSomewhereScene"</span> &#123;</div><div class="line">      passDataToSomewhereScene(segue)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">passDataToSomewhereScene</span><span class="params">(segue: UIStoryboardSegue)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Teach the router how to pass data to the next scene</span></div><div class="line"></div><div class="line">    <span class="comment">// let someWhereViewController = segue.destinationViewController as! SomeWhereViewController</span></div><div class="line">    <span class="comment">// someWhereViewController.output.name = viewController.output.name</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CreateOrderRouterInput-协议"><a href="#CreateOrderRouterInput-协议" class="headerlink" title="CreateOrderRouterInput 协议"></a>CreateOrderRouterInput 协议</h3><p>CreateOrderRouterInput协议指明了它的各类路由：场景可以导航到的 view controller。<code>navigateToSomewhere()</code> 方法告诉了 view controller: 如果你把我当作你的 router，我得知道该如何导航到一个叫做 somewhere 的场景。</p>
<p>正如你在 <code>navigateToSomewhere()</code> 方法中的注释中看到的那样，router 在它可以导航的场景数量上非常灵活。我将会在另一篇文章中关于 router 的全部。</p>
<h3 id="viewController-变量"><a href="#viewController-变量" class="headerlink" title="viewController 变量"></a>viewController 变量</h3><p>viewController 变量仅仅只是一个指向使用此 router 的 viewController 的引用。它是一个 weak 变量来避免循环引用问题，它被一个 configurator 配置好（稍后你就会看到）。Apple 在 segue 间转场的方式是将所有的 present 和 push 方法都放到了 UIViewController 类中。所以在这里我们需要 view controller 引用以让我们能够在 router 中调用这些方法。</p>
<h3 id="passDataToNextScene-与-passDataToSomewhereScene"><a href="#passDataToNextScene-与-passDataToSomewhereScene" class="headerlink" title="passDataToNextScene() 与 passDataToSomewhereScene()"></a>passDataToNextScene() 与 passDataToSomewhereScene()</h3><p><code>passDataToNextScene()</code> 和 <code>passDataToSomewhereScene()</code> 方法提供了一种传递数据到下一个场景中去的方式。通常你会把同样的代码放到 <code>prepareForSegue()</code> 中。<code>passDataToNextScene()</code> 将试图匹配 segue ID 以分发到更具体的会传递实际的数据的 <code>passDataToSomewhereScene()</code> 方法。</p>
<h2 id="See-you-in-the-next"><a href="#See-you-in-the-next" class="headerlink" title="See you in the next"></a>See you in the next</h2><p>第二篇先翻译到这里，坚持每周翻译一部分吧😂，下周我们再接着 configurator 继续。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;节选翻译来自 Clean Swift iOS Architecture for Fixing Massive View Controller 系列第二篇。&lt;br&gt;原作者：Raymond&lt;br&gt;翻译者：Roc Zhang&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>翻译：Clean Swift iOS Architecture for Fixing Massive View Controller （一）</title>
    <link href="http://www.roczhang.com/%E7%BF%BB%E8%AF%91%EF%BC%9AClean%20Swift%20iOS%20Architecture%20for%20Fixing%20Massive%20View%20Controller%20%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>http://www.roczhang.com/翻译：Clean Swift iOS Architecture for Fixing Massive View Controller （一）.html</id>
    <published>2017-12-09T06:49:05.000Z</published>
    <updated>2017-12-09T07:38:07.292Z</updated>
    
    <content type="html"><![CDATA[<p>节选翻译来自 Clean Swift iOS Architecture for Fixing Massive View Controller 系列第一篇。<br>原作者：Raymond<br>翻译者：Roc Zhang<br><a id="more"></a><br>第一次尝试翻译，如有任何问题还请留言指出。  </p>
<p>E-mail: roczhang9673@gmail.com<br>Weibo: @张鹏roczhang<br>Twitter: @Lighters9673</p>
<hr>
<p>开始之前: 原作者提供了付费的 <a href="https://clean-swift.com/handbook" target="_blank" rel="external">The Clean Swift Handbook</a>，以及可以通过订阅他的 list 来下载 Clean Swift 的 Xcode 模版。示例代码在原文发布后有更新，因此文中所提及代码可能与你下载到的代码有所出入。   </p>
<h1 id="Clean-Swift-适用于-iOS-上的-Clean-架构"><a href="#Clean-Swift-适用于-iOS-上的-Clean-架构" class="headerlink" title="Clean Swift - 适用于 iOS 上的 Clean 架构"></a>Clean Swift - 适用于 iOS 上的 Clean 架构</h1><p>Clean Swift 架构起源于由 Uncle Bob 提出的 Clean 架构，他们之间有很多概念互通，例如 Components 组件，Boundaries 边界，以及 Models 模型。我将会实现一个由 Uncle Bob 谈过的“创建订单”用例。Uncle Bob 使用 Java 在 Web 应用程序中做了示范，我将会向你展示如何使用 Swift 将 Clean 架构应用到 iOS 项目中。</p>
<h2 id="“创建订单”-用例"><a href="#“创建订单”-用例" class="headerlink" title="“创建订单” 用例"></a>“创建订单” 用例</h2><p>这个用例由 Uncle Bob 在 <a href="https://skillsmatter.com/skillscasts/2437-uncle-bob-web-architecture" target="_blank" rel="external">Why can’t anyone get Web architecture right?</a> 中提出。它起源于 Ivar Jacobson 的 <a href="http://www.amazon.com/Object-Oriented-Software-Engineering-Approach/dp/0201544350" target="_blank" rel="external">Object Oriented Software Engineering</a> 一书。此用例包含了 Clean Swift 中除 routing 外的绝大多数特性，是一个非常好的例子。</p>
<p><strong>Data 数据:</strong><br>– Customer-id<br>– Customer-contact-info<br>– Shipment-destination<br>– Shipment-mechanism<br>– Payment-information  </p>
<p><strong>Primary Course:</strong><br>1.用上面的数据命令 clerk 发出“创建订单”命令。<br>2.系统验证所有数据。<br>3.系统创建订单并确定订单 ID。<br>4.系统将订单 ID 传达给 clerk。  </p>
<p><strong>Exception Course:</strong><br>Validation Error 验证错误，由系统将错误信息送达给 clerk。</p>
<p>我们将给这个用例中的数据建模到我们的模型层，并且创建特定的 request（请求）、response（响应）和 view models（视图模型）来在 view controller（视图控制器）、interactor（交互器）和 presenter （展示器）这些组件的边界中传递数据。</p>
<p>首先来看一下我们如何在 Xcode 项目中组织我们的代码。</p>
<h2 id="在-Xcode-中组织你的代码"><a href="#在-Xcode-中组织你的代码" class="headerlink" title="在 Xcode 中组织你的代码"></a>在 Xcode 中组织你的代码</h2><p>我们将创建一个新的 Xcode 项目，将其命名为 <strong>CleanStore</strong>。为了简单起见选择“Single View Application” 和 “仅 iPhone” 就行，并确定在语言中选择了 Swift。接下来，创建一个嵌套的子 Group: <strong>Scene -&gt; CreateOrder</strong>。当我们稍后开始实现删除订单的用例时，再创建一个新的子 Group 叫做 <strong>Scenes -&gt; DeleteOrder</strong>。</p>
<p>在一个典型的 Xcode 项目中，我们通常会见到文件被组织成 <strong>Model（模型）</strong>、<strong>View（视图）</strong>和 <strong>Controller（控制器）</strong> 三个组。每个 iOS 开发者都知道 MVC 架构，但让并没有告诉你任何关于项目更明确具体的信息。如 Uncle Bob 所指出，group（组）和 file names （文件命名）应当展现出你对此用例的意图，而不应该是反映底层框架结构。所以我们将在 Scene 下嵌套一个新的 group 来管理我们的每一个用例。</p>
<p>在 <strong>CreateOrder</strong> 组中，你可以预计到这里所有文件要做的事情都会和创建订单有关。同样的如果在 <strong>DeleteOrder</strong> 组下你将发现所有的代码都在处理关于删除订单的事务。如果你看到一个由其他开发者创建的新的 <strong>ViewOrderHistory</strong> 组，你就已经能预计到这是做什么的。<br>这种结构能够告诉你相比以往使用的 Model, View, Controller 分组来说的更多信息。长此以往，你累计了 15 个 models, 27 个 view controllers，和 17 个 views。它们是做什么的？在一一查看这些文件前，你大概会什么都不清楚。</p>
<p>也许你会问，那些被 <strong>CreateOrder</strong>, <strong>DeleteOrder</strong> 以及 <strong>ViewOrderHistory</strong> 所共用的类和协议该怎么办？实际上你可以将他们放到一个单独的组中，并取名为 <strong>Common -&gt; Order</strong>。为什么不简单明了一些呢？</p>
<p>回到我们的用例。</p>
<p>在 <strong>CreateOrder group</strong> 下面，我们将创建符合 Clean Swift 架构的组件。当我们继续完成用例时，我们将在这些组件的输入输出协议中添加方法，然后实现他们。</p>
<h2 id="VIP-循环"><a href="#VIP-循环" class="headerlink" title="VIP 循环"></a>VIP 循环</h2><p><img src="http://www.roczhang.com/images/cleanSwift/vipCycle.png" alt="Markdown preferences pane"><br>ViewController（视图控制器），interactor（交互器）和 presenter （展示器）是 Clean Swift 中的三个主要组件。他们彼此互相作为其他组件的输入和输出，正如下面的图表所展示：<br>视图控制器的输出连接着交互器的输入，交互器的输出连接着展示器的输入，展示器的输出连接着视图控制器的输入。我们将创建特定的对象来在这些组件的边界间传递数据。这能使我们把底层数据结构从组件中解耦。这些特定的对象仅由原始类型组成，如 Int, Double 和 String。我们可以创建结构体、类和枚举来重新表达数据，但在这些实体的内部应该仅包含原始类型。</p>
<p>这一点非常重要。因为一旦业务逻辑改变，底层的数据模型也需要改变。我们不需要去更新全部的代码。Components （组件）在 Clean Swift 中充当插件的角色。这就意味着我们可以将不同的组件交换使用，只要他们能够遵循 Input （输入）和 Output （输出）协议，应用仍然可以按照我们的预期正常工作。</p>
<p>一种典型的情况是这样的：用户点击了应用界面中的一个按钮，Tap Gesture 点击手势通过 IBActions 进入 ViewController 视图控制器，View Controller 构造一个请求对象并将其发送给 Interactor 交互器。Interactor 接受这个请求对象去执行一些任务，然后将执行结果放入 Response 响应对象中并将其发送给 Presenter 展示者。Presenter 将接收 Response 响应对象并格式化结果，然后将格式化的结果放到一个 ViewModel 视图模型对象中，并将其发回给 ViewController。最后，由 ViewController 将结果展示给用户。</p>
<h2 id="1-View-Controller"><a href="#1-View-Controller" class="headerlink" title="1.View Controller"></a>1.View Controller</h2><p>一个 ViewController 视图控制器应当在 iOS App 中承担着怎样的角色？基类 UITableViewController 应当可以给我们一些启示。我们想要使用代码来控制 UITableView 和 UIView 的子类，但这里的的控制代码应当是什么样？怎样的代码能有资格被称作控制代码而怎样的代码不能呢？</p>
<p>让我们深入来看。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CreateOrderViewControllerInput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">displaySomething</span><span class="params">(viewModel: CreateOrderViewModel)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CreateOrderViewControllerOutput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(request: CreateOrderRequest)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderViewController</span>: <span class="title">UITableViewController</span>, <span class="title">CreateOrderViewControllerInput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">var</span> output: <span class="type">CreateOrderViewControllerOutput</span>!</div><div class="line">  <span class="keyword">var</span> router: <span class="type">CreateOrderRouter</span>!</div><div class="line"></div><div class="line">  <span class="comment">// MARK: Object lifecycle</span></div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">super</span>.awakeFromNib()</div><div class="line">    <span class="type">CreateOrderConfigurator</span>.sharedInstance.configure(<span class="keyword">self</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// MARK: View lifecycle</span></div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    doSomethingOnLoad()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// MARK: Event handling</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doSomethingOnLoad</span><span class="params">()</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Ask the Interactor to do some work</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> request = <span class="type">CreateOrderRequest</span>()</div><div class="line">    output.doSomething(request)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// MARK: Display logic</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">displaySomething</span><span class="params">(viewModel: CreateOrderViewModel)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Display the result from the Presenter</span></div><div class="line"></div><div class="line">    <span class="comment">// nameTextField.text = viewModel.name</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="CreateOrderViewControllerInput-和-CreateOrderViewControllerOutput-协议"><a href="#CreateOrderViewControllerInput-和-CreateOrderViewControllerOutput-协议" class="headerlink" title="CreateOrderViewControllerInput 和 CreateOrderViewControllerOutput 协议"></a>CreateOrderViewControllerInput 和 CreateOrderViewControllerOutput 协议</h2><p><code>CreateOrderViewControllerInput</code> 协议指明了 <code>CreateOrderViewController</code> 组件（它遵循这个协议）的输入。<code>CreateOrderViewControllerOutput</code> 协议指明了输出。稍后你将在 interactor 和 presenter 上看到相同的模式。</p>
<p>在 output 协议中有一个方法叫做 <code>doSomething()</code> ，如果有另一个组件想要成为 <code>CreateOrderViewController</code> 的输出，则需要在它的输入中支持 <code>doSomething()</code> 方法。</p>
<p>从之前你看到的 VIP 循环中，我们知道这个 output 是 interactor。但请注意在 <code>CreateOrderViewController.swift</code> 中，没有提及到 <code>CreateOrderInteratcor</code>，这就意味着我们可以将另一个组件替换成为 <code>CreateOrderViewController</code> 的输出，只要这个组件在他的 input 协议中支持 <code>doSomething()</code> 。<br><code>doSomething()</code> 方法中的参数是一个由 view controller 传递到 interactor 的请求对象。这个请求对象是一个 <code>CreateOrderRequest</code> 结构体。它由原始类型构成，而不是之前我们确定的全部的订单数据。这意味着我们可以将底层订单数据模型从 view controller 和 interactor 中解耦出来。所以当我们将来要对订单数据模型做修改的时候（例如在其中增加一个“订单 ID” 的字段），我们不需要去更新 Clean Swift 组件中任何其他的内容。</p>
<p>稍后我们完成了 VIP 循环之后，我们会再回到输出协议中的 displaySomething() 方法。</p>
<h2 id="output-和-router-变量"><a href="#output-和-router-变量" class="headerlink" title="output 和 router 变量"></a>output 和 router 变量</h2><p>输出变量是个遵循 <code>CreateOrderViewControllerOutput</code> 协议的对象。虽然我们已经知道在这里它实际上是 interatcor，但也可以不是（因为可以将它替换成其他组件）。</p>
<p>router 变量是一个对 <code>CreateOrderRouter</code> 的引用，它被用来导航到不同的场景。</p>
<h2 id="configure-方法"><a href="#configure-方法" class="headerlink" title="configure() 方法"></a>configure() 方法</h2><p>我们将在 <code>awakeFromNid()</code> 方法中调用 <code>CreateOrderConfigurator.sharedInstance.configure(self)</code> 去让 configurator 来配置好 VIP 链。在 Uncle Bob 的 Clean 架构或者 VIPER（他将所有的配置工作放在 AppDelegate 中）里没有 configurator （配置器）的存在。由于我真的不想让这些无关的配置代码打乱我们的 VIP 代码，所以我将其提取出来放入到了 configurator 中。稍后我们会来看一下 configurator。</p>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>在 <code>viewDidLoad()</code> 中，我们需要去运行一些业务逻辑，所以调用 <code>doSomethingOnLoad()</code>。在 <code>doSomethingOnLoad()</code> 中，我们创建一个 <code>CreateOrderRequest()</code> 对象并在 output（the interactor）上调用 <code>doSomething()</code>。就是这样啦。我们要求 output 来执行我们的业务逻辑，view controller 不用也不应该关心谁来做，以及它如何完成。</p>
<h2 id="See-you-in-the-next"><a href="#See-you-in-the-next" class="headerlink" title="See you in the next"></a>See you in the next</h2><p>第一篇先翻译到这里，下次我们再接着 Interactor 继续。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;节选翻译来自 Clean Swift iOS Architecture for Fixing Massive View Controller 系列第一篇。&lt;br&gt;原作者：Raymond&lt;br&gt;翻译者：Roc Zhang&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>跨越大三</title>
    <link href="http://www.roczhang.com/%E8%B7%A8%E8%B6%8A%E5%A4%A7%E4%B8%89.html"/>
    <id>http://www.roczhang.com/跨越大三.html</id>
    <published>2017-11-25T16:37:26.000Z</published>
    <updated>2017-11-25T19:39:52.252Z</updated>
    
    <content type="html"><![CDATA[<p>大三早已结束了。对于名义上大四却已经实习了一个多月的我来说，大学生活好像真的已然过去了。</p>
<a id="more"></a>
<h3 id="16年7月-～-16年8月，实习"><a href="#16年7月-～-16年8月，实习" class="headerlink" title="16年7月 ～ 16年8月，实习"></a>16年7月 ～ 16年8月，实习</h3><p>距离上一次写生活日志已经过去一年多了，而上篇落笔时我还身处北京，体验第一次实习的各种新鲜感。并且不仅是实习，也是第一次见到如此多的在网络上 follow 已久的 stars 们。在多点的那个暑假非常开心，每天能和师傅、友才还有马老师一起工作，还可以和 JustZht、Cee 一起看电影吃饭，听 Kevin 说了很多人生经验。而更重要的是我看到了更优秀同行业的同龄人和前辈是如何工作和生活的。</p>
<h3 id="16年9月-～-16年11月，返校"><a href="#16年9月-～-16年11月，返校" class="headerlink" title="16年9月 ～ 16年11月，返校"></a>16年9月 ～ 16年11月，返校</h3><p>回到学校之后的日子渐渐平淡下来。而感激于 Kevin 给我继续远程工作的机会，得以给我每天平淡的校园生活以一些机会去做自己喜爱的事。记得有阵子每天晚上都会 coding 到凌晨，饿了就吃吐司面包，累了就看一看 B 站上的食彩之国。虽然有时候通宵 coding 完还要继续去上早上的课困到撑不出，但第一次有一种用力工作用力生活的感觉。而这一段时间也是我有史以来技术学习最快最积极的一段时间了。  </p>
<p>想起这段生活至今依然感到非常充实幸福，我感到非常幸运，真的很感谢 Kevin。</p>
<p>有了一份得以持续的实习工作，除了让我的精神生活得以充实之外，也让我第一次经济上更加独立了。搬出了在学校闹人的寝室，租住了学校旁的学生公寓，终于也有了一点独立的个人空间。</p>
<p>有阵子每天晚上我会一个人关掉所有灯听把音响开到最大反复听 Cornfield Chase，感觉自己好像虚无的飘在宇宙里，让我对未来的一切不确定都没那么恐慌了。</p>
<h3 id="16年12月-～-17年4月，前前前世和-WWDC"><a href="#16年12月-～-17年4月，前前前世和-WWDC" class="headerlink" title="16年12月 ～ 17年4月，前前前世和 WWDC"></a>16年12月 ～ 17年4月，前前前世和 WWDC</h3><p>十二月你的名字上线，追漫画不多的我感动到连刷两场，果然梦是只有少年才有的。期末结束去长沙见了小萌师傅，和师傅聊了一整天，听了些师傅对未来的打算。寒假回家见到了一些高中同学，他们也已经有了自己的规划，或是出国读研，或是选择考公务员。而自己已经意识到在学校的时间不多了，当时的我还对自己考不考研的事情依旧举棋不定。  </p>
<p>四月准备了一个音乐小游戏申请 WWDC 奖学金，虽然是第一次参与但自己却对此心生执念很久了。虽然最后没过，但看到一些冒泡排序可视化或者一个 collectionView 翻牌记忆都可以过，并且一个有 Apple iOS 俱乐部合作的学校就有几个人都过了的时候，实话说确实是有些不服气的。</p>
<h3 id="17年5月-～-17年6月，提前的毕业照和-Mr-Weather"><a href="#17年5月-～-17年6月，提前的毕业照和-Mr-Weather" class="headerlink" title="17年5月 ～ 17年6月，提前的毕业照和 Mr.Weather"></a>17年5月 ～ 17年6月，提前的毕业照和 Mr.Weather</h3><p>转眼五月，迎来了我院特色提前拍毕业照。穿上学士服想到马上就可以踏出校园的那一刻还是挺开心的，毕竟虽然不知道自己在学校算不算的上异类，我确实已经自己做自己的事太久了。并且长久以来自己在学校聊的来的朋友不多，看到其他同龄小伙伴在做各种精彩的事情总让我感到无可奈何，更早已开始让我期望自己能够去做自己喜爱的工作。此时我也开始放弃今年考研的打算，一方面是自己并不想在国内读研，因为咨询到不少朋友最后发现国内 CS 专业研究生似乎就是给导师打工，与其如此还不如去公司工作来积累经验。另一方面则是考虑到自己和自己家庭目前的情况，尤其是经济情况，似乎也并不允许。</p>
<p>而最后在学校的这段日子时间上也相对自由宽松，因此也得以做出了我的第一款个人应用 Mr.Weather，五月上架到了 AppStore。结果还是有些意外，得到了一些媒体的推荐，在 AppStore 上最高排到了国区天气免费榜 13 名，并且也因此认识了不少新朋友。当时每天早晨起床后第一件事就是打开邮箱查看用户发来的各类邮件，总让我能有一种被人认可的喜悦。</p>
<p>最后在学校的几周几乎每天都会和朋友骑车，也突然感觉这个被我吐槽了三年的城市好像也挺好的。</p>
<h3 id="17年7月，深圳香港"><a href="#17年7月，深圳香港" class="headerlink" title="17年7月，深圳香港"></a>17年7月，深圳香港</h3><p>七月回家带了一阵子之后去了深圳和香港。在港中大住了阵子，参与和体验了他们日常学习和工作的方式。而看到自己的同龄人在如此规范成熟的协作，也让我感到钦佩。<br>第一次来到大家都称赞开放的深圳，确实是到处充满了南方的气息，也顺带参与了一次 Swift <t> 沙龙。而对于香港我则是一直心有好感，一方面是小时候经常看 TVB 剧听粤语歌，另一方面则是香港的文化环境和社会制度的吸引。我羡慕香港的法治，羡慕香港在今天依然能够享有的那么一点小小自由。</t></p>
<h3 id="17年8月-～-17年9月，生命脆弱"><a href="#17年8月-～-17年9月，生命脆弱" class="headerlink" title="17年8月 ～ 17年9月，生命脆弱"></a>17年8月 ～ 17年9月，生命脆弱</h3><p>在深圳的时候得知姥姥病危，赶紧赶回家。看到之前每次回去都问我吃饱穿暖没有的姥姥躺在病床上连话都说不清的时候，心里非常难受。并且姥姥病情恶化的速度也超出所有人的想象，先后转院多次，姥姥却已经进入昏迷状态了。最后几天姥姥进了 ICU，我和家人坐在 ICU 和手术室中间的走廊，看着来来往往的病床推来推去，自己却又无可奈何，终于体会到“医院的墙不知听到了多少人的祷告”这句话的含义，而最后，姥姥还是走了。第一次在心智成熟之后面对生离死别，最后姥姥昏迷之后真的让我思考到底什么才能定义活着。想到之后姥姥再也不会坐在床上问我吃没吃饭呢，心情就会酸楚沉重起来。</p>
<h3 id="17年10月-～-现在"><a href="#17年10月-～-现在" class="headerlink" title="17年10月 ～ 现在"></a>17年10月 ～ 现在</h3><p>待家中事情办完，自己意识到该考虑校招的事情了。Mr.Weather 发布之后收到了一些 Offer，而面对校招自己还是想参与尝试一次的。也没有做什么别特的准备，做了一份简历，复习了一下算法 / 数据结构 / OC 方面的问题。但却发现一些公司的校招已经结束，而另一些校招笔试之后的进度又慢的离奇。最后还是在先拿到的几个 Offer 中决定去上海了，毕竟在家已经呆了挺久并且考虑到现在的经济状况也想去尽快工作。而新员工入职培训的时候，还接到了其他公司的电话，然而决定了就决定了。开始实习至今已经有一个多月了，每天十点上班八点下班的工作时间还是让我感觉挺累的，并且和去年相比，似乎少了一些兴奋，也许是因为去年实习时我意识到自己暑假结束后终究要回学校，也许是因为有 Kevin、小萌、马老师，而现在只有我一个人。<br>每天去掉工作、通勤、洗漱之外的时间，能留下给自己支配的时间已经非常少了，难免感到有些压抑与担忧，但至少我身处在自己喜爱的行业中。不过自己依然在努力融入新环境中，11 月初第一次参加了 Hackathon，与队友们一起组队 coding。也参加了一期 Sketch Meetup，最后一个似乎是培训班老师，一番抄袭无罪的理论让我三观不适。不过看到了丁一和 JASKNi，然而人很多并没有机会也没好意思上前打扰打招呼。<br>在家准备面试的之前开始了自己的新项目 Adonis，经过了好久好久的 TF 前几天终于上架了，关于 Adonis 的故事还是单独再谈。</p>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>落笔的时候脑中闪过了很多东西，甚至高考。现在大四的我大学生活基本已经算是结束了，我不得不说高考之后每件事似乎都和高考可以扯得上关系，而面对自己的高考我当然有遗憾但是没什么好后悔的。大一的时候我还没日没夜不停的想着复读的问题，看着周边一些每天连续游戏的同学和合不来的室友甚至很害怕自己变成那样。所以现在看起来自己的大学三年似乎一直过的很焦虑，虽然我对自己的学校并不满意，但也从来没有沉溺于抱怨，总是想着自己可以改变些什么，到发现环境改变不了的时候便开始专心改变自己。从大一大二每天泡实验室到寝室关门，到大三沉心于自己的事情，至少我一直向着自己的方向尝试努力。大一大二的时候急着在学校证明自己，拿一等奖学金，去评各类奖项，但后来我发现在学校里追逐这些对我而言并没有什么实际意义，我在学校之外开始看到了更多更优秀的同龄人在做什么，我开始关心自己应该要去做什么。甚至于私以为读大学的目的学专业倒是其次，因为该用的东西自己迟早会学，而至于大学人脉什么就更是胡诹。对我而言最重要的可能就是给我一个环境和足够的时间思考自己认识和处理世界的方式，想好了，就专心去做吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大三早已结束了。对于名义上大四却已经实习了一个多月的我来说，大学生活好像真的已然过去了。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.roczhang.com/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>Mr.Weather 的故事</title>
    <link href="http://www.roczhang.com/Mr.Weather%20%E7%9A%84%E6%95%85%E4%BA%8B.html"/>
    <id>http://www.roczhang.com/Mr.Weather 的故事.html</id>
    <published>2017-05-30T07:47:32.000Z</published>
    <updated>2017-06-03T08:54:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.roczhang.com/images/mrWeatherStory/banner.png" alt="Markdown preferences pane"></p>
<p>Mr.Weather 是第一个从 0 到 1 完全由我自己完成的 App，因此我也在这个过程中体验到了产品、设计、开发甚至是客服等各个角色。从构建 Mr.Weather 首版雏形至今已经超过一年，我想不如就从这几个身份来聊聊 Mr.Weather 的故事。</p>
<a id="more"></a>
<h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><h3 id="思路的雏形与改变"><a href="#思路的雏形与改变" class="headerlink" title="思路的雏形与改变"></a>思路的雏形与改变</h3><p>坦白说，开始动手做 Mr.Weather时我甚至没想好到底要做个怎样的产品，这也是为什么中间花费了如此长的时间。甚至于今天看来，雏形和现在的版本完全是两个不同的产品。最开始是在突发奇想下决定要做一个程序员风格的天气 app，实际上就是类似于 Terminal ，直接输入各种命令，完成查询某个城市天气之类的动作。而在这种奇特的思想驱动下，甚至还加入了类似聊天机器人的对话功能。整体风格也是尽力模仿像素风，甚至字体也是用的 Xcode 默认的 Menlo。当时还在大二的我觉得这种感觉很酷，而现如今看起来则是有些惨不忍睹了。<br><img src="http://www.roczhang.com/images/mrWeatherStory/2.png" alt="Markdown preferences pane"></p>
<p>之后大二暑假实习期间的一个晚上去 Kevin 家吃饭，我掏出手机给 Kevin 看了当时的 Mr.Weather。依稀记得 Kevin 说挺有趣但感觉有些自嗨，我认真一想感觉还真的是。就算是程序员，也不会每次想要查温度都要输入一个 weather -temp 呀。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>在实习结束后，我开始认真考虑究竟应该做一个怎样的天气应用。如同买钻头的人需要的往往不是钻头而是洞，大部分用户查看天气都不是为了研究天气数据，而是想要知道这些数据会怎样影响到自己，自己需要做出怎样的决定。<br>在仔细观察自己和朋友的使用习惯之后，初步将需求划分成两部分：一是经常发生的，有规律的动作，比如我们会在早晨出门前查询天气，通过降雨概率决定要不要带伞，或者通过空气质量指数决定要不要戴口罩，再或者在周五晚上看看周末的天气适不适合安排出游之类。而另一部分则是相对随机的，没有太多规律的动作。比如临出门时天色暗下来了查查当前天气。于是根据这两类需求，我开始重新考虑 Mr.Weather 的 feature。对于第一类规律性的动作，我做了 Mr.Weather 中最重要的一个功能，自定义天气通知。你可以自定义触发通知的条件、监测时间与通知发送时间，如 “当天的空气质量指数大于100时，在早晨提醒我带口罩”，又或是“第二天的降雨概率大于 50% 时，在晚上提醒我装好伞”。这些规律性的动作，就可以完全交给 Mr.Weather 来监控，用户不必每次手动查看了。而对于另一方面的需求，我给出的解决方案是当用户主动查看时，以最直观的方式告诉他所需要的信息。如 App 中包涵了分为四大类别的可定制卡片，拥有实时播报和天气动画的 Widget。并且尽量更直接的告诉用户天气变化趋势以及将带来怎样的影响，而不单是天气数据。<br><img src="http://www.roczhang.com/images/mrWeatherStory/4.png" alt="Markdown preferences pane"></p>
<p>每一次增改 feature 都可能让已经完成的设计和代码被放弃重来，甚至让完成进度变成遥遥不可期。在经历了第一版的 Mr.Weather 之后，我也学着更谨慎的面对每一个设想和功能。</p>
<h3 id="克制"><a href="#克制" class="headerlink" title="克制"></a>克制</h3><p>在考虑其他功能点时我也相对保持克制，引用 Alan 的话说，我非常讨厌 “航母级应用”，所有的生活需求被一个 App 接管是一种非常可怕的事。相比而言我更喜欢目的明确的产品，用起来干脆利落。少即是多的道理谁都会讲，而增加功能却经常是一个思考成本相对更低的选择。而由于 Mr.Weather 是个人作品，所以也有机会更加纯粹，无需面对所谓的 「 KPI 压力 」 吧。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>我很敬佩那些设计优秀重视细节的产品，这样的产品处处都会充满着设计者的巧思与灵魂。同时我很享受做设计的过程，打开 Sketch 看到一个个 Artboard 排列在屏幕上的感觉总会让人非常愉悦。从自己画下 Mr.Weather 中用到的每一个小图标，到设计调整各个天气动画，甚至是通知提示音，很多细节都需要时间和精力打磨。<br><img src="http://www.roczhang.com/images/mrWeatherStory/5.png" alt="Markdown preferences pane"></p>
<h3 id="气质与迭代"><a href="#气质与迭代" class="headerlink" title="气质与迭代"></a>气质与迭代</h3><p>设计的理念倒不像产品一样，从开始时我就希望 Mr.Weather 的设计干净明晰。Mr.Weather 的整体配色相对克制，也尽量注意留白。整体由信息驱动，寻求干净开阔。由于在产品构思上的更新导致整个产品有过数次推翻重来，我自己又稍稍有些强迫症，经常会和一个图标、界面死磕，找不到想要的感觉就会再来。单一个设置界面就反反复复改了数版，而至于引导界面、主界面之类则更甚，经常是自己看着不舒服就推倒再来。不过除去做个人作品怕是很难会有这样的时间成本可以让自己打磨了。好在最后的结果自己总体还算比较满意，当然还是有很多不足（比如不少用户甚至都没能找到设置入口）。<br><img src="http://www.roczhang.com/images/mrWeatherStory/6.png" alt="Markdown preferences pane"></p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>配合 Mr.Weather 整体的气质，我为 Mr.Weather 的英文与数字选择了 Gill Sans 这款字体。Gill Sans 被誉为英国的 Helvetica，甚至在 SHERLOCK 电影前的 BBC 片头里还能见到他的身影。虽然我对字体的了解还非常浅薄，但我很喜欢这款字体那种相对谨慎且平和的气质。在 Sketch 和 iPhone 屏幕上反复比较之后，我觉得 Gill Sans 相对 Open Sans 、Helvetica 等字体与 Mr.Weather 整体更加契合，于是选定了使用 Gill Sans。而中文字体由于考虑到对应用整体大小的控制，所以算是在妥协之下选择了系统默认的苹方。</p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>Mr.Weather 的天气动画依然在寻求自然干净的感觉，晴天、阴天、雨天及下雪等场景的动画也遵循 Mr.Weather 整体的配色。 除去较大的天气动画之外，在 App 中我也加入了很多细小的动画。比如下拉菜单时后面背景的逐渐模糊，添加卡片时类似一推滑动的 toggle 动画，天气卡片下方展开分类筛选时的提示用户可以滑动的动画，以及各类 alert 动画等等，都希望能营造出一种自然、干净、利落的体验。<br>Mr.Weather 中的动画在少数地方使用了 Facebook 的 pop 与 Airbnb 的 Lottie，而 95% 以上的动画还是使用了 CoreAnimation 来完成。<br><img src="http://www.roczhang.com/images/mrWeatherStory/7.png" alt="Markdown preferences pane"></p>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>由于自己程序员的主要身份，所以整体开发上的烦恼基本只剩下 Xcode 经常崩溃的自动提示与 Swift 越来越长的编译等待时间。但最重要的天气通知则还是遇到了一些问题。对于如何处理天气通知想过非常多的办法，甚至于一开始打算把所有用户的通知设置保存在 Server 上，由 Server 来处理判断再给客户端发通知。而这种办法对于目前的 Mr.Weather 来说基本不可行。后来还是采取了后台应用刷新和远程静默通知结合的方式来解决。</p>
<h3 id="数据源与运营压力"><a href="#数据源与运营压力" class="headerlink" title="数据源与运营压力"></a>数据源与运营压力</h3><p>另一件比较烦心的则是天气数据源的选择。先后比较了几个数据源，最后还是选择了一个付费数据源。毕竟准确、及时的数据对于一个天气应用至关重要，也会在很多时候影响用户体验。而在上架时，考虑到 Mr.Weather 目前的完善状况，觉得现在收费还是对用户不太负责的行为，所以选择了免费也没有添加内购选项。后来 Mr.Weather 的日访问突然增长，按次收费的天气接口费用让我措手不及。非常感动的是不少用户都给予了捐助支持，也帮助我在想清 Mr.Weather 的未来之前缓解了不少压力。</p>
<h3 id="内测"><a href="#内测" class="headerlink" title="内测"></a>内测</h3><p>在 Mr.Weather 上架之前，我先通过 TestFlight 发布了数个测试版本。由于开发者使用时的一些惯性非常容易忽略掉不少问题，所以进行测试非常必要。 Mr.Weather 先后从 0.1 测到 0.7，其中数次都是凌晨新版本通过审核后交由朋友们测试一天，我在当天晚上就会做修改调整，再提交下一版本审核。朋友们给了很多反馈与建议，数次下来 Mr.Weather 的问题也少了很多，方提交到了 AppStore。<br>值得一提的是，作为自己第一次提交给 AppStore 的应用，一次就通过审核了，而且前后一共也只用了两三天的时间，非常意外。</p>
<h3 id="上架后与用户反馈"><a href="#上架后与用户反馈" class="headerlink" title="上架后与用户反馈"></a>上架后与用户反馈</h3><p>Mr.Weather 于 5 月 18 日上架到了 AppStore ，至今差不多两周的时间。期间最佳排名为国区天气类免费榜第 25 名。而上架之后，阅读每日的反馈与来信也变成一件非常有趣的事情，也正是通过这个渠道，结识到了不少用户甚至是设计师和开发者，感觉非常奇妙。</p>
<h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>从大二开始参与过大大小小的项目开发，在团队中每个人各司其职，相互配合与学习的过程让我非常快乐。而第一次通过 Mr.Weather 完整体验了从 0 到 1 制作一款产品，自己独立掌控产品的方方面面则别有一番感触。这两种体验都让我投入且着迷。<br>我曾想过做设计对一个程序员而言会不会是不务正业，然而上面提到的每一个角色努力的目的都是为了打造出一个更好的产品，之间并没有冲突。而将我的所学所想杂糅并倾注到一款产品中去，不断打磨完善，再实现新的想法，这个过程我想我永远不会觉得无趣。</p>
<p>我是 Roc Zhang，这就是我的首个独立作品 Mr.Weather。<br>Mr.Weather 官网与下载地址：<a href="http://www.roczhang.com/mr.weather/">http://www.roczhang.com/mr.weather/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.roczhang.com/images/mrWeatherStory/banner.png&quot; alt=&quot;Markdown preferences pane&quot;&gt;&lt;/p&gt;
&lt;p&gt;Mr.Weather 是第一个从 0 到 1 完全由我自己完成的 App，因此我也在这个过程中体验到了产品、设计、开发甚至是客服等各个角色。从构建 Mr.Weather 首版雏形至今已经超过一年，我想不如就从这几个身份来聊聊 Mr.Weather 的故事。&lt;/p&gt;
    
    </summary>
    
      <category term="Product" scheme="http://www.roczhang.com/categories/Product/"/>
    
    
  </entry>
  
  <entry>
    <title>&#39;===&#39; &amp; &#39;!==&#39; in Swift</title>
    <link href="http://www.roczhang.com/in-Swift.html"/>
    <id>http://www.roczhang.com/in-Swift.html</id>
    <published>2017-03-28T14:21:43.000Z</published>
    <updated>2017-03-28T15:12:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>一篇简短的小记。<br><a id="more"></a></p>
<h1 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h1><p>由于最近比较多的用了 IGListKit 来写新的模块和重构旧的模块，其中 IGListKit 要求模型遵遁 IGListDiffable 协议，其中需要你实现一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public func isEqual(toDiffableObject object: IGListDiffable?) -&gt; Bool</div></pre></td></tr></table></figure>
<p>来告诉 IGList 接收到的和给定的 object 是否相等。一般情况用模型里的 hash id 来判断就可以解决，但今天和师傅讨论到如果是一个数组，而且数组里的模型又没有 ID 属性，该如何判断相等。</p>
<p>由此想到了 ‘===’ &amp; ‘!==’ 运算符。</p>
<h1 id="‘-’-amp-‘-’"><a href="#‘-’-amp-‘-’" class="headerlink" title="‘===’ &amp; ‘!==’"></a>‘===’ &amp; ‘!==’</h1><p>比起常用的 == 和 != ，这两个运算貌似使用的频度非常低，其实用法倒是很简单的， === 和 !== 用于比较 引用类型（Reference Type）是否是相同的引用。</p>
<p>不过随便查看几个搜索结果会发现好像有这么一段说法：</p>
<p>“Check whether two arrays or subarrays share the same storage and elements by comparing them with the identity operators (=== and !==).”</p>
<p>嗯嗯嗯？还可以比较数组或者子数组的？原生支持？如此方便？<br>在 Playground 中简单一试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let array1 = [1, 2, 3]</div><div class="line">var array2 = array1</div><div class="line"></div><div class="line">array1 !== array2</div></pre></td></tr></table></figure>
<p>马上就会 “Error: binary operator ‘!==’ cannot be applied to…”。</p>
<p>不过等等，Swift 中的 Array 不是 Value Type 吗，是应该不能用这个啊，那为什么会有可以比较数组这种说法？难道记错了？</p>
<p>“Array and Dictionary in Swift are implemented as structs.”</p>
<p>没记错， Array 是 Value Type.</p>
<p>后来发现，之所以有比较数组这种说法是因为，在 2014 年 Swift beta 3 之前，Swift 中的 Array 有一些小小的不同，引用喵神以前的博客里的一句话：</p>
<p>“Swift 考虑到实际使用的情景，对 Array 做了特殊的处理。除非需要（比如 Array 的大小发生改变，或者显式地要求进行复制），否则 Array 在传递的时候会使用参照。”</p>
<p>而之后</p>
<p>“对于 Array 中元素的改变，在 beta 3 中发生了变化。现在不再存在作为一个值类型但是却在赋值和改变时表现为参照类型的 Array 的特例，而是彻头彻尾表现出了值类型的特点。”</p>
<p>所以， ‘===’ &amp; ‘!==’ 用于比较数组的这种说法也是很早之前的老文档中存在的，现在并不能用啦。</p>
<p>等等，谁说不能？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let array1 = NSArray(array: [A, B])</div><div class="line">var array2 = array1</div><div class="line"></div><div class="line">array1 !== array2</div></pre></td></tr></table></figure>
<p>用 Cocoa 中的容器类自然没问题，因为是引用类嘛。</p>
<p>但这就没有 Swift 的 “钦定” 感了! 🙃</p>
<p>善变的 Swift! 🙃</p>
<h1 id="Swift-3-1"><a href="#Swift-3-1" class="headerlink" title="Swift 3.1"></a>Swift 3.1</h1><p>Xcode 8.3 出来了！ Swift 3.1 出来了！<br>Apple 还说 “Faster builds for large projects that mix Objective-C and Swift code”!<br>赶紧一试！</p>
<p><img src="http://i1.piimg.com/577817/dc057c7c28ef5d73.jpg" alt="Markdown preferences pane"></p>
<p>120 秒… 还有 Swift 3.1 附赠的爆炸多的警告… 🙃<br>也许还是在提示我电脑不行了。 🙃</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-ID82" target="_blank" rel="external">Apple - Classes and Structures</a><br><a href="https://onevcat.com/2014/06/walk-in-swift/" target="_blank" rel="external">OneV’s Den - 行走于 Swift 的世界中</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇简短的小记。&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>3D Touch for iOS 10 适配指南</title>
    <link href="http://www.roczhang.com/3D-Touch-for-iOS-10-%E9%80%82%E9%85%8D%E6%8C%87%E5%8D%97.html"/>
    <id>http://www.roczhang.com/3D-Touch-for-iOS-10-适配指南.html</id>
    <published>2017-03-26T02:31:03.000Z</published>
    <updated>2017-03-26T16:11:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>好不容易起个大早的居然就突然停电了，翻看到好久之前的 WWDC 学习笔记，想起来之前好像打算稍稍整理一下 3D Touch 相关内容的，趁着 MacBook 还有电顺手写一下。<br><a id="more"></a></p>
<p>对应的是 WWDC 16 - Session 228。先记录 Session 上的相关内容。</p>
<h1 id="Home-Screen-Quick-Actions"><a href="#Home-Screen-Quick-Actions" class="headerlink" title="Home Screen Quick Actions"></a>Home Screen Quick Actions</h1><p>这就是 iOS SpringBoard 上用力点按 App Icon 弹出的快捷操作菜单了。此类菜单分为两类，静态和动态。</p>
<h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><p>静态 action 被定义在 app 的 info.plist 文件中。定义之后，用户在安装了你的 app 后就可以生效使用。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-UIApplicationShortcutItems</div><div class="line">--Item 0</div><div class="line">---UIApplicationShortcutItemType      String    com.company.app.XXX</div><div class="line">---UIApplicationShortcutItemTitle    String    New Chat</div><div class="line">---UIApplicationShortcutItemIconType  String    UIApplicationShortcutIconTypeMessage(system type)</div></pre></td></tr></table></figure>
<p>最后的 ShortcutIconType 可以使用系统提供的一些类型。而关于 Item 总数的问题，除去 iOS 10 开始系统增加的 “分享” 项外，最多只能设置 4 个（包括动静态项全部）。顺带一提，貌似大多数 app 的做法都是一个静态项外加三个动态生成项。</p>
<h2 id="Dynamic"><a href="#Dynamic" class="headerlink" title="Dynamic"></a>Dynamic</h2><p>与上面静态项所对应的就是 dynamic item，动态项是你的 App 在运行时创建的，所以只有在你的 app 第一次启动后才可以生成并可用。并且顺序上 dynamic item 是展示在 static item（看 action 列表展开的方向嘛，动态项会比静态项离手指更远）。但是动态项除了可以使用上面提到的系统提供的 icon 外，还可以使用自定义的 icon，以及通讯录中联系人的头像👦。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">let contactName = &quot;RocZhang&quot;</div><div class="line">var contactIcon: UIApplicationShortcutIcon? = nil</div><div class="line"></div><div class="line">// Make sure to request access to the user&apos;s contacts first</div><div class="line">if CNContactStore.authorizationStatue(for: .contacts) == .authorized &#123;</div><div class="line">    let predicate = CNContact.predicateForContacts(matchingName: contactName)</div><div class="line">    let contacts = try? CNContactStore().unifiedContacts(matching: predicate, keysToFecth: [])</div><div class="line"></div><div class="line">    if let contact = contacts?.first &#123;</div><div class="line">        contactIcon = UIApplicationShortcutIcon(contact: contact)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Fallback</div><div class="line">let icon = contactIcon ??  UIApplicationShortcutIcon(type: .message)</div><div class="line"></div><div class="line">// Create a Dynamic quick action using the icon</div><div class="line">let type = &quot;com.company.app.sendMessageTo&quot;</div><div class="line">let subtitle = &quot;Send a message&quot;</div><div class="line">let shortcutItem1 = UIApplicationShortcutItem(type: type, localizedTitle: contactName, localizedSubTitle: subtitle, icon: icon)</div><div class="line"></div><div class="line">// Repeat ...</div><div class="line"></div><div class="line">let shortcutItems = [shortcutItem1, shortcutItem2, shortcutItem3]</div><div class="line"></div><div class="line">// Register the Dynamic quick actions to display on the home Screen</div><div class="line">UIApplication.shared.shortcutItems = shortcutItems</div></pre></td></tr></table></figure>
<h2 id="Handing"><a href="#Handing" class="headerlink" title="Handing"></a>Handing</h2><p>设置好这些快捷操作项后我们当然要处理相应点击后的操作。没啥特别好说的，两种情况：</p>
<h3 id="On-app-activation"><a href="#On-app-activation" class="headerlink" title="On app activation"></a>On app activation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func application(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: Bool -&gt; Void) &#123;</div><div class="line">    let didHandle: Bool =  handle the quick action using shortcutItem</div><div class="line">    completionHandler(didHandle)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="On-app-launch"><a href="#On-app-launch" class="headerlink" title="On app launch"></a>On app launch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool &#123;</div><div class="line">    var performAdditionalHandling = true</div><div class="line">    if let shortcutItem = launchOptions?[UIApplicationLaunchOptionsShortcutItemKey] as? UIApplicationShortcutItem &#123;</div><div class="line">        handle the quick action using shortcutItem</div><div class="line">        performAdditionalHandling = false</div><div class="line">    &#125;</div><div class="line">    return performAdditionalHandling</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Best-Practices"><a href="#Best-Practices" class="headerlink" title="Best Practices"></a>Best Practices</h2><p>关于上述的 Quick Actions，Apple 提供了一些建议：</p>
<ul>
<li>每个 app 都应该提供 quick actions(我想这可能就是 iOS 10 系统全部加上 “分享” 的原因之一🤗)</li>
<li>好钢用在刀刃上（因为总数只有 4 个，所以 Apple 建议应该给具有高价值的任务创建快捷进入项）</li>
<li>确保你设置的项目是可被用户预知的（嗯我感觉我用力按了这个图标应该会出现…诶诶诶你怎么不按套路出牌！）</li>
<li>做好版本升级后依然能处理前一个版本生成的动态快捷项的准备</li>
</ul>
<h1 id="Peek-amp-Pop"><a href="#Peek-amp-Pop" class="headerlink" title="Peek &amp; Pop"></a>Peek &amp; Pop</h1><p>如果你还不太了解 peek pop 是什么，建议去看一下超炫酷的 iPhone 6s 发布时介绍 3D Touch 的视频。<br><a href="https://www.youtube.com/watch?v=IfXB7SPbg9A" target="_blank" rel="external">iPhone 6s 3D touch feature video</a><br>简单说来，Peek &amp; Pop 提供了一种可供用户快速预览和在内容之间导航的方式。</p>
<h2 id="Adding-Peek-amp-Pop-to-your-app"><a href="#Adding-Peek-amp-Pop-to-your-app" class="headerlink" title="Adding Peek &amp; Pop to your app"></a>Adding Peek &amp; Pop to your app</h2><p>适配 Peek &amp; Pop 非常简单，但首先需要了解一下，CocoaTouch 中把这两个动作先后称之为 Preview 和 Commit。</p>
<p>适配的过程可分为以下几步：<br>一，让 ViewController 遵循 UIViewControllerPreviewingDelegate:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// MARK: - UIViewControllerPreviewingDelegate Methods</div><div class="line"></div><div class="line">extension ViewController: UIViewControllerPreviewingDelegate &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>二，是把 ViewController 注册 Previewing:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">override func viewDidLoad() &#123;</div><div class="line">    super.viewDidLoad()</div><div class="line"></div><div class="line">    registerForPreviewing(with: self, sourceView: tableView)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>三，实现 UIViewControllerPreviewingDelegate 中的 preview 和 commit 方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// MARK: - UIViewControllerPreviewingDelegate Methods</div><div class="line"></div><div class="line">extension ViewController: UIViewControllerPreviewingDelegate &#123;</div><div class="line">  func previewingContext(_ previewingContext: UIViewControllerPreviewing, viewControllerForLocation locatin: CGPoint) -&gt; UIViewContrller? &#123;</div><div class="line">    guard let indexPath = tableView.indexPathForRow(at: location) else &#123; return nil &#125;</div><div class="line"></div><div class="line">    let chatDetailViewController = ...</div><div class="line">    chatDetailViewController.chatItem = chatItem(at: indexPath)</div><div class="line">    let cellRect = tableView.rectForRow(at: indexPath)</div><div class="line">    let sourceRect = previewingContext.sourceView.convert(cellRect, from: tableView)</div><div class="line">    previewingContext.sourceRect = sourceRect</div><div class="line"></div><div class="line">    return chatDetailViewController</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  func previewingContext(_ previewingContext: UIViewControllerPreviewing, commit viewControllerToCommit: UIViewContrller) &#123;</div><div class="line">    show(viewControllerToCommit, sender: self)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Preview-quick-actions"><a href="#Preview-quick-actions" class="headerlink" title="Preview quick actions"></a>Preview quick actions</h2><p>这里你可以自己决定是否要提供一些预览时的快捷操作。并不是最开始说的主屏幕上的快捷操作，而是这里的：</p>
<p><img src="http://i4.buimg.com/577817/330ac8dc3e144f43.png" alt="Markdown preferences pane"></p>
<p>这里需要 override 一个 previewActionItems 的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">override func previewActionItems() -&gt; [UIPreviewActionItem] &#123;</div><div class="line">    let heart = UIPreviewAction(title: &quot;&quot;, style: .default) &#123; (action, viewController) in</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return [heart]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中的 style 除了 .default 还有 .selected 代表被选中，以及 .destructive 代表具有破坏性的操作。</p>
<h2 id="Best-Practices-1"><a href="#Best-Practices-1" class="headerlink" title="Best Practices"></a>Best Practices</h2><p>同样，关于 Peek &amp; Pop ，Apple 提供了一些建议：</p>
<ul>
<li>可以被点击的内容应该要考虑支持 Peek &amp; Pop （和上面那条 每个 app 都应该提供 quick actions 差不多，毕竟 3D Touch 用力点按之前用户并不知道会发生什么，有些可以响应 3D Touch 有些又不能就可能会让用户很不爽，久而久之就不愿意去使用 3D Touch 了）</li>
<li>不要在 previewing delegate 中花费太长的时间，因为是需要 peek 一下就显示出来，不能做太过费时的操作。</li>
</ul>
<h1 id="UIPreviewInteraction"><a href="#UIPreviewInteraction" class="headerlink" title="UIPreviewInteraction"></a>UIPreviewInteraction</h1><p>UIPreviewInteraction 似乎是用的比较少的，这是一个可以让我们的视图提供响应 3D Touch 交互动作的类。刚才提到 preview 和 commit，实际上这是使用 3D Touch preview 中包括的两个过程。由于从开始点按屏幕到响应 peek（preview 阶段结束） 再到响应 pop (commit 阶段结束)，力度是有变化的。通过 UIPreviewInteraction 我们就可以获取当前用户点按力度分别在这两个阶段中的进度（0-1），这两个阶段的关系使用 API 官网中的一张图就可以表示清楚：</p>
<p><img src="http://i2.buimg.com/577817/ee50a5a22bc56521.png" alt="Markdown preferences pane"></p>
<p>适配过程同样很简单，大致如下：<br>一，遵循 UIPreviewInteractionDelegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extension xxViewController: UIPreviewInteractionDelegate</div></pre></td></tr></table></figure></p>
<p>二，创建 UIPreviewInteraction 并设置 delegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private var previewInteraction: UIPreviewInteraction?</div><div class="line"></div><div class="line">override func viewDidLoad &#123;</div><div class="line">    super.viewDidLoad()</div><div class="line"></div><div class="line">    previewInteraction = UIPreviewInteraction(view: view)</div><div class="line">    previewInteraction?.delegate = self</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>三，就可以通过代理方法获取到当前的进度，然后做你需要的事情了。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func previewInteraction(_ previewInteraction: UIPreviewInteraction, didUpdatePreviewTransition  transitionProgress: CGFloat, ended: Bool) &#123;</div><div class="line">    // Do something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为通过 progress 获取到进度，所以我们可以通过这个值来驱动一些动画之类的，仔细想想这个应该会是蛮好玩的。</p>
<h1 id="Low-Level-Force-API"><a href="#Low-Level-Force-API" class="headerlink" title="Low-Level Force API"></a>Low-Level Force API</h1><p>此外，session 228 的最后也提及了一下低层级力度 API ，在支持 3D Touch 或 Apple Pencil 的设备上，你可以获取到规范化的力度数据。关于这方面的内容，可以参见另一个 session: Leveraging Touch input on iOS.</p>
<h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><p>下面是一些 session 中并没有提及的内容。<br>除去上面通过 UIViewControllerPreviewingDelegate 适配常见的 UITableView, UICollectionView 等的 peek 与 pop 操作，还有一种比较常见的场景是，我们希望在 3D Touch 发生在 cell 的每个部分上时，作出不同的响应（比如，3D Touch 了某个 feed 我们希望预览这个 feed 的详情，而点的时 feed 里的头像时，我们希望弹出的预览是 profile）。我们可以在上面的基础上进一步，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public func viewContainsFormSuperview(with view: UIView, location: CGPoint) -&gt; Bool &#123;</div><div class="line">        let location = view.convert(location, from: self)</div><div class="line">        return view.bounds.contains(location)</div><div class="line">&#125;</div><div class="line"></div><div class="line">public func previewingContext(_ previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -&gt; UIViewController? &#123;</div><div class="line">        guard let indexPath = tableView.indexPathForRow(at: location) else &#123; return nil &#125;</div><div class="line">        guard let cell = tableView.cellForRow(at: indexPath) as? xxCell else &#123; return nil &#125;</div><div class="line"></div><div class="line">        let avatarView = cell.avatarView</div><div class="line">        let location = avatarView.convert(location, from: tableView)</div><div class="line">        if avatarView.bounds.contains(location) &#123;</div><div class="line">            let viewRect = tableView.convert(avatarView.frame, from: avatarView.superview)</div><div class="line">            previewingContext.sourceRect = viewRect</div><div class="line"></div><div class="line">            return ProfileViewController()</div><div class="line">        &#125; else &#123;</div><div class="line">            return nil</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结，session 中方提到的适配 3D Touch 主要三个方面 – 主屏幕快捷操作可以使用户直接跳转进对应的动作，Peek &amp; Pop 允许用户快速预览并导航到内容，最后的 UIPreviewInteraction 也为 app 的交互提供了新的可能。这篇文章也就到这里啦，如有问题和疏漏，还请指出。</p>
<p>最后准备提交的时候发现 多说即将关闭 的消息，啊，有点可惜。</p>
<h2 id="See-you"><a href="#See-you" class="headerlink" title="See you"></a>See you</h2><p>Created by ROC Zhang on 2017-03-26.<br>Copyright © 2016-2017 ROC Zhang. All rights reserved.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好不容易起个大早的居然就突然停电了，翻看到好久之前的 WWDC 学习笔记，想起来之前好像打算稍稍整理一下 3D Touch 相关内容的，趁着 MacBook 还有电顺手写一下。&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>遇到的 XC 8 中的两个小坑</title>
    <link href="http://www.roczhang.com/%E9%81%87%E5%88%B0%E7%9A%84%20XC%208%20%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B0%8F%E5%9D%91.html"/>
    <id>http://www.roczhang.com/遇到的 XC 8 中的两个小坑.html</id>
    <published>2016-11-28T16:23:12.000Z</published>
    <updated>2016-11-28T17:54:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天可能时运不济，一次碰到了两个小坑，趁着现在 pod repo update 的时候记一下。<br><a id="more"></a></p>
<h2 id="Background-Fetch"><a href="#Background-Fetch" class="headerlink" title="Background Fetch"></a>Background Fetch</h2><p>今天在一开始在写和 Background Fetch 相关的代码。把 performFetchWithCompletionHandler 写好，然后其他的配置做好之后，连上手机准备测试。因为一般 Background Fetch 发生都需要时间，而且这个调用的时间间隔是系统定的，即使设定了 setMinimumBackgroundFetchInterval(UIApplicationBackgroundFetchIntervalMinimum) 可能也要蛮久一段时间系统才会调用。所以一般都会点 Xcode -&gt; Debug -&gt; Simulate Background Fetch 让 Background Fetch 能立即执行来方便调试。</p>
<p>所以我当然也是要点的。<br>结果我期待的结果并没有和以前一样发生，程序居然奔溃退出了，就像这样。</p>
<p><img src="http://p1.bpimg.com/4851/100d68e61bc45fa2.png" alt="Markdown preferences pane"></p>
<p>我开始以为是自己代码有问题，于是调试了一会儿，最后发现即使我在方法里什么都不做调用的时候还是会奔溃。有点懵。然后我在模拟器上试了一发，结果发现并没有任何问题！调用是成功的！</p>
<p>Google 了一发，在 Apple Developer Forums 里看到了一篇贴 ( <a href="https://forums.developer.apple.com/thread/51361" target="_blank" rel="external">https://forums.developer.apple.com/thread/51361</a> )，也有人在 Xcode 8 上遇到了一样的情况：</p>
<p><img src="http://p1.bpimg.com/4851/544f7a16ca99aeee.png" alt="Markdown preferences pane"></p>
<p>然而最后是怎么解决的呢？当然不是等20分钟让他自然发生调用。你会发现在真机上点击后的奔溃是 Xcode 自己断开的，然后你再轻轻的点一下继续执行按钮，它就把我的 Background Fetch 执行好了。</p>
<p><img src="http://p1.bpimg.com/4851/6cef865f9bef302d.png" alt="Markdown preferences pane"></p>
<p>Fun.</p>
<h2 id="UNNotificationSound"><a href="#UNNotificationSound" class="headerlink" title="UNNotificationSound"></a>UNNotificationSound</h2><p>还有就是关于 UNNotificationSound 的问题。</p>
<p>我在尝试用 iOS 10 新的 UserNotification 来创建通知，一个本地通知，其他的一切都没有问题，然而自定义的提醒通知的声音就是无法播放。并且以前创建通知写法的代码是没有问题可以播放的。</p>
<p><img src="http://p1.bpimg.com/4851/960c9bffa8db51e8.png" alt="Markdown preferences pane"></p>
<p>从苹果的文档 ( <a href="https://developer.apple.com/reference/usernotifications/unnotificationsound" target="_blank" rel="external">https://developer.apple.com/reference/usernotifications/unnotificationsound</a> ) 看到 UNNotificationSound 支持由 Linear PCM ／ MA4 (IMA/ADPCM)／ µLaw ／ aLaw 封装成的 aiff, wav, caf 几种格式的文件。我也转换了几种格式都试了下想确定是不是格式的问题，而无论怎么测试，系统始终播放的是默认的三连音：哒哒哒。</p>
<p>然后我又遇到了一样处境的人（这次的人比较多），还是在 Apple Developer Forums 里的帖子（ <a href="https://forums.developer.apple.com/thread/49512" target="_blank" rel="external">https://forums.developer.apple.com/thread/49512</a> ）。</p>
<p>有人好像找到了暂时解决的方法：重启 iOS 设备，卸载 App ，然后重新安装，自定义的铃声就可以生效了。但是有人说这种方法在你使用 Xcode 再装 App 的时候又会失效了。</p>
<p><img src="http://p1.bpimg.com/4851/313c960e725367c2.png" alt="Markdown preferences pane"></p>
<p>但是无论如何，我的自定义铃声一直没有播出来。<br>Magic.</p>
<h3 id="？？？"><a href="#？？？" class="headerlink" title="？？？"></a>？？？</h3><p>天冷了，Macbook 的散热变好了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天可能时运不济，一次碰到了两个小坑，趁着现在 pod repo update 的时候记一下。&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>我的设计学习之旅</title>
    <link href="http://www.roczhang.com/%E6%88%91%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85.html"/>
    <id>http://www.roczhang.com/我的设计学习之旅.html</id>
    <published>2016-10-28T21:03:38.000Z</published>
    <updated>2017-05-29T16:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>今晚逛 Dribbble 的时候突然又点开看了自己悲剧的 Debuts ，于是突然想到理理这个，正好可以也当作自己博客 Design 系列第一篇。<br><a id="more"></a></p>
<h2 id="大学前"><a href="#大学前" class="headerlink" title="大学前"></a>大学前</h2><p>大学前基本应该不懂啥是设计（现在应该也不懂）。</p>
<p>初中的时候机缘巧合参加了网页制作的比赛，那时候第一次开始用 Photoshop，做一些素材，修改排版。当时觉得来回折腾调整，或者这种在“制作／创作”的感觉非常有意思。而初高中时期除了偶尔帮班主任做一些班会的 PPT 也就没什么时间和机会做东西了。那会儿能算的上接触的设计作品也就算是各种主题了。</p>
<h2 id="大学后"><a href="#大学后" class="headerlink" title="大学后"></a>大学后</h2><h3 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h3><p>大一刚进大学那会儿除了日常写程序结果是做各种 PPT，居然还被班上同学嘲笑为 “PPT 小王子”。其实是根本没啥特别的，只不过我没有用 Office 艺术字而已。附上一个那会儿给一个小活动做的 Keynote。</p>
<p><img src="images/myDesignsStudyTour/1.jpeg" alt="Markdown preferences pane"></p>
<p>然后就开始算的上设计了第一个作品了– 真选！那时候还不是会做真正的 App 开发，就在 Photoshop 里面画设计稿。那时候完全不了解 App 设计的准则规范之类，完全凭借着自己的感觉来。从自己觉得丑到爆炸到后来慢慢改成觉得还行之间，也是改了很多个版本。</p>
<p>一开始几个版本是这样的，其实都挺辣眼睛的：<br><img src="images/myDesignsStudyTour/2.png" alt="Markdown preferences pane"></p>
<p>最后做成这样了：<br><img src="images/myDesignsStudyTour/3.png" alt="Markdown preferences pane"></p>
<p>还若有其事的做了一个 MockUp 当 Cover ：<br><img src="images/myDesignsStudyTour/4.PNG" alt="Markdown preferences pane"></p>
<p>后来非常幸运的认识了 Martin Waters ， 神奇的白开水兄。大一暑假的时候还和白开水见了面，一起继续做了真选参加了一小比赛。一开始是在一个编程开发的群认识了白开水，后来发现白开水设计的东西都惊人的漂亮。我那时会将我设计的一些不堪入目的东西交给白开水，他总是会画腐朽为神奇一般的 redesign 的非常棒。而且他总是会向我介绍一些非常神奇的工具，比如我第一次了解 Sketch 就是白开水介绍给我的，嗯，真是如同打开了新世界的大门。</p>
<p>当年暑假白开水兄画下的一些 Icon ：<br><img src="images/myDesignsStudyTour/5.png" alt="Markdown preferences pane"></p>
<h3 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h3><p>寒假的时候读了 About Face 和 设计心理学全系列的四册，算是第一次开始看设计类的书籍。后来开学之后大多数时间都在学习写 App，所以就在有了新 App 想法的时候会画上一些:</p>
<p>Roc Daily<br><img src="images/myDesignsStudyTour/6.png" alt="Markdown preferences pane"></p>
<p>教务助手<br><img src="images/myDesignsStudyTour/7.png" alt="Markdown preferences pane"></p>
<p>期间还画过一些小东西，比如图标还有小组件之类的：<br><img src="images/myDesignsStudyTour/8.png" alt="Markdown preferences pane"><br><img src="images/myDesignsStudyTour/9.PNG" alt="Markdown preferences pane"></p>
<p>实习的时候见到了之前仰慕已久大神们，在一旁观察他们做设计时的章法、理念、创意，还有和我们把 App 用程序写出来之后和设计稿仔细的比对调整，像素级的双眼和对细节的追求。嗯，我在钦佩的同时又开始感概道阻且长啦。</p>
<p>之后还得到了自己心心念念的 Dribbble 邀请码（我要再次再次感谢敬爱的马老师），本打算也画一波 Hello Dribbble 的我尝试了几稿后还是决定在原来的设计稿上修改一个提交，于是这就是我的 Debuts 了:</p>
<p><img src="images/myDesignsStudyTour/10.png" alt="Markdown preferences pane"></p>
<p>Dribbble 上的地址是：<a href="https://dribbble.com/shots/2969219-Hello-Dribbble" target="_blank" rel="external">https://dribbble.com/shots/2969219-Hello-Dribbble</a></p>
<p>现在感觉确实画的不好后悔把这个当 Debuts 啦。</p>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>想起来刚开始练习做设计的时候还怀疑过不写代码自己是不是跑偏了，后来觉得如果是自己想要做一个产品的话，设计和开发都是实现好产品的一种方式，本质是相同的。我想过做设计的目的是什么，嗯，应该是悦心，从设计产品的 look 到 work，好的设计总能让人感到愉悦。这太值得了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今晚逛 Dribbble 的时候突然又点开看了自己悲剧的 Debuts ，于是突然想到理理这个，正好可以也当作自己博客 Design 系列第一篇。&lt;br&gt;
    
    </summary>
    
      <category term="Design" scheme="http://www.roczhang.com/categories/Design/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 中的 Delegate 设计模式</title>
    <link href="http://www.roczhang.com/iOS%20%E4%B8%AD%E7%9A%84%20Delegate%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://www.roczhang.com/iOS 中的 Delegate 设计模式.html</id>
    <published>2016-10-24T15:32:31.000Z</published>
    <updated>2016-11-28T17:40:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近写的 iOS/Swift 代码比较多，很久没动笔又没怎么写过技术类的文章。所以决定从小小的总结一下 Delegate 模式开始写一写，因此这也是一篇入门文章。<br><a id="more"></a></p>
<h2 id="What-is-Delegate"><a href="#What-is-Delegate" class="headerlink" title="What is Delegate ?"></a>What is Delegate ?</h2><p>我想很多同学第一次遇见 Delegate 这个词是在写 tableView 的时候。那时候我也只是每每需要用的时候就照着这种模式写上 tableView.delegate = self, tableView.dataSource = self 也并不理解究竟是什么意思。</p>
<p>应该说 delegate 是 Cocoa/CocoaTouch 中的一种设计模式，正如前面提到的 tableView 一样，Cocoa 框架中很多地方都用到了这种设计模式。这种设计模式中我们可以将一个对象的一些功能委托给另一个对象来实现。因此使用 delegate 模式可以帮助我们设计出更松耦合的代码。</p>
<p>delegate 使用起来非常简单。假设我们现在需要一个电视机和一个音响，我们想要将电视机播放声音的职责委托给外置的音响来实现，我们就可以这样编写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// 首先定义一个 Protocol 协议</div><div class="line">protocol PlayAudioDelegate &#123;</div><div class="line">  func playAudio()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 编写一个遵循 PlayAudioDelegate 协议的音响对象，实现协议中的方法</div><div class="line">class Speaker: PlayAudioDelegate &#123;</div><div class="line">  func playAudio() &#123;</div><div class="line">    printLog(&quot;Start Play!&quot;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 编写电视机</div><div class="line">class TV &#123;</div><div class="line">  // delegate 可以为任何遵守 PlayAudioDelegate 协议的对象</div><div class="line">  var delegate: PlayAudioDelegate?</div><div class="line"></div><div class="line">  func play() &#123;</div><div class="line">    // 当 delegate 对象存在时，调用对象的 playAudio 方法</div><div class="line">    delegate?.playAudio()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let tv = TV()</div><div class="line">let speaker = Speaker()</div><div class="line"></div><div class="line">tv.delegate = speaker</div><div class="line">tv.play()  // printLog 将输出 &quot;Start Play!&quot;</div></pre></td></tr></table></figure>
<p>如上，使用起来并不复杂，但还是存在一些问题的。</p>
<h2 id="可选"><a href="#可选" class="headerlink" title="可选"></a>可选</h2><p>上面的例子里，我们使用 PlayAudioDelegate 这个 Protocol 来定义了一些方法，我们也知道 Swift 中当让一个类遵循某个协议的时候，这个类中必须将 Protocol 中定义的所有属性和方法实现，否则编译器将报错。</p>
<p>但实际情况中，我们可能只需要当前类实现 Protocol 中的部分方法，就好像在使用 tableView 中，我们并不是想要每一次都需要将 UITableViewDelegate 和 UITableViewDataSource 中所有方法都全部实现。</p>
<p>我们有两种方法来实现 Protocol 中的可选。</p>
<h3 id="objc"><a href="#objc" class="headerlink" title="@objc"></a>@objc</h3><p>一种是借用 @objc 关键字来实现。我们可以在定义 Protocol 时在前面加上 @objc 关键字，然后在协议中需要定义为可选的方法前也加上 @objc 和 optional 来定义一个可选方法。如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@objc protocol PlayMediaDelegate &#123;</div><div class="line">  @objc optional func playAudio()</div><div class="line">  @objc optional func playVideo()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样在需要类遵循 PlayMediaDelegate 协议时其中的 playAudio() 和 playVideo() 方法就不再是必须要实现的。</p>
<h3 id="extension-Protocol"><a href="#extension-Protocol" class="headerlink" title="extension Protocol"></a>extension Protocol</h3><p>第二种方法，也是我个人更常用的方法，就是将协议扩展，给出协议中方法的默认实现来达到不需要在遵循 protocol 的类中必须实现所有方法的效果。</p>
<p>我们使用 Swift 中的 extension 来对 Protocol 进行扩展。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// MARK: - PlayMediaDelegate Protocol</div><div class="line">protocol PlayMediaDelegate &#123;</div><div class="line">  func playAudio()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// MARK: - Extension PlayMediaDelegate Protocol</div><div class="line">extension PlayMediaDelegate &#123;</div><div class="line">  func playAudio() &#123;</div><div class="line">    printLog(&quot;Play Audio Now&quot;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，我们通过在扩展中给出需要可选方法的默认实现，也可以达到效果。在使用时，遵循当前 Protocol 的类在不实现方法时将使用 extension 中的默认实现。当然，你也可以再类中给出这个方法重新实现。</p>
<h2 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h2><p>倘若你对内存管理和 ARC 有一定的理解，你可能会发现我们在上面的代码中可能存在一些问题（ 内存管理和 ARC 这里就不展开了）。<br>为了避免循环引用，我们可能会通过尝试在 delegate 前加上 weak 来声明当前类不负责保持 delegate 这个对象，让它的销毁由外部控制。从而利用 ARC 的这个特性帮助我们完成内存管理。如将上面的例子改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">protocol PlayAudioDelegate &#123;</div><div class="line">  func playAudio()</div><div class="line">&#125;</div><div class="line"></div><div class="line">class TV &#123;</div><div class="line">  weak var delegate: PlayAudioDelegate?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但很快就会发现编译器报错了。</p>
<p>为什么？<br>在 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID281" target="_blank" rel="external">Apple 爸爸的这篇文档</a> 里，我们可以知道：</p>
<p>1) Swift 中的 Protocol 是可以 class, struct, enum 这些类型都可以遵循的<br>2) 而 struct, enum 并不通过 ARC 来管理内存，所以 ARC 中的 weak 并不能用来修饰</p>
<p>那应该怎么办？</p>
<p>答案是将 Protocol 限制为 Class-Only Protocol，也就是只能被 class 而不能被其他类型遵循的协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">protocol PlayAudioDelegate: class &#123;</div><div class="line">  func playAudio()</div><div class="line">&#125;</div><div class="line"></div><div class="line">class TV &#123;</div><div class="line">  weak var delegate: PlayAudioDelegate?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就可以啦。</p>
<p>此外，为什么 class TV 中的 delegate 我们用了 optional 类型，因为我们使用了 weak 来修饰 delegate， 这就有可能导致 delegate 在使用过程中变为 nil，所以我们需要使用 optional 类型。否则编译器也将报 “ ‘weak’ variable shoule have optional type ‘…?’ “ 错。</p>
<h2 id="See-you"><a href="#See-you" class="headerlink" title="See you"></a>See you</h2><p>Created by ROC Zhang on 2016-10-24.<br>Copyright © 2016 ROC Zhang. All rights reserved.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近写的 iOS/Swift 代码比较多，很久没动笔又没怎么写过技术类的文章。所以决定从小小的总结一下 Delegate 模式开始写一写，因此这也是一篇入门文章。&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>跨越大二下：（一）</title>
    <link href="http://www.roczhang.com/%E8%B7%A8%E8%B6%8A%E5%A4%A7%E4%BA%8C%E4%B8%8B%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>http://www.roczhang.com/跨越大二下：（一）.html</id>
    <published>2016-08-14T15:49:38.000Z</published>
    <updated>2016-11-28T17:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>北京时间2016年8月14日23点49分。</p>
<p>日子真的过的好快，就这样到了8月中旬。来帝都已经两周多了，实习的日子应该也只剩下两周，之后紧接着又要开学。一直想把从上学期到现在蛮久一段时间的事情理一理，却又一直没能真正坐下来动笔。呼～就今天开始吧。</p>
<p>嗯，还是先闪回到上学期的日子，慢慢开始理吧。<br><a id="more"></a></p>
<h2 id="3月-6月"><a href="#3月-6月" class="headerlink" title="3月-6月"></a>3月-6月</h2><h3 id="在学校的糟糕生活"><a href="#在学校的糟糕生活" class="headerlink" title="在学校的糟糕生活"></a>在学校的糟糕生活</h3><p>说起来大二下这一个学期我过的并不愉快。这一学期似乎我的的确确没有在其他事情上花很多时间，生活方式简单到概括起来除去我在实验室写代码的时间只剩下在寝室弹吉他、去看电影、和好友约饭。而且这些其他的事情占的比例其实很小。然而在学校的日子到后面开始让我越发感到煎熬起来，甚至很多事我也越来越不想参与，有不少课我都没有去上而是在实验室继续做自己的事。总结其原因，我觉得真的可以用 JustZht 说的三观不合来回答。真的开始感觉自己越来越和这个学校很多人三观不合。我并不想而且也没有啥资格去评价别人的生活方式价值取向如何如何，因为每个人的生活完全是自己的事，被自己不认可的人干预和评价并不是一件愉快的事情。</p>
<p>但于我单方面而言，这种三观不合给我在学校的生活带来很多不适。举例来说，就比如之前和寝室里其他同学越发不可调和的冲突，使得这种不合已经逐渐到了开始让我感觉恶心的一步。我对别人生活的选择是无权干涉，但每天每周每月每学期夜里两三点还有音乐播放和台灯照射，每天午休都是打印机的声音与游戏鼠标的劈劈啪啪，这种种的事情已经对我的生活造成了无法回避到无法忍受的困扰。而即便是这种情况居然还会有其他同学的评论是我应该体谅容忍，我对自己胸怀的狭小真是感到抱歉。又或是在技术方面，实际上身处若大的一个计科院，你却很难感受得到对技术的热情。因为并没有太多人热衷于关注和讨论行业相关的事情。本来就没有多少人关心技术，所以更是没多少人关心新技术。并且整个学校也总是会时不时弥漫着面向创业、面向 PPT 编程的氛围，所以在学校也难以找到几个聊得来的同学。可能只有实验室算是要好一些的地方。</p>
<p>于此种种，大事小事，似乎真的只能用三观不合来解释了。我也越来越不愿意和别人理论争论什么，因为很多事说起来似乎都是小事，说大了那就是三观问题，浪费生命在这些事上没有意义。</p>
<p>解决？我已经决定大三开学就搬出去了，学习技术或者准备考研，这种事情放在我的寝室里是永远无法进行下去的事情。而其他的不合，回避。保持和能聊得来的朋友的日常交际，就已尽非常足够了。</p>
<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>这学期开始给自己添了一些新设备。一是从 WASD 定制了一个机械键盘，茶轴无刻，自选配色，看起来漂亮用起来爽。二是买了一个 DELL UltraSharp 25’ 显示器，和 MacBook 用 ThunberBolt 接起来，非常省心。还有其他的一些小东西。我总觉得在干活的家伙上开销是非常值得的，光只是这两样就让我 Coding 时候的效率和心情都高了不少。这学期也是读了不少书，一类是关于设计的书，比如寒假时 Kevin 推荐的 About Face 和设计心里学的4册，剩下的就是技术类的书了。技术上这学期开始学了 React Native，中间趁机学了一小把 Android。Android 说起来好像也就只是摸了一把，写了一个2048，所以也不能算真的学了。然后就是跟着学校点了一些数据库和 JAVA 的技能。说起来上课我是真的没有太仔细听的，到后期好像都在用纸手写代码或者带着 Kindle 去看书。这两门课都是到后来要交课程设计的时候我才开始学的，课程设计我写了一个 MySQL + JAVA + iOS App 的小系统直接当做两门课的课程设计交了两次，写了两天。JAVA 老师最后点评说这个可以当毕业设计了我是有点惊讶不知道是真是假。</p>
<p>说回上课不听的这种方式，这样当然是有不好的地方，期末之前总要体验一把绝望的感觉和被挂科支配的恐惧。但明知如此，我还是更喜欢花时间在自己钻研技术上，只是如果要考研的话，可能以后还要多花很多力气吧。不过还好，这学期依旧延续从前，没有挂科，有些科目考的还算不错。</p>
<p>关于技能除了刚才说的 React Native \ Android \ JAVA \ DataBase 这些，主要时间还是花在 iOS 上了。开始学习了 Apple 的 SpriteKit 和 SceneKit, 然后重新好好读了一些关于 Swift 的文章，感觉起来对很多 Swift 里的概念和特性又有了新的理解，比如函数式的一些有趣的东西。之后写了两个至今难产的 Project， 虽然产品难产，但过程里还是收获了不少，包括 GCD, CA, CG 之类。造了两个小轮子。但我开始感觉自己之前尤其是大一的时候好像走了弯路，浪费了不少时间，对 iOS ，真的是要继续深入不停学习才是，自己还是太嫩了。</p>
<p>其他，这学期体验了一把代教选修课。到最后感觉并不特别愉悦，总让我感觉无论是学校还是学生对待选修课似乎都不是一个严肃的事情，比如选修课时间总是会被各种事情占用，让人感觉似乎就不是一个严肃的教学和学习的地方。不过也无妨，这种事情本来还是看个人自己的呗，靠外面 PUSH 有啥子用。</p>
<p>快期末的时候受一位老师指点去研究一个开源的物联网项目。趁此机会又一次的温故和学习了一些 Linux 相关的，还有部署之类的，最后花了一些时间去了解使用了 MongoDB ／ Maven / MQTT , 也仅限是了解和尝试，并没有深入。</p>
<p>还有不知道算不算是技术上的，这学期去考的那个软件设计师，之前查询结果通过了，所以也是在大二结束了这个事情。我个人对考证的兴趣是不大的，而且这个考试并不会对某一个方面有很深入的考察，但是横向的面却撒的很大。考着玩是可以的，我也没有在准备这个考试上花时间，甚至是交报名表和打印准考证的时间。哈，这要感谢我们实验室被称为小暖男的学弟。</p>
<p>最后，在今年的 WWDC 第二天去注册了 Apple Developer Program。为啥这么晚注册呢，因为之前好像没咋考虑过要上架的事情？所以以后每年 WWDC 续费 Developer Program 的时候还可以提醒自己想想干了啥。然后还有幸去参加了的的确确是 Apple 举办的一个小型研讨会，中途茶歇的时候还和一位 Apple 的人员简单的交流了一会儿，非常棒的体验。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>从开始练习 FingerStyle 的指弹吉他演奏，这学期还是有一直坚持继续练习吉他。这学期弹会的曲子不多，把之前的 Kujira 练熟了，之后学弹了 Little Martha 、Rings 和 Voyage for Ireland，一共换了两幅弦，还是 Elixir 11025 。值得一提的是，5月的时候和阿汪一起去听了 Pierre Bensusan 的武汉场演奏会，坐在内场5排，第一次亲眼见到三叔，印象非常深刻。感觉三叔确实老了，但在现场亲耳听到 So Long Michael 、 WuWei 等等自己听了许久的 DADGAD 名曲的时候确实很感动。想起自己当时学弹 FingerStyle 可能也就是为了演奏三叔的 WuWei …</p>
<p>其实因为说起来在学校好像也没有什么健康有趣适合我的放松方式，加上我又是一个完全玩不转游戏的人，所以写代码和看书之外的放松，我就会去看电影或弹吉他。去看电影的话平均每周可能至少都会抽出时间去看一次，算起来好像上学期也看了20场以上了。其中当然一个人也会去，我想大部分人都会非常享受能有一段完全属于自己而不会被别人打扰的放松时间。</p>
<p>所以这两种放松的方式实在是非常适合我。</p>
<p>惭愧的是本学期依然没有开始好好锻炼身体，以至于现在每当我和班上同学说起我要去锻炼身体一事，他们的脸上总是会透露出让我难以名状的笑容。然而严肃的说，现在可能坐的时间对着屏幕的时间越来越多了，有时候也会通宵 Coding，我有时候能感受到自己身体发出的不舒适的信号。所以剩下能在学校继续呆的一年多的时间，放掉其他的事情之后，锻炼身体是必须的了。而且在学校的日子里，饮食上也总是很难挑选或者控制。</p>
<p>于此乎，2016年6月结束。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;北京时间2016年8月14日23点49分。&lt;/p&gt;
&lt;p&gt;日子真的过的好快，就这样到了8月中旬。来帝都已经两周多了，实习的日子应该也只剩下两周，之后紧接着又要开学。一直想把从上学期到现在蛮久一段时间的事情理一理，却又一直没能真正坐下来动笔。呼～就今天开始吧。&lt;/p&gt;
&lt;p&gt;嗯，还是先闪回到上学期的日子，慢慢开始理吧。&lt;br&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.roczhang.com/categories/Life/"/>
    
    
  </entry>
  
</feed>
