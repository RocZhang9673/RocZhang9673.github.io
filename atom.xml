<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Roc Zhang&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.roczhang.com/"/>
  <updated>2018-09-09T16:50:31.714Z</updated>
  <id>http://www.roczhang.com/</id>
  
  <author>
    <name>Roc Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018.09.09</title>
    <link href="http://www.roczhang.com/20180909.html"/>
    <id>http://www.roczhang.com/20180909.html</id>
    <published>2018-09-09T03:10:23.000Z</published>
    <updated>2018-09-09T16:50:31.714Z</updated>
    
    <content type="html"><![CDATA[<p>2018 的夏天结束了。</p>
<a id="more"></a>
<h2 id="Things-at-Work"><a href="#Things-at-Work" class="headerlink" title="Things at Work"></a>Things at Work</h2><h3 id="AirLogs-2"><a href="#AirLogs-2" class="headerlink" title="AirLogs 2"></a>AirLogs 2</h3><p>AirLogs 2 大体上算是完成了，还差一些小组件和部分功能的优化。</p>
<p><img src="http://www.roczhang.com/images/20180909/02.png" alt="1"></p>
<p>上周五在公司的每周 iOS 组分享里第一次介绍了 AirLogs 2，一共准备了 80 页整的 Keynote，讲了近一个小时。这个原先为了解决连接与展示问题方便 QA 实时查看日志的工具在一个月前完成了第一个版本之后收到了不少反馈，在 2.0 中新增了通过 MultipeerConnectivity 的无线连接方式以及 ADB 连接 Android 设备的方式，同时也增添了独立组件后的 Formatter 与 Filter 工具，也完全重新设计和改写了 UI。</p>
<p><img src="http://www.roczhang.com/images/20180909/01.png" alt="2"></p>
<p>写 AirLogs 算是我第一次写 Cocoa Mac App，AirLogs 2 因为是完全从头开始，因此也算是第二次开始写 Cocoa Mac App。同时我也花了些时间完全重新设计了 AirLogs 内部的组件架构，也和一位同事大佬讨论得到了建议。因为最近也在读「聊聊架构」这本书，算是在实际尝试思考实践 “核心生命周期” 和 “树状架构” 两个概念。后面全部完成正式在内部 release 之后应该会写一篇详细一些的文章介绍 AirLogs 2 的结构和用到的技术。</p>
<p>同时 MultipeerConnectivity 是一个非常好玩的框架，但以前都没发现过，最近还是在看 ARKit 2 的 demo 中通过 MultipeerConnectivity 框架传输 ARWorldMap 才开始了解这个从 iOS 7 时代就有的框架。感觉起来应该可以用这个框架做很多好玩的事情。</p>
<h2 id="Personal-Life"><a href="#Personal-Life" class="headerlink" title="Personal Life"></a>Personal Life</h2><h3 id="Boxing"><a href="#Boxing" class="headerlink" title="Boxing"></a>Boxing</h3><p>上个月决定了开始学习拳击，在第三周去上了第一节拳击课。我好像从小开始就不是非常喜欢和擅长运动的人，决定去学一方面是开始感到每天长久坐着工作同时缺乏运动之后身体越来越差，另一方面是一直觉得拳击/搏击这类运动很有挑战很想试一试，因此第一次去的时候就有一种成就解锁达成的感觉。记得初中的时候看「第一神拳」这部动漫，就很喜欢主人公“一步”燃到爆的态度。</p>
<p>自己开始学之后当然是不会有动漫里那么热血的故事，但对我还是挺有挑战的。我的体能、跳绳之类都不是很行，同时初学开始是要不断不断重复各种基础动作，就像是和练习所有其他技能一样。但从开始到现在一共 5 节课过去，还是能挺明显感到自己在进步的，会让自己非常开心，甚至最近走路的时候都会偶尔中二练习出拳（还被路旁的外卖小哥用奇怪的眼神扫视了）。</p>
<p>目前是每周两节课的频率，然后是在午休时间去，当然也就少掉了吃午饭的时间。但运动之后下午精神还能保持挺好的状态，也顺便能帮自己戒掉每天喝咖啡导致的有些咖啡因成瘾了。希望自己能坚持下去，某一天能和别人实战训练的时候应该算是又可以解锁一个成就了。</p>
<h3 id="Side-Projects"><a href="#Side-Projects" class="headerlink" title="Side Projects"></a>Side Projects</h3><p>之前小幅更新了一个 Adonis 的版本，后来公司的事情又多起来，再去掉写 AirLogs 2 的时间，目前又是没啥时间可以更新个人项目的状态了。</p>
<p>上个版本的 Adonis 里接入了腾讯的 “吐个槽” 反馈平台，上线之后发现发帖反馈的还不少，因此开始思考之前用的邮箱、Slack 等方式对用户反馈来说是不是成本有些太高了。同时也在闲暇时间规划了 Adonis 3 的 Features，也第一次在做个人项目的时候开始尝试详细写 PRD。然后就开始发现 3.0 里要做的功能可能只用 CloudKit 或者其他 BAAS 服务是不够了，可能不得不又要自己写后端还有维护了。</p>
<p>天，真的还有好多想做的项目但时间实在是太不够了。</p>
<h2 id="Talks"><a href="#Talks" class="headerlink" title="Talks"></a>Talks</h2><p>终于有了时间可以在下个月的十一小长假回学校去拿已经发放了好久的毕业证和学位证。然后偶然才发现比自己小一届的学弟们已经开始找工作了，加上上周流利说六周年年会，然后猛然间发现自己来流利说也已经快一年了。</p>
<p>熟悉我的可能知道实际上我算是已经不间断工作 2 年多了，从在学校大三一整年做 part-time intern 开发，到大四做 full-time intern 开发，再到现在变成一个 full-time employee，每年故事的转折点好像都在夏天发生。在不断遇到的好好坏坏的事里不断修正着自己的心态，也不断在了解确定自己想追求的是什么。身边的环境和人总会变化，处理内我和外界之间相处的方式不是一件容易的事情，从妥协到自信到固执之间也不只是改变不改变那么简单。在一个不断要去面对外界环境的挑战里，从被人怀疑到产生自我怀疑之间也不止是坚信自己的选择那么简单。</p>
<p>2018 的夏天结束了，窗外隐约之间能听到的蝉鸣还有一丝夏天的余韵。我还确信有自己的热爱和坚持，我告诉自己新故事又要开始了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018 的夏天结束了。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.roczhang.com/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>2018.08.15</title>
    <link href="http://www.roczhang.com/20180815.html"/>
    <id>http://www.roczhang.com/20180815.html</id>
    <published>2018-08-14T16:50:56.000Z</published>
    <updated>2018-09-09T16:50:28.602Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.roczhang.com/images/20180815/01.png" alt="cover"><br>“某公司设计师和 iOS 工程师被 PM 逼疯，对着桌子傻笑着疯狂拍照。“</p>
<a id="more"></a>
<p>上上周经历了魔鬼的一周。之前重构的部分基本结束，然后就是发版前的不断完善、测试、修改。为了不影响正常发布几乎上上周每天晚上回家了之后都在继续，甚至还有两三天都在小通宵还加上一整个周末的时间，最后终于还是没有 delay 在周一正常提交 App Store 审核了。目前上线不到一周，还没有遇到重构部分相关的问题。</p>
<p>其中的发生了两件值得一提的小插曲。其一是审核被拒，理由是权限描述不具体。最近 App Store 因为这个理由拒绝的频率好像还挺高，除了周边开发者朋友的描述，我自己前一段时间也遇到过。Mr.Weather 申请定位权限用于自动定位城市的描述从上架到现在 1 年多从来没有改动过也从来没有被拒过，上次因为同样的理由被拒了，后来回复了审核之后重新 review 很快过审。结合最近审核又开始变慢（平均需要两天左右）和不少开发者在吐槽的客服要求找开发者退费问题，有些担心后面情况会更加恶化。</p>
<p>另一件事是工作时间。某天接通知要求上班时间从弹性工作时间改成固定早 10 点到晚 9 点。当时大家还都不太开心，即使基本上开发在弹性工作时间制下的工作时间并不会比这样固定的时间少。国内工程师晚上加班都是普遍行为了，因此国内互联网公司非常流行的弹性工作制在形式上的不固定对工程师相对也更友好一些，提倡效率也更结果导向。好在最后我们还是改回了弹性工作时间。</p>
<hr>
<p>上周末去了 T 沙龙，也是自己第一次在外做技术分享。分享的主题是 ARKit，然后做了一个桌面打保龄球的小 AR 游戏做 demo。非常羞耻的还是紧张了（捂脸），语速有些快而且漏掉了一些实现准备讲的点没有深入进去提，最终时长也比预计短了不少。好在 T 沙龙气氛非常好，QA 环节有很多人提问，结束了之后也有很多观众来继续提问和交流（顺带一提又一次遇到了 Mr.Weather 的用户）。组委会给的准备时间其实很长，但自己还是因为拖延和重构事情准备的不够充分。毕竟分享还是应该要能对得起观众的时间，经历这次之后我想最好还是准备详细的演讲注释或者提纲。很感谢 @chun 和组委会给机会分享，后面自己要好好积累希望以后有机会能再做分享了。</p>
<p>非常开心的是见到了很多 iOS 开发大佬，比如 MM、冬瓜、EyreFree 等等大佬，都是之前我有用过的开源库的作者或读过和在关注的博客的作者。和大佬们一起吃饭时听了大佬们聊工作日常和技术讨论，真的是非常开心了。</p>
<p><img src="http://www.roczhang.com/images/20180815/02.png" alt="cover"><br><img src="http://www.roczhang.com/images/20180815/03.png" alt="cover"></p>
<hr>
<p>更新一些自己项目的状态。之前有不少次看到用户在各种渠道问 Mr.Weather 2 上架的时间，但非常抱歉的是我真的不知道。原因在于虽然之前 Mr.Weather 2 设计完成，iOS 代码也写了一部分，但后期自己还是越来越觉得不满意，而且工程上希望能有机会 Support 到不同的平台，除了 iPhone 之外，希望（目前只是希望）还能提供 macOS 上的版本，如果后面时间充裕的话应该还会做 watchOS 的版本和为 iPad 优化的 UI，所以重新建了工程。现在变成了一个大的 workspace，下面目前包含了  Mr.Weather-iOS、Mr.Weather-macOS、Mr.Weather-Core、Mr.Weather-Data、Mr.Weather-Resource 这些 project，框架和相关服务配置啥的都已经搭好接好了，后面就是用时间来填充完成了。</p>
<p>想做和要做的事情还有很多，比如更通用的 AirLogs，还有 Adonis 3，还有 24，甚至最近还越发想写一个播客应用… 可惜的只是时间精力永远不够用，只能好好安排具体去做了。</p>
<p>最近会感觉到自己状态要比前一小段时间好一些，我想自己会这样循环往复状态好或者不太好，原因就是自己周边不断发生的各种事情或无形或有形的在影响我对自己的定位与认知。这种循环起伏也许没什么不好的，至少目前似乎每经历一个周期都能让我修正一点自我定位和认识。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.roczhang.com/images/20180815/01.png&quot; alt=&quot;cover&quot;&gt;&lt;br&gt;“某公司设计师和 iOS 工程师被 PM 逼疯，对着桌子傻笑着疯狂拍照。“&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.roczhang.com/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>2018.08.03</title>
    <link href="http://www.roczhang.com/20180803.html"/>
    <id>http://www.roczhang.com/20180803.html</id>
    <published>2018-08-03T15:28:15.000Z</published>
    <updated>2018-08-03T17:02:13.321Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.roczhang.com/images/20180803/01.png" alt="ReLife"></p>
<p>ReLife 真是一部太棒的剧了，让我忍不住要发表中二感言，也突然又想起了两年前的生活。</p>
<a id="more"></a>
<p>这周吃午饭时和同事们闲聊，突然就开始互相安利起动漫来。于是我一下子又想起了 ReLife 这部番，一查，才发现原来都已经出了完结篇了。然而这周一直在处理上周 Roadmap 重构后还没有解决完全的问题与 bugs，每天都是疯狂加班，到家还得继续，今天终于有些许闲暇来看完了短短 4 集的完结篇（虽然到了周末还是要加班继续，囧）。</p>
<p>ReLife 的剧情大体是 27 岁的男主在工作中遭遇挫折成为尼特族，选择 ReLife 重生计划，一年时间回到 17 岁的高中生活，开始重新审视自己，并结识了女主和小伙伴们的故事。</p>
<p>回翻相册发现第一次开始看 ReLife 这部番是在 2016 年，大概也就是自己大三那年，自己白天上课晚上远程兼职做开发的那段时间。当时的自己还不用特别为毕业之后的事情所烦恼，只是单纯做好自己的工作与学习，是每天都能因为自己技艺得到进步，能与厉害的同事交流，并且生活可以自给自足感到开心满足的一段时间。白天上课晚上工作虽然挺辛苦，但回想起来也是大学期间技术进步最快的一段时间。当时的自己会经常需要熬夜或者通宵，写代码间隙感到饥饿就会吃两片大吐司夹雀巢炼奶，并看一看各类番剧来放松休息。那段时间看的除了孤独的美食家、食彩之国、看理想的各类节目，就是 ReLife 了。</p>
<p>自己追过的番并不多，看完 ReLife 动漫之后，忍不住第一次开始找漫画来看。而后面 comico 国区停止运营，台区 comico 涌入大波难民，再到看到 ReLife 真人舞台剧的上映，一直很期待能看到这个故事的结局，而后面随着自己毕业事情慢慢多了起来，就逐渐没能再继续关注，直到这次又看到了完结篇。看到弹幕提到完结篇由于经费不够是众筹出来的，画面和剧情上确实做了很多删减，但能看到这次的完结篇，已经让我觉得非常感动了。</p>
<p>我想 ReLife 之所以能让很多人产生共鸣感到被打动，也许是不少人都有过的，想要回到以前的日子再来一次的念头；还有每一次仿佛自己都经理过的喜怒、纠结和最后面对离别的不舍。我也无数次想过自己回到从前，也许会作出哪些改变，也许会重新做哪些选择。但 ReLife 并不是一部乌托邦剧，回到 17 岁也不是为了回避在成人世界所遇到的烦恼，而是一个机会能够得以重新审视自己，做出改变再继续勇敢面对后面的生活。男主和女主从害怕 ReLife 结束之后所有印记都要被抹除，害怕越是绚烂的烟花消失之后就越是落寞，到最后尽情珍惜每一分一秒，相信即使一切最终都会被抹去，但当下的存在也是真实。</p>
<p>ReLife OP 里的一句歌词是“不要回头，勇敢向前，即使没有再会的那一天”，让我想到自己高中毕业时把同学的一句留言“幻梦终醒，本无不散之宴。却无悔，付之年华”加到了毕业纪念视频的最后。我依然是一个会经常忧虑未来，担心后续，焦虑下一刻的人。也会有“这些在多久之后都不会再和我有任何关系”而影响当下选择的想法。但也许，选择尽情全身心投入当下，才是更勇敢和更不易后悔的选择。即使知道一切都会散去，但依然能选择勇敢地面对，全身心投入到当下的一期一会中。</p>
<p>感谢你，ReLife。感谢你的漫画，夜宵草与 Comico。</p>
<p>我们无法经历一次 ReLife，但我们可以选择勇敢的面对和珍惜当下的生活。</p>
<p><img src="http://www.roczhang.com/images/20180803/02.png" alt="ReLife"><br><img src="http://www.roczhang.com/images/20180803/03.png" alt="ReLife"><br><img src="http://www.roczhang.com/images/20180803/04.png" alt="ReLife"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.roczhang.com/images/20180803/01.png&quot; alt=&quot;ReLife&quot;&gt;&lt;/p&gt;
&lt;p&gt;ReLife 真是一部太棒的剧了，让我忍不住要发表中二感言，也突然又想起了两年前的生活。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.roczhang.com/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>2018.07.22</title>
    <link href="http://www.roczhang.com/20180722.html"/>
    <id>http://www.roczhang.com/20180722.html</id>
    <published>2018-07-22T14:44:37.000Z</published>
    <updated>2018-07-22T16:22:43.039Z</updated>
    
    <content type="html"><![CDATA[<p>昨天听闻台风要登录上海，凌晨一直难以入眠。后来隐约间听到窗外风雨夹杂，已记不清是清醒还是睡着。早晨起床看到楼下院子里满是树叶，明明是个盛夏的日子却有摸得到的秋日凄凉。 </p>
<p>近期自己的状态一直不太好。突然感觉自己的心绪好像这满地落叶一样凌乱，甚至不知该从何处开始收拾。 </p>
<a id="more"></a>
<p>上周签了厚厚的一叠劳动合同，这也是我第一个没有暑假的夏天。上周五度过了自己 22 岁生日，天，高中之后我就没再收到过生日礼物，时隔多年收到了多份同事和测试小姐姐们送的礼物。晚饭后回到家里躺在床上，想到自己现在就 22 岁了，一段回过头就能仔细看得清的时间段里，经历了些许挫败的事情，无由头的联想起自己之前被不信任，甚至是被嘲讽的经历，突然就开始止不住的流眼泪。我从没感觉自己有变成熟，却感到自己其实越来越不成熟，越来越脆弱，越来越多愁善感。</p>
<p>和师傅聊了几次。师傅说他感觉我是个很内向的人，能感觉到的有很多想法和情绪也不会表露出来，只是搞笑一下就带过了。我之前从来都觉得自己是和内向无关的人，但现在发现自己积压的情绪越来越多却无处释放，已经很久没有和谁表达过自己情绪的时候，才发现师傅说的可能真的是对的。 </p>
<p>总结自己是一个极其残忍的过程。似乎大部分时间里都总是在否定自己，不管当时还有没有剩什么你肯定的事情。 </p>
<p>我也本就不认为自己是个内心强大的人。自己之前以为似乎已经努力弥补了的地方被证明并没有，自己之前以为做的有所作用的事也被证明并没有。因为之前自己的坚信本就不强烈，我便忍不住的开始怀疑是不是自己的想法与方式有问题，是不是该做出调整。看到之前的“但行好事，莫问前程”已经可以让我怀疑自己所做的算不算的上是“好事”了。 </p>
<p>昨夜翻看相册，一直看到大二大三那个暑假实习工作时的照片，一张公司大门的照片时间就定格在 2016 年 7 月 23 号。天，真的就已经过去两年了。还记得当时初次在学校以外的团队中工作，总是时不时会有“如果能和这群人永远一起工作该多好”的感叹。后来也发生过好多次相识后又离别的故事，以为是已经接受了本没有不散之宴，离别才是常态的事实，但身边真的有谈的来并在意的人又快要离开的时候，还是会忍不住非常非常难过。 </p>
<p>虽然是还没调整到足够好的状态，但手上和脑子上却没时间停下来。我还是想去国外读 master，始终有虽然已经读完了大学但相比起来还是没能学到什么真 Computer Science 的感觉。即便自问大学期间也没闲着，但还是浪费了不少时间在没有什么用处的事情上。但注定在只能自己供自己去读书的情况限定下，只能做 2 年以上的中长期打算了。我不是那类打算年龄大了之后以“写不动”转到其他职位上，或是准备回老家去做其他工作的人。既然这是我目前为止发现的自己最喜欢做的一类事之一，我还是希望自己能够在这条路上尽量往更远处去走吧。</p>
<p>公司的工作上最近在重构挺重的一部分代码。此外写了一个 Mac 上连接 iOS 设备的和 log 相关的工具 App，也在周会上给其他组的同事做了介绍展示。然后经过主动安利后看到自己的基础代码集 <code>RocFoundation</code> 里的一块代码首次出现在其他项目里（而不是我在的这个项目），有些奇特的感觉。 </p>
<p>个人项目这一块，在写一个小游戏，不出意外的话会是第四个应用了。Mr.Weather 2 只是停留在体验层的改进上会让我提不起太大的兴趣，我还是希望它能在面向需求层上有更进一步。虽然工作日的我基本上还是没有什么个人时间，但面对自己喜欢的事，就本不该有任何借口。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天听闻台风要登录上海，凌晨一直难以入眠。后来隐约间听到窗外风雨夹杂，已记不清是清醒还是睡着。早晨起床看到楼下院子里满是树叶，明明是个盛夏的日子却有摸得到的秋日凄凉。 &lt;/p&gt;
&lt;p&gt;近期自己的状态一直不太好。突然感觉自己的心绪好像这满地落叶一样凌乱，甚至不知该从何处开始收拾。 &lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.roczhang.com/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>跨越大四</title>
    <link href="http://www.roczhang.com/across-senior-year.html"/>
    <id>http://www.roczhang.com/across-senior-year.html</id>
    <published>2018-06-23T15:39:39.000Z</published>
    <updated>2018-06-23T17:48:24.225Z</updated>
    
    <content type="html"><![CDATA[<p>昨天早上学校的毕业典礼结束之后，我想自己终于算是程序上完全毕业了。<br>也终于到了可以写跨越大学最后一篇的时候，只是我对毕业这件事好像已经基本没剩什么感觉了。</p>
<a id="more"></a>
<p>去年六月离校，十月开始实习，四月完成论文返校答辩，上周完成双学位论文，到这周学校毕业典礼发毕业证学位证，只是因为自己还有很多事要做所以暂时还没法回学校。空间和身份上的转换对我而言似乎没有太大变化，唯一经历的不适感是因为个人可自由支配时间突然变少造成的不安。</p>
<p>还在学校的时候，有很多事情没曾想过也有很多事情没想明白。当时驱动自己的东西也很简单，或是真的喜爱，或是试图想要证明自己得到别人的认可与夸赞。离开学校之后虽也是一个人居住，但环境上开始时的生疏给了自己更多的时间能够把自己隔离开来了解和追问自己，从小问题到大问题。就如为什么要做每件事，为什么自己总在感到不安，我的能力有提升吗，为什么会经常对自己感到不满和自卑，什么对我来说才真的重要，我想追求的到底是什么。这些大大小小的问题关系着自己处理每一件事做每一个决定，还有晚上能否睡的着。技艺上的精进能够让我收获很单纯的开心，比如编程技术、设计水平或者是弹吉他，但这只是经历付出之后收到正向反馈的短期成就感，放到更短的时间长度之内可能和一盘游戏也并无差异，只是依然没有办法持久的缓解我对自己更长时间段上的焦虑。</p>
<p>幸运的是遇到了很多方面值得自己学习和引发自己思考的人（师傅），加之自己身边发生的事让我感受到之前觉得还离自己很远的事可能距离也没那么远。虽然很多问题的答案依然是想不明白，但有些问题阶段性的答案的的确确变得更清楚了，我也能感受到自己的心态在产生变化。见到了更多人的选择和生活方式，虽然不会再像以前一样啧啧称奇，但让我越发想去了解更多的人，看到更多的可能。</p>
<p>实习到现在已经八个月了，没有意外的话周一就会签入职合同正式入职了。回想起自己最近几年的生活依然会觉得非常神奇，总让我会想要感激每一次幸运的偶然，但也相信每一件事绝非只是偶然。站在以前的时间节点上我想不到现在的自己，这挺好也挺不好，但让我期待在以后的某一天，假想今天的我朝后面的我看过去，会更强烈的惊叹，这一切都太神奇了。</p>
<p>2018.06.22 - Ordinary graduation day, fantastic 4 years.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天早上学校的毕业典礼结束之后，我想自己终于算是程序上完全毕业了。&lt;br&gt;也终于到了可以写跨越大学最后一篇的时候，只是我对毕业这件事好像已经基本没剩什么感觉了。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.roczhang.com/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>WWDC18 Notes - Automatic Strong Passwords and Security Code AutoFill</title>
    <link href="http://www.roczhang.com/wwdc18-notes-automatic-strong-passwords.html"/>
    <id>http://www.roczhang.com/wwdc18-notes-automatic-strong-passwords.html</id>
    <published>2018-06-13T21:28:15.000Z</published>
    <updated>2018-06-13T23:17:52.369Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/videos/play/wwdc2018/204/" target="_blank" rel="external">WWDC18 - Session 204</a> 笔记 </p>
<p>在 iOS 12 中，Apple 将自动建议与使用强唯一密码的功能带入了 App 内，通过 QuickType bar 大幅简化了用户设置账户与登陆的繁琐操作。本 session 介绍了如何优化应用如何适配密码、安全码和其他自动填充功能，带给用户更安全与无缝的体验。</p>
<p><img src="https://www.roczhang.com/images/wwdc18-notes-automatic-strong-passwords/1.png" alt="cover"> </p>
<a id="more"></a>
<h2 id="Password-AutoFill-自动密码填充"><a href="#Password-AutoFill-自动密码填充" class="headerlink" title="Password AutoFill 自动密码填充"></a>Password AutoFill 自动密码填充</h2><p>在 iOS 11 中，Apple 引入了自动填充密码。此功能可以让用户通过点击键盘上方的 QuickType bar 快速完成用户名与密码输入过程。首先是对此功能的概要重述，重点包括：</p>
<ol>
<li>设置 Associated domains 关联域。iCloud Keychain Password Manager 中的密码是基于 Web 上的 domain 域（如 apple.com）来存储的。因此，就需要将 App 与 Web 上的域关联起来。关于 Password AutoFill 的详细功能，可见 <a href="https://developer.apple.com/videos/play/wwdc2017/206/" target="_blank" rel="external">WWDC 17 - Session 206 - Introducing Password AutoFill for Apps</a>。 </li>
<li>标记好 Content types。在 iOS 11 中，<code>UITextContentType</code> 中添加了新类型：<code>username</code> 及 <code>password</code>。只要给输入框设定好正确的 <code>textContentType</code> 即可。如：<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// For user name text field</span></div><div class="line"><span class="keyword">let</span> userTextField = <span class="type">UITextField</span>()</div><div class="line">userTextField.textContentType = .username</div><div class="line"></div><div class="line"><span class="comment">// For password text field</span></div><div class="line"><span class="keyword">let</span> passwordTextField = <span class="type">UITextField</span>() </div><div class="line">passwordTextField.textContentType = .password</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><ol>
<li>在 iOS 11.3 中，WKWebView 支持了自动填入密码，如果登录界面使用 Web 技术实现会很有帮助。</li>
<li>在 iOS 12 中，从 App Store 中下载的其他密码管理应用也可以提供信息实现自动输入功能。只要开发者适配了 iCloud Keychain Password Manager 的 AutoFill，其他第三方密码管理应用也同样能够得到支持。如果你在开发密码管理应用，可以浏览 <a href="https://developer.apple.com/videos/play/wwdc2018/721/" target="_blank" rel="external">WWDC 18 - Session 721 - Implementing AutoFill Credential Provider Extensions</a>。</li>
</ol>
<h3 id="Password-Saving-密码保存"><a href="#Password-Saving-密码保存" class="headerlink" title="Password Saving 密码保存"></a>Password Saving 密码保存</h3><p>在 iOS 12 中，Apple 提供了在 App 内新账户登录时保存密码凭证的功能。从而使得用户在所有设备上都能通过 iCloud Keychain 登录你的 App 或网站。保存密码的工作原理是：</p>
<ol>
<li>推断登陆场景；</li>
<li>基于关联 domain 检查资质；</li>
<li>查找用户名和密码字段；</li>
<li>检测登陆操作；</li>
<li>提示用户保存或更新密码。</li>
</ol>
<p>为确保兼容此功能，我们需要检查的事件有:</p>
<ol>
<li>为相关的输入框标记好 content type 内容类型；</li>
<li>当登录事件发生时，将用户名与密码输入框从 view hierarchy 中移除。这样 Autofill 便能够检测到登录事件正在进行。可以通过 dismiss 掉登录场景的 View Controller 实现；</li>
<li>确保值在上述移除工作完成之后再清除登录输入框中的内容，这样 Autofill 才能读到数据并将其保存；</li>
<li>检查 Autofill 保存的密码关联的是否为正确的 domain。可以通过保存后在设置界面中查看保存结果，如不正确，可通过 Web credentials associated domain service 覆盖其保存的位置。</li>
<li>如果之前手动通过 <code>SecAddSharedWebCredential()</code> 保存，现在可能不在需要使用它了.</li>
</ol>
<p>总结关键点在于：</p>
<ol>
<li>将 app 关联 domain；</li>
<li>为输入域做好标记；</li>
<li>确保登陆检测。</li>
</ol>
<h2 id="Automatic-Strong-Passwords-自动强密码"><a href="#Automatic-Strong-Passwords-自动强密码" class="headerlink" title="Automatic Strong Passwords 自动强密码"></a>Automatic Strong Passwords 自动强密码</h2><p>Automatic String Passwords 提供生成建议用户名、密码与保存功能，通过几次点击便可以完成注册，将注册过程变得更加容易与安全。<br><img src="https://www.roczhang.com/images/wwdc18-notes-automatic-strong-passwords/3.png" alt="automaticStrongPasswords"></p>
<p>Automatic Strong Passwords 的工作原理与上述的 Password Saving 工作原理大致相似：</p>
<ol>
<li>推断 View Controller 类型；</li>
<li>基于关联的 domians 检查资质；</li>
<li>检测相关的注册表单元素，如用户名输入框与密码输入框；</li>
<li>提供建议用户名；</li>
<li>键入强密码；</li>
<li>用户注册后保存。</li>
</ol>
<p>对此功能的兼容性检查表也与上述的 Password Saving 类似。<br>为配合此功能，在 iOS 12 中，<code>UITextContentType</code> 新增了 <code>.newPassword</code> 类型，我们需要标记好自己 App 中的新密码输入框与密码确认输入框为 .newPassword。</p>
<h3 id="对修改密码表单的注意事项："><a href="#对修改密码表单的注意事项：" class="headerlink" title="对修改密码表单的注意事项："></a>对修改密码表单的注意事项：</h3><ol>
<li>用户名与新密码文本框应该在同一屏上；</li>
<li>用户名文本框可以是只读的；</li>
<li>在注册中的最佳实践同样适用于此。</li>
</ol>
<h3 id="默认生成密码的格式"><a href="#默认生成密码的格式" class="headerlink" title="默认生成密码的格式"></a>默认生成密码的格式</h3><ol>
<li>长度为20个字符；</li>
<li>包括大字母、小写字幕、数字与连字符；</li>
<li>超过 71 位的熵；</li>
<li>设计上旨在与大多数服务兼容。</li>
</ol>
<p>自动生成的密码例子：<code>funrus-Hommez-kajzp7</code>。</p>
<p>当然，考虑到不同的后端规则，也可以自定义自动生成强密码的格式。可以通过密码规则语言来定义规则，如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> newPasswordTextField = <span class="type">UITextField</span>()</div><div class="line">...</div><div class="line"><span class="keyword">let</span> rulesDescriptor = <span class="string">"allowed: upper, lower, digit; required: [$];"</span> newPasswordTextField.passwordRules = <span class="type">UITextInputPasswordRules</span>(descriptor: rulesDescriptor)</div></pre></td></tr></table></figure></p>
<p>还可以使用新的密码规则验证工具 - <a href="https://developer.apple.com/password-rules/" target="_blank" rel="external">Password Rules Validation Tool</a>。</p>
<h2 id="Security-Code-AutoFill-验证码自动填充"><a href="#Security-Code-AutoFill-验证码自动填充" class="headerlink" title="Security Code AutoFill 验证码自动填充"></a>Security Code AutoFill 验证码自动填充</h2><p>对于 iOS 12 之前用户来说，收到短信验证码都需要人肉记忆，再手动输入到文本框中。iOS 12 与 macOS Mojave 中终于带来了自动输入验证码功能。同样在 <code>UITextContentType</code> 中新增了一种 <code>.oneTimeCode</code> 的类型。但由于依赖系统键盘 QuickType 输入，所以对于哪些取代系统键盘使用自定义界面输入验证码的场景无法使用。同时，在所以已支持的语言环境中都可用。验证码自动填充功能同样能够在 Safari Web 页面中使用。非常棒的一点是如果用户尝试在 Mac 上通过 Safari 登录，iPhone 上收到的验证码信息将会被自动安全的传递到 Mac 上，以实现在 Mac 上同样能够轻点一下自动填充验证码。</p>
<p>此次自动输入的功能在 Safari 中同样有效，具体属性符对应如下： </p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>iOS 12 (UITextContentType)</th>
<th>Safari (input autocomplete=”value”)</th>
</tr>
</thead>
<tbody>
<tr>
<td>UserName</td>
<td>.username</td>
<td>username</td>
</tr>
<tr>
<td>Existing Password</td>
<td>.password</td>
<td>current-password</td>
</tr>
<tr>
<td>New Password (for Automatic Strong Passwords)</td>
<td>.newPassword</td>
<td>new-password</td>
</tr>
<tr>
<td>One Time Code (for Security Code AutoFill)</td>
<td>.oneTimeCode</td>
<td>one-time-code</td>
</tr>
</tbody>
</table>
<h2 id="Federated-authentication-联合身份验证"><a href="#Federated-authentication-联合身份验证" class="headerlink" title="Federated authentication 联合身份验证"></a>Federated authentication 联合身份验证</h2><p>对于要支持使用第三方服务（如社交媒体账号）登录的情况，iOS 12 中引入了新的 API: <code>ASWebAuthenticationSession</code>。联合身份验证过程如下图所示：<br><img src="https://www.roczhang.com/images/wwdc18-notes-automatic-strong-passwords/2.png" alt="federatedAuthentication"><br>使用 ASWebAuthenticationSession 的好处在于：更快的登陆流程、支持密码自动输入与验证码自动输入以及简单明了的基于 block 形式的 API。具体用法如下所示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> AuthenticationServices</div><div class="line"><span class="keyword">guard</span> <span class="keyword">let</span> oauthURL = <span class="type">URL</span>(string: <span class="string">"https://www.example.com/oauth/..."</span>) <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">self</span>.authenticationSession = <span class="type">ASWebAuthenticationSession</span>(url: oauthURL, callbackURLScheme:</div><div class="line"><span class="literal">nil</span>) &#123; (callbackURL, error) <span class="keyword">in</span></div><div class="line"><span class="keyword">guard</span> error == <span class="literal">nil</span>, <span class="keyword">let</span> callbackURL = callbackURL <span class="keyword">else</span> &#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Process error.</span></div><div class="line"><span class="keyword">return</span></div><div class="line"><span class="comment">// Process token.</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">self</span>.authenticationSession.start()</div></pre></td></tr></table></figure></p>
<h2 id="New-password-management-features-密码管理新功能"><a href="#New-password-management-features-密码管理新功能" class="headerlink" title="New password management features 密码管理新功能"></a>New password management features 密码管理新功能</h2><p>iCloud Keychain Password Manager 中带了了一些与密码管理有关的新功能。如：通过询问 Siri 密码自动跳转到密码查看页以快速查看、密码内容支持通过 AirDrop 分享给他人、iOS 12 与 macOS Mojave 中的密码查看列表界面也经过了重新的设计、以及对在多个网站中使用相同密码的情况给予用户警告、tvOS 应用可以通过附近的 iOS 设备完成自动密码输入。</p>
<h2 id="Summary-总结"><a href="#Summary-总结" class="headerlink" title="Summary 总结"></a>Summary 总结</h2><p>在 iOS 12 与 macOS Mojave 中提供的这些密码相关功能非常强大，尽管许多功能可能能够自动适配工作，我们仍需要测试自己的 app 来保证良好兼容。<br>同时，联想到近两天再次频繁爆出的国内大网站被脱裤的消息，开发者对安全问题都应该更加重视。适配 Automatic Strong Passwords 相比其他 feature 来说适配工作量并不会非常多，但能够非常明显的提升用户操作的连贯体验与安全性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2018/204/&quot;&gt;WWDC18 - Session 204&lt;/a&gt; 笔记 &lt;/p&gt;
&lt;p&gt;在 iOS 12 中，Apple 将自动建议与使用强唯一密码的功能带入了 App 内，通过 QuickType bar 大幅简化了用户设置账户与登陆的繁琐操作。本 session 介绍了如何优化应用如何适配密码、安全码和其他自动填充功能，带给用户更安全与无缝的体验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.roczhang.com/images/wwdc18-notes-automatic-strong-passwords/1.png&quot; alt=&quot;cover&quot;&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>WWDC18 Notes - What&#39;s New in Cocoa Touch</title>
    <link href="http://www.roczhang.com/wwdc18-notes-what-is-new-in-cocoa-touch.html"/>
    <id>http://www.roczhang.com/wwdc18-notes-what-is-new-in-cocoa-touch.html</id>
    <published>2018-06-11T23:30:13.000Z</published>
    <updated>2018-06-13T21:43:36.388Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/videos/play/wwdc2018/202/" target="_blank" rel="external">WWDC18 - Session 202</a> 笔记<br><a id="more"></a></p>
<p>在 iOS 12 中，Apple 进一步增强了 Cocoa Touch 框架，着重提高了应用的性能表现，同时也带来了不少新功能。在 What’s New in Cocoa Touch 中，对性能上的最佳实践、安全改进、多尺寸与形状屏幕的适配工具、用于 iMessage Apps 的新 API、Siri Shortcuts 以及 Swift 优化等方面进行了概括介绍。</p>
<h2 id="Framework-Updates"><a href="#Framework-Updates" class="headerlink" title="Framework Updates"></a>Framework Updates</h2><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>此 Session 中主要通过 Scrolling、Memory 以及 Auto Layout 三个方面介绍了 iOS 12 中的性能改进。</p>
<h4 id="Scrolling"><a href="#Scrolling" class="headerlink" title="Scrolling"></a>Scrolling</h4><p>首先通过 UITableView 举例，介绍 UIKit 中滑动加载的常见流程：</p>
<ul>
<li>在 <code>UITableViewDataSource</code> <code>cellForRowAt</code> 方法中，重用或新初始一个 cell。</li>
<li>使用模型数据中的内容来填充此 cell 。</li>
<li>系统在 cell 上调用 <code>layoutSubviews</code> 方法，对 cell 中的内容进行布局。</li>
<li>系统在 cell 上调用 <code>draw</code> 方法。</li>
</ul>
<p>以上所有这些事务都必须在一次刷新间隔中完成，才能够保证流畅的滚动不掉帧。在 120 Hz 的 iPad Pro 上，间隔时间更短，所以需要尽可能快速的完成这些工作。在 iOS 10 中，UIKit 引入了 <code>UITableViewDataSourcePrefetching Protocol</code> 预加载，实现 <code>prefetchRowsAt</code> 方法之后，就能够提前在后台进行数据准备工作以提升性能表现，但加载当前 cell与预加载将来要显示的数据会同时发生。而在 iOS 12 中，将预加载工作放在了加载 cell 完成之后进行，如下图所示。<br><img src="https://www.roczhang.com/images/wwdc18-notes-what-is-new-in-cocoa-touch/1.png" alt="Markdown preferences pane"><br>同时，在先前的版本中，从简单开销小的内容滑动到复杂开销大的内容时，由于 CPU 性能调度器进行调度需要时间，因此可能会造成卡顿。而在 iOS 12 中，会更加智能的进行 CPU 调度，由上层 UIKit 通知 CPU 准备调度，预先估算在 deadline 之前需要多少 CPU 性能来满足需求，进一步提升滑动流畅度。这些改进都无需开发者做额外的适配工作即可获得性能提升，但开发者仍应尽可能控制并减少开销时间。 </p>
<h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><p>关注内存的原因在于 Memory Is Performance。当应用发出较大的内存请求而处于 Free 状态的内存不够时，系统就需要从其他 App 与系统使用的内存中挪出部分试图满足需求。但腾出其他 App 占用的内存并不代表对自己的 App 没有影响，内核需要做很多工作花费 CPU 时间来准备出需要的内存，因此需要花费时间进行等待。减少内存占用有很多方法，但 iOS 12 中带来了一项新技术 - Automatic Backing Store。根据图像中的信息自动减少色彩位深度以减少内存占用。<br><img src="https://www.roczhang.com/images/wwdc18-notes-what-is-new-in-cocoa-touch/2.png" alt="Markdown preferences pane"><br>在 iOS 12 中，<code>UIView.draw()</code>、<code>UIGraphicsImageRenderer</code>以及<code>UIGraphicsImageRendererFormat.Range</code>会默认启用。在 <a href="https://developer.apple.com/videos/play/wwdc2018/219/" target="_blank" rel="external">Session 219 - Image and Graphics Best Practices</a> 中，Apple 详细介绍了 Automatic Backing Store 的内容。</p>
<h4 id="Auto-Layout"><a href="#Auto-Layout" class="headerlink" title="Auto Layout"></a>Auto Layout</h4><p>在 iOS 12 中，Auto Layout 有了巨大的变化，在默认情况下都会变得更快。在处理较基础的独立同层视图布局约束时，在原先随视图数量计算耗时线性增长的基础上进一步减小了耗时。而在计算相互依赖的同层视图布局约束、嵌套的视图布局约束时，iOS 12 将原先随视图数量计算耗时指数级增长优化至了线性增长。如下图所示：<br><img src="https://www.roczhang.com/images/wwdc18-notes-what-is-new-in-cocoa-touch/3.png" alt="Markdown preferences pane"><br>在 <a href="https://developer.apple.com/videos/play/wwdc2018/220/" target="_blank" rel="external">Session 220 - High Performance Auto Layout</a> 中对此做了更详细的介绍。</p>
<h3 id="Swiftification"><a href="#Swiftification" class="headerlink" title="Swiftification"></a>Swiftification</h3><p>在 Swift 4.2 中，让 UIKit 进一步 Swift 化，通过嵌套 Types/Constants/Functions，让 Swift 味更浓，用起来感觉更自然。如下：  </p>
<ul>
<li>Nested Constants:<ol>
<li>将 <code>enum UIApplicationState</code> 嵌套至了 <code>class UIApplication</code> 中。</li>
<li>将 <code>enum UITabBarItemPositioning</code> 嵌套至了 <code>class UITabBar</code> 中。</li>
</ol>
</li>
<li>Nested Constants:<ol>
<li>将 <code>NSNotification/Name/didChangeStatusBarOrientation</code>、全局常量 <code>UIApplicationStatusBarOrientationUserInfoKey</code> 移至了 <code>class UIApplication</code> 中。</li>
<li>将 <code>UIFloatRangeZero</code>、<code>UIFloatRangeInfinite</code> 移至了 <code>struct UIFloatRange</code> 中。</li>
</ol>
</li>
<li>Nested Functions:<ol>
<li><code>UIEdgeInsetsInsetRect(originalRect, insets)</code> -&gt; <code>originalRect.insetBy(insets)</code>。</li>
<li><code>UIImagePNGRepresentation(image)</code> -&gt; <code>image.pngData()</code>。</li>
<li>Codable Type 支持: <code>NSStringFrom[CGPoint, CGRect, CGSize, CGVector, CGAffineTransform, UIEdgeInsets, UIOffset] / [CGPoint, CGRect, CGSize, CGVector, CGAffineTransform, UIEdgeInsets, UIOffset]FromString</code> -&gt; <code>JSONEncoder().encode(CGPoint(x: 0, y: 0)) / JSONDecoder().decode(CGPoint.self, from: encoded) / NSCoder.string(for: CGPoint(x: 0, y: 0)) / NSCoder.cgPoint(for: encoded)</code>。</li>
</ol>
</li>
</ul>
<h3 id="NSSecureCoding"><a href="#NSSecureCoding" class="headerlink" title="NSSecureCoding"></a>NSSecureCoding</h3><p>新增默认安全编码与解码，老的 API 现在为 <code>deprecated</code>。<br>关于此部分，详细可见 <a href="https://developer.apple.com/videos/play/wwdc2018/222/" target="_blank" rel="external">Session 222 - Data You Can Trust</a>。</p>
<h2 id="API-Enhancements"><a href="#API-Enhancements" class="headerlink" title="API Enhancements"></a>API Enhancements</h2><h3 id="Notifications"><a href="#Notifications" class="headerlink" title="Notifications"></a>Notifications</h3><p>iOS 12 中对消息通知也做出了较大的改进，主要体现在以下三方面：</p>
<ul>
<li>Interaction<br>自定义的通知界面中，允许添加使用自定义的交互，而不在限定于预先定义的动作。</li>
<li>Grouping<br>分组通知。默认即会使用分组通知，将同一个 App 的通知集合到一个组中。同时也可以设定自己 App 通知消息分组的规则。</li>
<li>Settings<br>在 iOS 12 中，可以在通知页让用户设置是否开启或关闭消息推送。<br>关于通知部分的详情，可见 <a href="https://developer.apple.com/videos/play/wwdc2018/710/" target="_blank" rel="external">Session 710 - What’s New in User Notifications</a> 与 <a href="https://developer.apple.com/videos/play/wwdc2018/711/" target="_blank" rel="external">Session 711 - Using Grouped Notifications</a>。</li>
</ul>
<h3 id="Messages"><a href="#Messages" class="headerlink" title="Messages"></a>Messages</h3><p>在 iOS 12 中，可以将 Message 贴纸置入到 Camera 中。在 Info.plist 中可添加新的 key：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;key&gt;<span class="type">MSSupportedPresentationContexts</span>&lt;/key&gt;</div><div class="line">&lt;array&gt;</div><div class="line">&lt;string&gt;<span class="type">MSMessagesAppPresentationContextMessages</span>&lt;/string&gt;</div><div class="line">&lt;string&gt;<span class="type">MSMessagesAppPresentationContextMedia</span>&lt;/string&gt;</div><div class="line">&lt;/array&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Automatic-Passwords-and-Security-Code-AutoFill"><a href="#Automatic-Passwords-and-Security-Code-AutoFill" class="headerlink" title="Automatic Passwords and Security Code AutoFill"></a>Automatic Passwords and Security Code AutoFill</h3><p>在 iOS 11 中，引入了自动输入密码功能，可以在 App 内快速输入已在 iCloud Keychain 中存储的密码。在 iOS 12 中，此功能做了进一步的改进，可以在 App 内保存密码到 iCloud Keychain，同时也可以在 App 给使用自动生成强密码功能。并且，如果应用后端对密码的格式有要求，也可以指定这些要求从而保证自动生成的密码符合规则。同时，iOS 12 中也带来了自动从信息中提取验证码，一键输入的功能。<br>关于自动密码与验证码输入详情，可见 <a href="https://developer.apple.com/videos/play/wwdc2018/204/" target="_blank" rel="external">Session 204 - Automatic Strong Passwords and Security Code AutoFill</a>。</p>
<h3 id="Safe-Area"><a href="#Safe-Area" class="headerlink" title="Safe Area"></a>Safe Area</h3><p>通过适配 SafeAreaInsets 来适配不同形状、大小与内容布局格式的界面。主讲人呼吁开发者尽快适配 SafeArea。详细可见 <a href="https://developer.apple.com/videos/play/wwdc2018/235/" target="_blank" rel="external">Session 235 - UIKit: Apps for Every Size and Shape</a>。</p>
<h2 id="Siri-shortcuts"><a href="#Siri-shortcuts" class="headerlink" title="Siri shortcuts"></a>Siri shortcuts</h2><p>Siri shortcuts 是 iOS 12 中带来的新功能。给 App 提供了在 Siri Suggestion 中展示信息、在 Apple Watch Siri 表盘中展示信息，定义出发 Siri shortcuts 语言关键词等能力。可以通过以下 API 来适配 Siri shortcut。</p>
<h3 id="NSUserActivity"><a href="#NSUserActivity" class="headerlink" title="NSUserActivity"></a>NSUserActivity</h3><p>与 Handoff 和 Spotlight 通用的 API。适合要在 App 中打开某些具体内容的情况。为 UserActivity 设置 <code>eligibleForPrediction = true</code>。</p>
<h3 id="Intents"><a href="#Intents" class="headerlink" title="Intents"></a>Intents</h3><p>提供最佳 shortcut 体验需要适配 intents，可以提供无需启动 app 即可运行、提供自定义的语音响应、自定义用户界面、定义预测场景等能力。<br>关于 Siri Shortcut 详情可见 <a href="https://developer.apple.com/videos/play/wwdc2018/211/" target="_blank" rel="external">Session 211 - Introduction to Siri Shortcuts</a> / <a href="https://developer.apple.com/videos/play/wwdc2018/214/" target="_blank" rel="external">Session 214 - Building for Voice with Siri Shortcuts</a> / <a href="https://developer.apple.com/videos/play/wwdc2018/217/" target="_blank" rel="external">Session 217 - Siri Shortcuts on the Siri Watch Face</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2018/202/&quot;&gt;WWDC18 - Session 202&lt;/a&gt; 笔记&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>App Architecture 笔记 - 2</title>
    <link href="http://www.roczhang.com/app-architecture-notes-2.html"/>
    <id>http://www.roczhang.com/app-architecture-notes-2.html</id>
    <published>2018-05-30T12:10:41.000Z</published>
    <updated>2018-06-05T22:02:18.147Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.objc.io/books/app-architecture/" target="_blank" rel="external">App Architecture</a> 读书笔记<br>第二章 Overview of Application Design Patterns<br><a id="more"></a></p>
<p>第一篇：<a href="https://www.roczhang.com/app-architecture-notes-1.html">App Architecture 笔记 - 1 Introduction</a><br>第二篇：<a href="https://www.roczhang.com/app-architecture-notes-2.html">App Architecture 笔记 - 2 Overview, MVC/MVVM-C</a></p>
<h2 id="Model-View-Controller"><a href="#Model-View-Controller" class="headerlink" title="Model-View-Controller"></a>Model-View-Controller</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><ul>
<li>少数的 controller 对象负责处理所有 model 层与 view 层之外的任务，包括：<ol>
<li>收集所有 view actions</li>
<li>处理所有交互逻辑</li>
<li>分发 model actions</li>
<li>收集所有 model notifications</li>
<li>准备所有用于展示的数据</li>
<li>将变更应用到视图 </li>
</ol>
</li>
<li>依赖：<ol>
<li>view / model 不在代码中直接引用 controller</li>
<li>controller 实例知道 view / model 的接口以及连接对象</li>
</ol>
</li>
</ul>
<h3 id="5-Tasks"><a href="#5-Tasks" class="headerlink" title="5 Tasks"></a>5 Tasks</h3><ul>
<li>Construction:<ol>
<li>构建顶层 view controllers -&gt; 加载与配置 view，及要展示的 model 数据</li>
<li>controllers 创建并持有模型层，或使用懒加载的单例访问模型</li>
<li>与视图有关的模型对象缓存在控制器中 </li>
</ol>
</li>
<li>Updating the Model:<ol>
<li>MVC 中 controller 通常使用 target/action、delegate 等方式来接收 view events</li>
<li>当 view events 到来时，控制器改变期内部的状态、更改模型或直接改变视图层级结构 </li>
</ol>
</li>
<li>Chaning the View:<ol>
<li>控制器订阅 model notifications，当 model notifications 到达时，controller 去改变视图层级结构，以使数据能够单向流动 </li>
</ol>
</li>
<li>View State:<ol>
<li>View State 按需被存在 view 或 controller 中</li>
<li>影响 view 或 contrller 状态的 view action 不要求通过 model 传递 </li>
</ol>
</li>
<li>Testing:<ol>
<li>MVC 中，由于 controllers 与其他组件间需紧密结合，缺乏边界，导致很难编写单元/接口测试</li>
<li>集成测试可行。在测试中构建 view/model/controller 间的连接部分，测试逻辑与组件间的连接 </li>
</ol>
</li>
</ul>
<h3 id="Importance-of-Model-View-Controller"><a href="#Importance-of-Model-View-Controller" class="headerlink" title="Importance of Model-View-Controller"></a>Importance of Model-View-Controller</h3><ul>
<li>系统中默认的设计模式</li>
<li>MVC 的相对自由是的多种变体模式都能被整合进其中</li>
<li>历史：<ol>
<li>MVC 首次被用在 1979 年，Smalltalk-76 中。</li>
<li>原始公式中，视图直接被附给 model 对象，控制器仅用于捕获事件与转发给对象</li>
<li>原始 Smalltalk 对 MVC 实现中，持续下来的理念是 view 层与 model 层应当分离  </li>
</ol>
</li>
</ul>
<p><br></p>
<h2 id="Model-View-ViewModel-Coordinator"><a href="#Model-View-ViewModel-Coordinator" class="headerlink" title="Model-View-ViewModel+Coordinator"></a>Model-View-ViewModel+Coordinator</h2><h3 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h3><ul>
<li>与 MVC 相同，都围绕一个 scene（视图层级结构中的一个子视图场景）来构建</li>
<li>每个 scene 使用一个 view-model 来描述场景中展示与交互的逻辑用于描述 view 上要展示值的属性，这些值从底层模型中经过一系列转化得来，可被直接用于视图</li>
<li>通过绑定确保发生变化后视图可及时展示</li>
<li>响应式是用于表达这种类型与转换的工具，天然适合 MVVM</li>
<li>对 view 层级没有直接引用使得 view-model能脱离框架方便测试</li>
<li>MVVM-C 中，使用 coordinator 协调器来负责场景间转换的逻辑。coordinator 持有对模型层的引用，并了解视图控制器树，因此它可为每个场景提供其所需要的 model 对象与 view-model</li>
<li>与 MVC 不同，MVVM-C 中试图控制器间不直接引用其他控制器，而是通知 coordinator 有关的 view actions，让 coordinator 来展示新 VC 与设置模型数据，相当于用 coordinator 来管理 tree</li>
<li>View Controller 不再有内部的 view state，而将其移动到 view-model 中，使得 VC 原始的双重身份（A，作为视图层级结构的一部分 / B，调解 view 与 model 间交互）减少到单层（单纯作为视图层级结构一部分），同时，coordinator 负责了 VC 的另一个工作，展示出其他 VC</li>
</ul>
<h3 id="5-Tasks-1"><a href="#5-Tasks-1" class="headerlink" title="5 Tasks"></a>5 Tasks</h3><ul>
<li>Construction:<ol>
<li>单独的模型对象，交由 view-model 持有而不再是 view controllers</li>
<li>与 MVC 不同，VC 不再直接获取或准备数据，而是在构建时创建 view-model，并将 view 绑定到 view-model 暴露出的相关属性上</li>
</ol>
</li>
<li>Updating the Model:<ol>
<li>与 MVC 不同，当 view event 到达后，VC 不改变其内部状态，而是调用 view-model 上的方法，由 view-model 改变其内部状态或模型</li>
</ol>
</li>
<li>Chaning the View:<ol>
<li>与 MVC 不同为，VC 不观察模型，view-model 观察模型，并将 model notifications 进行转化</li>
<li>VC 观察 view-model（通常通过响应式），当 view-model 事件到来，VC 改变其视图层级结构</li>
</ol>
</li>
<li>View State:<ol>
<li>视图状态在 view 中或 view-model 中</li>
<li>与 MVC 不同，VC 中不含任何 view state，controller 观察 view-model 的 view state 变化 </li>
</ol>
</li>
<li>Testing:<ol>
<li>由于 view-model 与 view 层和 controller 层解耦，view-model 可进行接口测试而不是 MVC 中的集成测试</li>
<li>为使接口测试尽可能多的覆盖，VC 需要尽量保持简洁</li>
</ol>
</li>
</ul>
<h3 id="Importance-of-Model-View-Controller-1"><a href="#Importance-of-Model-View-Controller-1" class="headerlink" title="Importance of Model-View-Controller"></a>Importance of Model-View-Controller</h3><ul>
<li>MVVM 与 MVC 最大区别在于使用响应式将 view-model 中的状态表达成一系列转换和依赖关系，清晰地描述出模型与要展示值之间的关系，可以让人更好的理解 app 中的依赖关系</li>
<li>使用 coordinator 来管理 VC 层级的概念非常重要。coordinator 不与 MVVM 直接绑定，因此也可以用在 MVC 等其他模式中</li>
<li>历史:<ol>
<li>MVVM 由 Ken Cooper 和 Ted Peters 指定（他们在微软参与开发 WPF）</li>
<li>WPF 中使用一种叫做 XAML 的基于 XML 的声明式语言来描述视图绑定到 view-model 上的属性</li>
<li>Cocoa 中没有 XAML，所以需要使用如 RxSwift 之类的框架来执行 view-model 与 view 间的绑定</li>
<li>iOS 中的 coordinator 概念由 Soroush Khanlou 2015 年在其网站上提出</li>
</ol>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.objc.io/books/app-architecture/&quot;&gt;App Architecture&lt;/a&gt; 读书笔记&lt;br&gt;第二章 Overview of Application Design Patterns&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>App Architecture 笔记 - 1</title>
    <link href="http://www.roczhang.com/app-architecture-notes-1.html"/>
    <id>http://www.roczhang.com/app-architecture-notes-1.html</id>
    <published>2018-05-20T03:21:35.000Z</published>
    <updated>2018-06-05T22:02:18.146Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.objc.io/books/app-architecture/" target="_blank" rel="external">App Architecture</a> 读书笔记<br>第一章 Introduction<br><a id="more"></a></p>
<h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><ul>
<li>此书会讨论五种设计模式:<ol>
<li>MVC: Model-View-Controller </li>
<li>MVVM-C: Model-View-ViewModel-Coordinator</li>
<li>MVC+VS: Model-View-Controller-ViewState</li>
<li>MAVB: ModelAdapter-ViewBinder</li>
<li>TEA: The Elm Architecture</li>
</ol>
</li>
<li>此书的 Demo 是一个 Recording App，在 GitHub 上。</li>
</ul>
<h2 id="Application-Architecture"><a href="#Application-Architecture" class="headerlink" title="Application Architecture"></a>Application Architecture</h2><ul>
<li>Application architecture 关注的方面包含：<ol>
<li>组件如何被构建；</li>
<li>事件流如何在层级中传递；</li>
<li>组件间是否应有编译期或运行期的相互引用；</li>
<li>不同的组件中数据应如何被读取或变更；</li>
<li>状态变更后应在整个应用结构中用怎样的路径来处理。</li>
</ol>
</li>
</ul>
<h2 id="Model-and-View"><a href="#Model-and-View" class="headerlink" title="Model and View"></a>Model and View</h2><ul>
<li>分类层 Categories Layer:<ol>
<li>应用架构在最高层上看，是把不同的应用组件分离到不同的分类层中;</li>
<li>一个分类层便是一个包含代码和接口的集合，他们都能够遵循一定的规则并且职责相似;</li>
<li>最常见的分类层就是模型层与视图层。</li>
</ol>
</li>
<li>模型层 Model Layer:<ol>
<li>对应用内容的抽象；</li>
<li>不依赖于任何应用框架；</li>
<li>通常包含模型对象对协调对象。</li>
</ol>
</li>
<li>视图层 View Layer:<ol>
<li>依赖于应用框架；</li>
<li>将模型层可视化，可交互化；</li>
<li>通常直接使用 UIKit（也可能使用 SceneKit / OpenGL 等）。</li>
</ol>
</li>
<li>Why Are the Categories of Model and View Considered So Fundamental?<ol>
<li>保持模型层整洁，及不受应用框架底层实现的影响；</li>
<li>方便讲模型层运用到当前应用之外，如运行测试、用不同的框架重写视图层、移植到其他系统平台等。</li>
</ol>
</li>
</ul>
<h2 id="Applications-Are-a-Feedback-Loop"><a href="#Applications-Are-a-Feedback-Loop" class="headerlink" title="Applications Are a Feedback Loop"></a>Applications Are a Feedback Loop</h2><ul>
<li>应用设计模式的挑战在于如何处理如试图层与模型层之间的通信、依赖与转换。</li>
<li>View Action: 由视图触发，用于响应用户驱动的事件。发送给 Model Layer 时，View Action 可能会被转换成 Model Action，这种转换被叫做 Interaction Logic。</li>
<li>Model Update: 模型对象更新后通常会产生一个通知，此通知将触发视图层的更新。通知可以使用多种形式，如 Foundation Notification、Delegates、Callback 等。这种由 Model Notification 转换到视图的变化被称为 Presentation Logic。</li>
<li>当所有状态都放在模型层中，并且所有变化都遵循上述的完整反馈路径环时，被称为单向数据流。</li>
</ul>
<h2 id="Architectural-Technologies"><a href="#Architectural-Technologies" class="headerlink" title="Architectural Technologies"></a>Architectural Technologies</h2><ul>
<li>实现架构的工具技术:<ol>
<li>Notification 广播：单个源的变化 -&gt; 0到多个监听者；</li>
<li>KVO：将一个对象上属性的变化告知给另一个对象；</li>
<li>响应式：重点在于关注从源到目标间的转换，允许将逻辑运用到转换中。</li>
</ol>
</li>
<li>双向绑定:<ol>
<li>Cocoa Bindings 是双向绑定。被观察者同时也是观察者，会建立反向连接；</li>
<li>本书仅讨论单向绑定。</li>
</ol>
</li>
</ul>
<h2 id="Application-Tasks"><a href="#Application-Tasks" class="headerlink" title="Application Tasks"></a>Application Tasks</h2><ul>
<li>五类任务：<ol>
<li>构建：谁来构建模型与视图，谁来连接；</li>
<li>更新：如何处理 View Actions；</li>
<li>改变视图：如何将模型数据应用到视图上；</li>
<li>视图状态：如何处理 Navigation 与其他非模型状态；</li>
<li>测试：使用怎样的测试策略来达到合理的测试覆盖率。</li>
</ol>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.objc.io/books/app-architecture/&quot;&gt;App Architecture&lt;/a&gt; 读书笔记&lt;br&gt;第一章 Introduction&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>Go For WWDC18 - 1</title>
    <link href="http://www.roczhang.com/go-for-wwdc18-1.html"/>
    <id>http://www.roczhang.com/go-for-wwdc18-1.html</id>
    <published>2018-05-17T14:35:15.000Z</published>
    <updated>2018-06-05T22:02:18.147Z</updated>
    
    <content type="html"><![CDATA[<p>准备篇：签证与行程</p>
<a id="more"></a>
<p><img src="http://www.roczhang.com/images/go-for-wwdc18-1/1.jpg" alt="Markdown preferences pane"></p>
<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>四月还在学校完成毕业答辩时接到公司电话，得知有可以去 WWDC 的机会。而后面非常幸运的，我的 scholarship 没有中。一番纠结之后还是决定 – 去吧！</p>
<p>今年 WWDC 的时间在 6 月 4 日 ～ 8 日，离程序上最后毕业的时间也不远。所以也可以把第一次参加 WWDC 当作自己的毕业旅行，后面想起来应该会很有趣。</p>
<h3 id="签证"><a href="#签证" class="headerlink" title="签证"></a>签证</h3><p>决定之后就开始准备办理各类手续。由于之前已经办好了护照，所以当务之急就是办理签证。办签证前后需要准备的手续还是挺多的，最重要的应该就是填写 DS-160 表了。填表需要上传白底彩色特定大小的照片，因此没有的话需要去照相并索取电子档。表中的要填的内容很多，并且很多时候填表网站的速度不是很稳定，所以填写完成需要挺长一段时间。完成提交之后便需要交办理签证的费用，使用中信银行在线缴费即可。缴费完成之后便可以预约去大使馆面签的时间，一般似乎可以预约到 1～2 周之后的时间。在这段时间里就可以准备各类面签用的文件。网站说明指出面签时需要携带护照/DS-160 确认页/缴费预约确认单，以及其他支持性文件。  </p>
<p>由于之前在群里看到拒签似乎并不是少见的事，所以自己准备了很多材料。先后找 Apple 申请 VISA LETTER 的 HARD COPY，让家里帮忙复印了一些证件与证明，又摆脱了学校的好友找学校老师开具了在读证明、成绩单等证明，之后找公司开了实习证明、介绍信、三方、Offer 纸质版，最后又准备了机票确认单，英文简历，去招行打印了半年的流水。我的面试约在了两周后，Apple 的 VISA LETTER 大概在申请的一周后寄到了手上。之后便带着厚厚的一沓文件去面签了。 </p>
<p>由于之前了解到面签不能带电子设备等等，而自己又不想去寄存包裹，于是当天中午我就把手机之类都留在了公司，带着文件袋直接坐到南京西路站。本非常自信的以为出了站一定能够马上通过排队的人群找到地点，但事实是完全找不到。虽然距离地铁站不远，但只是摸到梅陇镇广场就先后问了几次路人，最后又绕了一圈才找到排队的地方。中午外面排队的人并不多，所以直接看了预约确认领了牌，就直接上了8楼。楼上在等待办理的人还是很多，采集了指纹之后排队等了很久。采集指纹和面谈的办公人员都是外国人。排队时正看到前面在面试的人先后出示了很多文件，最后还是被退回护照的场景。 </p>
<p>我的面试对话大概如下：</p>
<ul>
<li>VO: 去美国的目的？</li>
<li>ME: 参加 WWDC 开发者大会。</li>
<li>VO: 有邀请函吗？</li>
<li>ME: 有的。（递上邀请函）</li>
<li>VO: 为什么要去？</li>
<li>ME: 了解最新的技术，和其他开发者交流。</li>
<li>VO: ZHENG HAO TIAN 是谁？</li>
<li>ME: 我的同行人，他也是开发者。</li>
<li>VO: What will they have in this conference?（突然变成英文）</li>
<li>ME: They will have some sessions about the latest iOS, macOS technologies.</li>
<li>VO: OK. (沉默打字了一小段时间)</li>
<li>VO: Have a nice trip.</li>
<li>ME: (不确定)我通过了吗？</li>
<li>VO: Yeah, Yeah, 通过了。</li>
</ul>
<p>面试全程大概五分钟。 </p>
<p>虽然自己并没有被要求查看其他的材料，但并不后悔准备这些材料，因为一旦需要某些材料没有准备，往往还要花费比准备材料更多的精力弥补。 </p>
<p>面试完成之后查询了签证的状态，一开始是 Administrative Processing。在网上搜索了一下再次被吓到，各种条目说 AP 代表行政审查，可能会花费数周甚至数月的时间进行审核。后来才知道似乎所有的签证面签后都会经历 AP 的过程，代表正常的行程处理流程，只有 AP 时间非常长时才有可能是遇到了额外审核。状态变更到 issued 之后大概两天就拿到了寄过来的护照。之后还需要的一步便是在 EVUS 上进行登记。</p>
<h3 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h3><p>原本准备租用 WiFi 的我们考虑到在当地游览时应该会经常使用 Uber 所以可能需要接听司机电话，还是决定买电话卡。稍微查看了一下（<a href="https://www.whistleout.com/CellPhones/Guides/Best-Cell-Phone-Plans-and-Carriers-in-San-Jose" target="_blank" rel="external">比如这篇文章</a>)，在 San Jose 应该 AT&amp;T 的信号比较好，于是决定购买短期 AT&amp;T 无限制电话卡。行程上定了 6 月 2 号从上海飞到 Los Angeles，再由 Los Angeles 到 San Jose 的航班。住所也提前在 Airbnb 上做好了预定。除去还需要兑换少量现金应该也不用在其他方面做特别准备了。 </p>
<p>想起这个去年 WWDC 时和各位一起讨论的 Telegram Group：<a href="https://t.me/joinchat/CVYFGkPXZUzr3MkgoFbMOg" target="_blank" rel="external">Mr.Weather Friends</a>，希望今年还可以和大家一起聊天！ </p>
<p>离出发还剩 15 天！非常期待第一次 WWDC 之旅了！ </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;准备篇：签证与行程&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.roczhang.com/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>2018.04.18</title>
    <link href="http://www.roczhang.com/20180418.html"/>
    <id>http://www.roczhang.com/20180418.html</id>
    <published>2018-04-18T13:05:15.000Z</published>
    <updated>2018-06-05T22:02:18.145Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.roczhang.com/images/20180418/01.jpg" alt="Markdown preferences pane"></p>
<p>临近毕业了。一期一会，世当珍惜。 </p>
<a id="more"></a>
<p>‘I thought of all of the time passing by.’ - No One But You</p>
<iframe src="https://open.spotify.com/embed/track/4ae9ASpdH2cpz3aX1TJvsA" width="100%" height="80" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe>


<h3 id="Updates"><a href="#Updates" class="headerlink" title="Updates"></a>Updates</h3><p>上周匆匆忙忙完成了毕业设计和论文，写的是一个最简单的 TensorFlow 模型训练然后应用到 iOS 的 App 里。周五回了学校，答辩还算顺利，后续应该只用提交二次查重再打印成册就完成了。但还有一篇双学位的论文没有写，有些头疼。六月领毕业证，所以理论上还剩最后两个月的学生身份。 </p>
<p>4 月初提交了 Swift Playground 申请 WWDC Scholarship。实际上今年比去年还没有信心，但毕竟这是最后一次机会了，不再试一次总感觉自己以后会后悔。今年总是感觉比去年穷很多，实习工资加上卖 App 的收入基本每个月还是没有结余。如果 Scholarship 没抽中，公司有一个去 WWDC 的机会，但由于目前自己依然是实习生的身份所以不能完全报销。自己是非常想去，然而 3 万块对我现在都是 unaffordable 的状态，实在是有点纠结和伤感了。 </p>
<p>从去年 10 月来流利说到现在不知不觉就已经半年过去了。公司两周一版本的迭代节奏还是挺快的，但和同事相处的都挺愉快，自己的个人生活节奏也比去年稳定了很多。回顾自己技术有进步，但日常工作外的整理和输出还是太少了。</p>
<p>买了 Spotify Premium 之后发现自己近期听歌的口味有变化，居然开始喜欢 Stayin’ Alive 这类复古的 Disco 了… 最近看了黑豹和头号玩家，黑豹除了感觉衣服挺骚气没觉得很好看。但头号玩家看了第一遍之后没忍住又去看了一遍 IMAX 版本。看完之后总会有一种从盛大的梦境中醒来的感觉，上一次看你的名字时也有这种感觉。如果说只有少年才是有梦的那这种梦就是想象力吧。Silicon Valley S5 开播了，E4 里借 Jian Yang 黑中国互联网加上最后的 BGM 实在是黑的太妙了。</p>
<h3 id="Apps"><a href="#Apps" class="headerlink" title="Apps"></a>Apps</h3><p><a href="https://itunes.apple.com/cn/app/adonis/id1281626299?l=en&amp;mt=8" target="_blank" rel="external">Adonis</a> 上架到现在大概卖了几千份，并不算好。我也看到了 Adonis 上存在的一些问题，只能逐渐演进。 </p>
<p><a href="https://itunes.apple.com/cn/app/mr-weather/id1198461086?l=en&amp;mt=8" target="_blank" rel="external">Mr.Weather</a> 去年 5 月份上架，到现在已经有几万的用户，而且虽然很久没有更新，每天还是有挺稳定的增长。我觉得 Mr.Weather 上还有一些想做但没实现的，所以几个月前开始设计 Mr.Weather 2，开发进度比较慢，但争取在今年 5 月 Mr.Weather 上架一周年的时候发布新版本。想了想可能会使用年订阅的方式。剧透一下 Mr.Weather 2: </p>
<p><img src="http://www.roczhang.com/images/20180418/02.png" alt="Markdown preferences pane"></p>
<p><a href="https://itunes.apple.com/cn/app/year-timer/id1359786804?l=en&amp;mt=8" target="_blank" rel="external">Year Timer</a> 属于写着好玩的类型吧，本身只花了半天的开发时间，上架之后也没有做任何宣传什么，只是满足个人的一个小需求。</p>
<p>至此就有三个已经上架的个人 App 了。之前建了一个 <a href="https://join.slack.com/t/roczhang/shared_invite/enQtMjgwMDQ5NjM5NDg4LWIxMTQzNmU1NmZkZmUxMDY0Y2ZhYjE4ZDI5M2ZiYTkxMjVmM2E5ZTkyYWNhMTVmMTg2ZjFhNzU0MTY4YzRhZjA" target="_blank" rel="external">Slack Group</a>，三个 app 在 group 里都有独立的 channel。我无法肯定这些 App 本身的价值，但这是我个人想法的延伸与表达的方式。所以我觉得那些抄袭别人作品的实在没有任何意义，抄袭别人的自我表达反而代表着自己没有任何想法。</p>
<h3 id="Thoughts"><a href="#Thoughts" class="headerlink" title="Thoughts"></a>Thoughts</h3><p>回学校的时候和同学与朋友聊了挺多，基本是交换自己的现状，对离开学校有不舍和感伤。我当然也是有一些，但再次去往几处之前去过的地方，便发现自己怀念的并不是单纯的地点或人，只是怀念自己之前的这一段经历罢了。也发现对之前发生的让自己曾感到不爽的事情没有那么在意了，并没有什么必要去感到伤感或愤怒，关注自己收获到了什么就好。但还是提醒自己珍惜每一段经历，虽然有“要珍惜”这种念头本身就影响了全身心投入，而不算是纯粹的珍惜了。</p>
<p>感觉自己是一个挺矛盾的人。看不清未来的时候会很焦虑，看到未来可能没有变化的时候也会很焦虑。平常很少有可以倾诉个人想法的对象，因此独处会是自己绝大多数的处境。虽然这在大多数情况下不会是什么问题，但总会有想要倾诉分享的时候。所以只能观察自己，反思自己在矛盾中的选择。 </p>
<p>发现自己还有一个 Telegram 的 Channel，之前是为了 Mr.Weather 建立的，但显然当时还没有了解 Telegram Channel 的运作方式，所以后来 Mr.Weather 就迁移到 Group 和 Slack 上去了。但 Channel 这种只能广播无法回复的方式确实挺好的，所以把 Channel 改了名，会不定期分享自己的开发和境遇。欢迎关注：<a href="https://t.me/roczhangchannel" target="_blank" rel="external">https://t.me/roczhangchannel</a> 。</p>
<p>今天看到 Kevin 的博客，离开了多点去了青岛，实在非常钦佩。Kevin 哥很多时候给我了精神上的鼓舞，祝福 Kevin！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.roczhang.com/images/20180418/01.jpg&quot; alt=&quot;Markdown preferences pane&quot;&gt;&lt;/p&gt;
&lt;p&gt;临近毕业了。一期一会，世当珍惜。 &lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.roczhang.com/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>翻译：iOS Code Signing (一)、（二）</title>
    <link href="http://www.roczhang.com/%E7%BF%BB%E8%AF%91%EF%BC%9AiOS%20Code%20Signing%20(%E4%B8%80)%E3%80%81%EF%BC%88%E4%BA%8C%EF%BC%89.html"/>
    <id>http://www.roczhang.com/翻译：iOS Code Signing (一)、（二）.html</id>
    <published>2018-03-03T02:16:03.000Z</published>
    <updated>2018-06-05T22:02:18.149Z</updated>
    
    <content type="html"><![CDATA[<p>翻译来自 iOS Code Signing 系列第一、二篇。<br>原作者：SHASHIKANT JAGTAP<br>翻译者：Roc Zhang<br><a id="more"></a><br>如有任何问题还请留言指出。  </p>
<p>E-mail: roczhang9673@gmail.com<br>Weibo: @张鹏roczhang<br>Twitter: @Lighters9673</p>
<hr>
<h1 id="Post-1-入门"><a href="#Post-1-入门" class="headerlink" title="Post 1: 入门"></a>Post 1: 入门</h1><p>这是 iOS 代码签名教程系列的第一部分。此系列涵盖了 iOS 代码签名过程的基础知识，此系列的全部文章为：</p>
<ul>
<li>iOS Code Signing: 1. Getting Started  <a href="http://shashikantjagtap.net/ios-code-signing-1-getting-started/" target="_blank" rel="external">原文</a> <a href="http://www.roczhang.com/%E7%BF%BB%E8%AF%91%EF%BC%9AiOS%20Code%20Signing%20%28%E4%B8%80%29%E3%80%81%EF%BC%88%E4%BA%8C%EF%BC%89.html">译文</a></li>
<li>iOS Code Signing: 2. Certificate Signing Requests  <a href="http://shashikantjagtap.net/ios-code-signing-2-certificate-signing-requests/" target="_blank" rel="external">原文</a> <a href="http://www.roczhang.com/%E7%BF%BB%E8%AF%91%EF%BC%9AiOS%20Code%20Signing%20%28%E4%B8%80%29%E3%80%81%EF%BC%88%E4%BA%8C%EF%BC%89.html">译文</a></li>
<li>iOS Code Signing: 3. Certificates  <a href="http://shashikantjagtap.net/ios-code-signing-3-certificates/" target="_blank" rel="external">原文</a></li>
<li>iOS Code Signing: 4. Provisioning Profiles  <a href="http://shashikantjagtap.net/ios-code-signing-4-provisioning-profiles/" target="_blank" rel="external">原文</a></li>
<li>iOS Code Signing: 5. Signing iOS App  <a href="http://shashikantjagtap.net/ios-code-signing-5-signing-ios-app/" target="_blank" rel="external">原文</a></li>
</ul>
<p>通常，iOS 设备仅能够运行被信任的开发者所签名的 app，除非是对设备进行了越狱。如果你是一个 iOS 工程师，你肯定和代码签名在某些方面打过交道。由于代码签名是每个 iOS 开发者都无法逃避且最让人痛苦和繁琐的工作之一，除非开发者能够完全理解关于代码签名的基础知识，否则代码签名和 Provisioning Profile 将会成为一个一直伴随你的烦恼。这是一篇入门介绍文章，阐述了代码签名的过程及其优点与局限。</p>
<h2 id="关于此系列"><a href="#关于此系列" class="headerlink" title="关于此系列"></a>关于此系列</h2><p>iOS 应用的代码签名对每一个 iOS 开发者来说都是热门话题。尽管网络上已经有很多资源存在，并且 Apple 也给出了清晰的文档，但它看起来仍然像一个谜。在这个系列中，我们将尝试从头开始去理解代码签名，包括代码签名需要什么，以及代码签名自身的处理过程。我们同样会探讨如何使用 GUI 与命令行去实现。我们将从 Certificate Signing Request 开始得到一个 iOS 开发证书，之后我们将聊到证书和其内部组成部分。在理解证书之后，我们将会深入到 Provisioning Profiles，最后我们将能够理解代码签名的整个过程。<br>这个系列的文章是我自己通过研究网上的资料与 Apple 的文档所写出的，我已将这些引用材料列在了最后一篇文章中。同样我也附带了一些来自 Apple Developer 网站与 Xcode 的截图，以便于读者能够理解这些概念。我已经试图隐藏了所以的敏感内容，但如果依然有被不小心暴露出来的，还请不要黑我 🙂。</p>
<h2 id="代码签名"><a href="#代码签名" class="headerlink" title="代码签名"></a>代码签名</h2><p>在我们开始了解 Apple 对 iOS 应用所进行的代码签名方式之前，先让我们大体上探讨一下代码签名。在现实生活中，我们会在各种不同的合同、协议上签名。那么为什么要进行签名？为什么签名对我们而言如此重要？通常这是因为签署合同能在法律上保护我们，并且我们相信合同上的任何条款都不会被篡改。签名同样还能确保合同来自受信任的机构而非诈骗者以确保安全。这就意味着签合同能够带给我们安全、保障与信赖。</p>
<p>同样，代码签名是指对代码进行数字签名，以确保谁编写了代码及代码在签名时没有发生更改或损坏。代码签名使用加密哈希算法来验证软件代码的真实性与完整性。在软件的世界里，代码签名确保了作者的身份、代码的完整、构建系统与版本，使得软件的用户在使用时能感到可靠与安全。代码签名使用了多种安全项如私钥、公钥、证书、数字签名等。不同的代码签名方法会被用在如 Linux、Windows 、macOS 等不同的平台上。</p>
<h2 id="iOS-代码签名"><a href="#iOS-代码签名" class="headerlink" title="iOS 代码签名"></a>iOS 代码签名</h2><p>Apple 据说有着十分强大的安全机制，除去一些你最近可能在新闻中看到的小毛病。对黑客来说很难打破这种安全机制。Apple 同样也使用了非常强大的代码签名机制以保证从 Apple App Store 下载的 iOS App 的安全性与完整性。大多情况下，iOS 的代码签名就好像是发生在幕后的黑魔法。如果它工作良好，每个人都会很开心，然而一旦出现问题则会让每个人都陷入恐慌。大多数 iOS 工程师对这幕后的签名过程都不甚了解。最近 Apple 发布了 ‘Automatic Signing (自动签名)’ 功能以帮助减少代码签名所带来的痛苦，不让代码签名打断主要开发流程。Apple 平台上的代码签名依赖于 X.509 标准的公钥加密，我们稍后将在此系列中讨论这些工具和技术。</p>
<h2 id="为什么要学习-iOS-代码签名"><a href="#为什么要学习-iOS-代码签名" class="headerlink" title="为什么要学习 iOS 代码签名"></a>为什么要学习 iOS 代码签名</h2><p>现如今代码签名的大多数工作都由 Xcode 处理，那么为什么我们应该关心代码签名以及为什么要投入时间去了解它？</p>
<p>这里是一些为什么要学习代码签名内部原理的原因：</p>
<ul>
<li>iOS 工程师直接从安装在本地机器上的 Xcode 部署 iOS 应用的日子已经一去不复返了。现如今的公司正使用 DevOps 和 CI/CD 来构建软件，以便于所以构建工作都能够在无需人力或与 GUI 交互的情况下自动完成。</li>
<li>开发人员因 Xcode 代码签名失败，试图通过重新生成与修复证书和配置文件来修复代码签名问题上耗费了大量的时间。<br>第三方工具如 Fastlane 可以让 iOS 开发者更加轻松地创建 build 脚本。然而，当 Apple 在底层技术上作出更改，Fastlane 将无法使用，开发人员会花费数小时、数天甚至数周时间来修复损坏的部署脚本。在某些情况下，工程师们必须等到 Fastlane 实现了新更改。</li>
<li>如果你是一个 iOS 开发人员或工程师，并只是想一直做一个 iOS 工程师，那么你没有必要去学习这些知识。但如果你想要在你的职业生涯中成长，那么你就必须要详细了解这些底层工具、技术和整个 iOS 生态。如果你不了解这些底层技术，不管你在 iOS 开发技术上有多出色，都无法让你成为一个 iOS 技术主管或一个 iOS 技术架构师之类的角色。作为一个技术架构师，你应该能够在不依赖于 Xcode 或其他第三方工具的情况下快速修复代码签名或类似的基础架构问题。</li>
</ul>
<p>希望这能足以证明代码签名的重要性。要学习还是离开取决于你。</p>
<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>让我们进入 iOS 代码签名的世界。我们将从头开始涵盖全部所需与其在底层所做的事。开始前我们需要以下准备：</p>
<ul>
<li>macOS</li>
<li>Apple Developer Membership</li>
<li>Xcode 9+</li>
</ul>
<p>所有这些你都准备好后，就可以开始深入了解 iOS 代码签名了。</p>
<h2 id="代码签名的好处"><a href="#代码签名的好处" class="headerlink" title="代码签名的好处"></a>代码签名的好处</h2><p>Apple 之所以要我们经历繁琐的代码签名流程是因为这对用户有一定的益处。当用户从 Apple App Store 上下载 app 时他们能感到安全，是因为代码签名保证了：</p>
<ul>
<li>合法的开发者编写了这些代码，且具有 app 作者或签发者的身份</li>
<li>代码签名保证了代码在作者编写之后没有被其他人篡改过。它保证了作者生成的代码是原始的，并且在作者签名之后没有任何其他东西被注入到原始代码中。</li>
<li>用户能够从他们信赖的开发人员那里下载应用，而不必担心太多安全问题。</li>
<li>代码签名是为了保证 iOS 用户的安全，以让他们使用从 AppStore 下载的应用时感到可信赖。</li>
</ul>
<h2 id="代码签名的局限"><a href="#代码签名的局限" class="headerlink" title="代码签名的局限"></a>代码签名的局限</h2><p>尽管代码签名是为了用户的安全，但在有些方面并不总能解决安全问题。</p>
<ul>
<li>代码签名保证了代码来自 Apple 开发者计划成员认证的合法开发者，但不能保证代码本身没有安全漏洞。</li>
<li>代码签名不能保证在 App 运行期间动态加载的插件是安全的。</li>
<li>对已签名的代码没有数字版权管理或拷贝保护技术。</li>
</ul>
<p>现在，我们已经了解了学习代码签名的重要性，以及代码签名的好处和局限。在下一篇文章里，我们将会了解重要概念：代码签名过程是如何开始的，即 Certificate Signing Requests 证书签名请求。</p>
<hr>
<h1 id="Post-2-证书签名请求"><a href="#Post-2-证书签名请求" class="headerlink" title="Post 2: 证书签名请求"></a>Post 2: 证书签名请求</h1><p>在上一篇文章中，我们已经说到了代码签名的基础知识，它所带来的好处及局限。现在我们将开始了解一些代码签名的概念。让我们先从所有代码签名起始的地方—-证书签名请求开始。也许你已经知道我们需要一个 development （开发）和一个 distribution （发布）证书来把一个 app 构建和部署到 AppStore。创建一个 iOS 开发证书是每一个 iOS 开发者都需要做的第一步。创建证书的过程从证书签名请求开始。在这片文章中，我们将会涵盖证书签名请求的概念（Certificate Signing Request，CSR）及使用 CSR 来请求证书的过程。</p>
<h2 id="什么是-CSR"><a href="#什么是-CSR" class="headerlink" title="什么是 CSR"></a>什么是 CSR</h2><p>代码签名请求 CSR 是一个由申请人向证书颁发机构发送的用于申请数字身份证书的消息。它使用了 <a href="https://en.wikipedia.org/wiki/Public_key_infrastructure" target="_blank" rel="external">Public Key Infrastructure</a> 公钥基础设施，是一种用于创建、管理与分发数字证书的策略。创建 CSR 的过程在 PKI 中非常规范化，申请人需要在本地机器上生成公钥和私钥，之后申请人需要将公钥与个人信息如邮箱、县等附在 CSR 中。申请人持有私钥。CSR 需要的典型信息包括：CN（通用名称）、组织、组织单位、国家、邮箱。CSR 包含了证书请求信息、签名算法和请求者的数字签名，以防止请求伪造证书。</p>
<h2 id="将-CSR-发送给-Apple"><a href="#将-CSR-发送给-Apple" class="headerlink" title="将 CSR 发送给 Apple"></a>将 CSR 发送给 Apple</h2><p>Certificate Signing Request（CSR）指的是从证书机构（CA）申请证书的过程，这里的证书机构就是 Apple，以便 Apple 能够在请求者详细信息正确的情况下发放开发者证书。请求需要从本地 macOS 机器上创建。</p>
<h2 id="从-GUI-创建-CSR"><a href="#从-GUI-创建-CSR" class="headerlink" title="从 GUI 创建 CSR"></a>从 GUI 创建 CSR</h2><p>CSR 可以通过 Keychain Access 来创建，Apple 编写了一些<a href="https://support.apple.com/kb/PH20128?locale=en_US" target="_blank" rel="external">文档</a>，但总结起来你需要做的是：</p>
<ul>
<li>在 Spotlight（聚焦搜索）中找到 Keychain Access（钥匙串访问）</li>
<li>选择 Keychain Access（钥匙串访问） &gt; Certificate Assistant（证书助理） &gt; Request a Certificate From a Certificate Authority（从证书颁发机构请求证书）</li>
<li>填写你的详细信息，如邮箱、姓名和国家，通常跟随屏幕上的指示就好</li>
<li>选中选项 “Saved to disk（保存到磁盘）”</li>
<li>指定一个文件名，点击保存</li>
<li>点击继续，之后证书助理会创建一个 CSR 并将其保存在你的电脑上</li>
</ul>
<h2 id="从命令行创建-CSR"><a href="#从命令行创建-CSR" class="headerlink" title="从命令行创建 CSR"></a>从命令行创建 CSR</h2><p>如果觉得用 GUI 麻烦，同样也有使用命令行创建 CSR 的方法。你可以通过运行几个快捷命令来拿到  CSR，只要将你的名字、邮箱与国家填写上去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ openssl genrsa -out mykey.key 2048</div><div class="line">$ openssl req -new -key mykey.key -out CertificateSigningRequest.certSigningRequest -subj &quot;/emailAddress=yourAddress@example.com, CN=Your Name Dev Key, C=GB”</div></pre></td></tr></table></figure>
<p>在过程结束时，你就可以在本地 mac 上看到一个有着奇怪名字的文件：CertificateSigningRequest.certSigningRequest，这就是我们需要上传给 Apple Developer 用于生成开发与发布证书的文件。我们将在稍后介绍证书。</p>
<p>现在，我们的本地机器上就有了我们的 CSR。让我们来了解一下创建 CSR 时发生了些什么：</p>
<ul>
<li>在创建 CSR 时，公钥/私钥对被生成</li>
<li>公钥被附在你的 CSR 上</li>
<li>私钥被保存在你的本地机器中</li>
</ul>
<p>如果你想了解更多有关公钥/私钥的知识以及他们是如何运作的，你可以阅读 <a href="https://cryptography.io/en/latest/hazmat/primitives/asymmetric/" target="_blank" rel="external">Asymmetric Cryptography</a> 非对称加密，但大体上公钥用在公共环境，私钥是私人持有的，你不应该将它分享给任何人。</p>
<p>现在来看一下 CSR 内部有些什么。在你的终端中运行下面的命令，这将会把 CSR 内部的基本信息显示出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openssl asn1parse -i -in CertificateSigningRequest.certSigningRequest</div></pre></td></tr></table></figure>
<p>如果你想看到以文本方式显示 CSR，看到公钥算法 rsaEncryption 和签名算法 sha256WithRSAEncryption，你可以运行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openssl req -text -noout -in CertificateSigningRequest.certSigningRequest</div></pre></td></tr></table></figure>
<p>这个密钥对由 RSA(2048 bit) 生成，公钥附在 CSR 中，私钥被用于实际签名，所以我们必须保持私密。在多个 macOS 上生成 CSR 不是一个好主意，因为用一台 mac 生成的密钥对不能被呈现在另一台 mac 上。直到我们创建 P12 格式的证书之前，最好使用一台 mac 来生成 CSR。</p>
<p>现在，我们已经看到了如何通过钥匙串访问及使用命令行来创建 CSR，在下一篇文章中，我们将会了解 iOS 开发与发布所需证书的细节。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译来自 iOS Code Signing 系列第一、二篇。&lt;br&gt;原作者：SHASHIKANT JAGTAP&lt;br&gt;翻译者：Roc Zhang&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>翻译：Clean Swift iOS Architecture for Fixing Massive View Controller （二）</title>
    <link href="http://www.roczhang.com/%E7%BF%BB%E8%AF%91%EF%BC%9AClean%20Swift%20iOS%20Architecture%20for%20Fixing%20Massive%20View%20Controller%20%EF%BC%88%E4%BA%8C%EF%BC%89.html"/>
    <id>http://www.roczhang.com/翻译：Clean Swift iOS Architecture for Fixing Massive View Controller （二）.html</id>
    <published>2017-12-17T11:37:25.000Z</published>
    <updated>2018-06-05T22:02:18.149Z</updated>
    
    <content type="html"><![CDATA[<p>节选翻译来自 Clean Swift iOS Architecture for Fixing Massive View Controller 系列第二篇。<br>原作者：Raymond<br>翻译者：Roc Zhang<br><a id="more"></a><br>第一次尝试翻译，如有任何问题还请留言指出。  </p>
<p>E-mail: roczhang9673@gmail.com<br>Weibo: @张鹏roczhang<br>Twitter: @Lighters9673</p>
<hr>
<p>本文接<a href="http://www.roczhang.com/%E7%BF%BB%E8%AF%91%EF%BC%9AClean%20Swift%20iOS%20Architecture%20for%20Fixing%20Massive%20View%20Controller%20%EF%BC%88%E4%B8%80%EF%BC%89.html">Clean Swift iOS Architecture for Fixing Massive View Controller 翻译系列第一篇</a>继续。</p>
<h2 id="2-Interactor"><a href="#2-Interactor" class="headerlink" title="2.Interactor"></a>2.Interactor</h2><p>Interactor 包括了你 App 中的业务逻辑。用户在 UI 上点击与滑动是为了和你的 App 进行交互。ViewController 从用户界面中收集用户的输入并将其传给 interactor，然后检索一些模型并要求一些 workers 来完成工作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CreateOrderInteractorInput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(request: CreateOrderRequest)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CreateOrderInteractorOutput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">presentSomething</span><span class="params">(response: CreateOrderResponse)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderInteractor</span>: <span class="title">CreateOrderInteractorInput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">var</span> output: <span class="type">CreateOrderInteractorOutput</span>!</div><div class="line">  <span class="keyword">var</span> worker: <span class="type">CreateOrderWorker</span>!</div><div class="line"></div><div class="line">  <span class="comment">// MARK: Business logic</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(request: CreateOrderRequest)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Create some Worker to do the work</span></div><div class="line"></div><div class="line">    worker = <span class="type">CreateOrderWorker</span>()</div><div class="line">    worker.doSomeWork()</div><div class="line"></div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Pass the result to the Presenter</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> response = <span class="type">CreateOrderResponse</span>()</div><div class="line">    output.presentSomething(response)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CreateOrderInteractorInput-和-CreateOrderInteractorOutput-协议"><a href="#CreateOrderInteractorInput-和-CreateOrderInteractorOutput-协议" class="headerlink" title="CreateOrderInteractorInput 和 CreateOrderInteractorOutput 协议"></a>CreateOrderInteractorInput 和 CreateOrderInteractorOutput 协议</h3><p><strong>CreateOrderInteractorInput</strong> 协议指定了 <strong>CreateOrderInteractor</strong> 组件的输入（它遵循这个协议），<strong>CreateOrderInteractorOutput</strong> 协议则指明了输出。</p>
<p>我们在 <strong>CreateOrderInteractorInput</strong> 协议中看到了与在 <strong>CreateOrderViewControllerOutput</strong> 协议中相同的 <code>doSomething()</code> 方法。<strong>CreateOrderViewController</strong> 的输出连接着 <strong>CreateOrderInteractor</strong> 的输入。</p>
<p><strong>CreateOrderInteractorOutput</strong> 协议包含一个 <code>presentSomething()</code> 方法，<strong>CreateOrderInteractor</strong> 的输出需要支持 <code>presentSomething()</code> 。提示：此处的 output 将是 <strong>VIP Cycle</strong> 中的 <strong>P</strong>。</p>
<p>这里另一件要注意的事情则是 <code>doSomething()</code> 方法的参数是 <strong>CreateOrderRequest</strong> 类型的请求对象，这和 <strong>CreateOrderViewControllerOutput</strong> 协议中的方法签名相同。Interactor 将在这个请求对象中检索出必要的数据来完成工作。<br>同样，<code>presentSomething()</code> 的参数是一个 <code>CreateOrderResponse</code> 类型的响应对象。</p>
<h3 id="output-与-worker-变量"><a href="#output-与-worker-变量" class="headerlink" title="output 与 worker 变量"></a>output 与 worker 变量</h3><p>output 变量是一个遵循 <strong>CreateOrderInteractorOutput</strong> 协议的对象，虽然我们知道这这里它将会成为 presenter，但同样，这也不是必须的。</p>
<p><strong>CreateOrderWorker</strong> 类型的 worker 变量是一个用于创建新订单的特定对象。由于创建订单可能会涉及到 Core Data 的持久化工作以及进行网络请求，这些工作如果全部由 interactor 来完成的话它所要做的任务就太多了。要记住，interactor 还需要去验证订单，这也同样可以被提取出来，成为 interactor 的 worker 来完成。</p>
<p>控制流</p>
<p>当 <strong>CreateOrderInteractor</strong> 的输入 (即 CreateOrderViewController) 调用 <code>doSomething()</code> 时，它将首先创建 worker 对象并通过调用 <code>doSomeWork()</code> 来要求 worker 去做一些工作。然后它将构造一个响应对象并调用输出的 <code>presentSomething()</code> 。</p>
<p>下面我们来快速的了解一下 worker。</p>
<h2 id="3-worker"><a href="#3-worker" class="headerlink" title="3.worker"></a>3.worker</h2><p>一个 Profile View 可能需要从 Core Data 中获取用户，下载照片，允许用户点赞与关注等。你不想让 interactor 陷入这些任务中不知所措，相反，我们可以将其拆解成许多的 workers，每个 worker 完成一件事，之后你还可以在其他地方复用 worker。</p>
<p><strong>CreateOrderWorker</strong> 非常简单，它仅仅提供了一个接口，并实现它可以对 interactor 完成的工作。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderWorker</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">// MARK: Business Logic</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doSomeWork</span><span class="params">()</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Do the work</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-Presenter"><a href="#4-Presenter" class="headerlink" title="4. Presenter"></a>4. Presenter</h2><p>在 interactor 产生出一些结果之后，它会将其传给 presenter，presenter 会将其组织成适合展示的 view model，然后将 view model 传回给 view controll 以展示给用户。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CreateOrderPresenterInput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">presentSomething</span><span class="params">(response: CreateOrderResponse)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CreateOrderPresenterOutput</span>: <span class="title">class</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">displaySomething</span><span class="params">(viewModel: CreateOrderViewModel)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderPresenter</span>: <span class="title">CreateOrderPresenterInput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> output: <span class="type">CreateOrderPresenterOutput</span>!</div><div class="line"></div><div class="line">  <span class="comment">// MARK: Presentation logic</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">presentSomething</span><span class="params">(response: CreateOrderResponse)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Format the response from the Interactor and pass the result back to the View Controller</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> viewModel = <span class="type">CreateOrderViewModel</span>()</div><div class="line">    output.displaySomething(viewModel)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CreateOrderPresenterInput-与-CreateOrderPresenterOutput-协议"><a href="#CreateOrderPresenterInput-与-CreateOrderPresenterOutput-协议" class="headerlink" title="CreateOrderPresenterInput 与 CreateOrderPresenterOutput 协议"></a>CreateOrderPresenterInput 与 CreateOrderPresenterOutput 协议</h3><p><strong>CreateOrderPresenterInput</strong> 协议指定了 <strong>CreateOrderPresenter</strong> 组件的输入，<strong>CreateOrderPresenterOutput</strong> 则指明输出。</p>
<p>现在，<code>presentSometing()</code> 和 <code>displaySomething()</code> 方法不再需要说明了。<strong>CreateOrderResponse</strong> 参数在 interactor 和 presenter 间的边界中传递，<strong>CreateOrderViewModel</strong> 在 presenter 和 view controller 间的边界中传递，VIP 环完成了。</p>
<h3 id="output-变量"><a href="#output-变量" class="headerlink" title="output 变量"></a>output 变量</h3><p>output 变量是一个遵循 <strong>CreateOrderPresenterOutput</strong> 协议的对象，尽管我们已经知道这里它就是 view controller，但同样它也可以不是。在这里一点细微的差别是，我们需要让 output 作为一个 weak 变量，当 <strong>CreateOrder</strong> 场景不被需要它的组件都要被 deallocate 的时候来避免循环引用。</p>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>当 <strong>CreateOrderInteractor</strong> 的输出被连接到 <strong>CreateOrderPresenter</strong> 的输入时，<code>presentSomthing()</code> 方法将在 interact 完成它的任务时被调用。它会构造 view model 对象，并在 output 上调用 <code>displaySomething()</code>。</p>
<p>之前我们说过会回过头来继续 view controller 中的 <code>displaySomething()</code> 方法，这是 VIP 环中的最后一步。它会将 view model 中任意的数据展示给用户。例如，我们也许想要在文本框中显示客户的姓名：<code>nameTextField.text = viewModel.name</code>。</p>
<p>恭喜！你刚刚学到了 Clean Swift 中的精华，你现在应该能够将业务与展示逻辑从你的用户界面代码中提取出来了。别担心，在介绍例子前我们不会就这样结束，但让我们先来说完 Clean Swift 中的其他组件。</p>
<h2 id="5-Router"><a href="#5-Router" class="headerlink" title="5. Router"></a>5. Router</h2><p>当用户点击 next 按钮导航到 storyboard 中的下一个场景时，一个 segue 将会被触发，一个新的 view controller 会被展示出来。Router 的作用就是将导航逻辑从 view controller 中提取出来，它同样是将数据传给下一个场景的最佳位置。最终的结果就是，view controller 中仅仅剩下控制各类视图的工作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CreateOrderRouterInput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">navigateToSomewhere</span><span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderRouter</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> viewController: <span class="type">CreateOrderViewController</span>!</div><div class="line"></div><div class="line">  <span class="comment">// MARK: Navigation</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">navigateToSomewhere</span><span class="params">()</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Teach the router how to navigate to another scene. Some examples follow:</span></div><div class="line"></div><div class="line">    <span class="comment">// 1. Trigger a storyboard segue</span></div><div class="line">    <span class="comment">// viewController.performSegueWithIdentifier("ShowSomewhereScene", sender: nil)</span></div><div class="line"></div><div class="line">    <span class="comment">// 2. Present another view controller programmatically</span></div><div class="line">    <span class="comment">// viewController.presentViewController(someWhereViewController, animated: true, completion: nil)</span></div><div class="line"></div><div class="line">    <span class="comment">// 3. Ask the navigation controller to push another view controller onto the stack</span></div><div class="line">    <span class="comment">// viewController.navigationController?.pushViewController(someWhereViewController, animated: true)</span></div><div class="line"></div><div class="line">    <span class="comment">// 4. Present a view controller from a different storyboard</span></div><div class="line">    <span class="comment">// let storyboard = UIStoryboard(name: "OtherThanMain", bundle: nil)</span></div><div class="line">    <span class="comment">// let someWhereViewController = storyboard.instantiateInitialViewController() as! SomeWhereViewController</span></div><div class="line">    <span class="comment">// viewController.navigationController?.pushViewController(someWhereViewController, animated: true)</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// MARK: Communication</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">passDataToNextScene</span><span class="params">(segue: UIStoryboardSegue)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Teach the router which scenes it can communicate with</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> segue.identifier == <span class="string">"ShowSomewhereScene"</span> &#123;</div><div class="line">      passDataToSomewhereScene(segue)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">passDataToSomewhereScene</span><span class="params">(segue: UIStoryboardSegue)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Teach the router how to pass data to the next scene</span></div><div class="line"></div><div class="line">    <span class="comment">// let someWhereViewController = segue.destinationViewController as! SomeWhereViewController</span></div><div class="line">    <span class="comment">// someWhereViewController.output.name = viewController.output.name</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CreateOrderRouterInput-协议"><a href="#CreateOrderRouterInput-协议" class="headerlink" title="CreateOrderRouterInput 协议"></a>CreateOrderRouterInput 协议</h3><p>CreateOrderRouterInput协议指明了它的各类路由：场景可以导航到的 view controller。<code>navigateToSomewhere()</code> 方法告诉了 view controller: 如果你把我当作你的 router，我得知道该如何导航到一个叫做 somewhere 的场景。</p>
<p>正如你在 <code>navigateToSomewhere()</code> 方法中的注释中看到的那样，router 在它可以导航的场景数量上非常灵活。我将会在另一篇文章中关于 router 的全部。</p>
<h3 id="viewController-变量"><a href="#viewController-变量" class="headerlink" title="viewController 变量"></a>viewController 变量</h3><p>viewController 变量仅仅只是一个指向使用此 router 的 viewController 的引用。它是一个 weak 变量来避免循环引用问题，它被一个 configurator 配置好（稍后你就会看到）。Apple 在 segue 间转场的方式是将所有的 present 和 push 方法都放到了 UIViewController 类中。所以在这里我们需要 view controller 引用以让我们能够在 router 中调用这些方法。</p>
<h3 id="passDataToNextScene-与-passDataToSomewhereScene"><a href="#passDataToNextScene-与-passDataToSomewhereScene" class="headerlink" title="passDataToNextScene() 与 passDataToSomewhereScene()"></a>passDataToNextScene() 与 passDataToSomewhereScene()</h3><p><code>passDataToNextScene()</code> 和 <code>passDataToSomewhereScene()</code> 方法提供了一种传递数据到下一个场景中去的方式。通常你会把同样的代码放到 <code>prepareForSegue()</code> 中。<code>passDataToNextScene()</code> 将试图匹配 segue ID 以分发到更具体的会传递实际的数据的 <code>passDataToSomewhereScene()</code> 方法。</p>
<h2 id="See-you-in-the-next"><a href="#See-you-in-the-next" class="headerlink" title="See you in the next"></a>See you in the next</h2><p>第二篇先翻译到这里，坚持每周翻译一部分吧😂，下周我们再接着 configurator 继续。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;节选翻译来自 Clean Swift iOS Architecture for Fixing Massive View Controller 系列第二篇。&lt;br&gt;原作者：Raymond&lt;br&gt;翻译者：Roc Zhang&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>翻译：Clean Swift iOS Architecture for Fixing Massive View Controller （一）</title>
    <link href="http://www.roczhang.com/%E7%BF%BB%E8%AF%91%EF%BC%9AClean%20Swift%20iOS%20Architecture%20for%20Fixing%20Massive%20View%20Controller%20%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>http://www.roczhang.com/翻译：Clean Swift iOS Architecture for Fixing Massive View Controller （一）.html</id>
    <published>2017-12-09T06:49:05.000Z</published>
    <updated>2018-06-05T22:02:18.148Z</updated>
    
    <content type="html"><![CDATA[<p>节选翻译来自 Clean Swift iOS Architecture for Fixing Massive View Controller 系列第一篇。<br>原作者：Raymond<br>翻译者：Roc Zhang<br><a id="more"></a><br>第一次尝试翻译，如有任何问题还请留言指出。  </p>
<p>E-mail: roczhang9673@gmail.com<br>Weibo: @张鹏roczhang<br>Twitter: @Lighters9673</p>
<hr>
<p>开始之前: 原作者提供了付费的 <a href="https://clean-swift.com/handbook" target="_blank" rel="external">The Clean Swift Handbook</a>，以及可以通过订阅他的 list 来下载 Clean Swift 的 Xcode 模版。示例代码在原文发布后有更新，因此文中所提及代码可能与你下载到的代码有所出入。   </p>
<h1 id="Clean-Swift-适用于-iOS-上的-Clean-架构"><a href="#Clean-Swift-适用于-iOS-上的-Clean-架构" class="headerlink" title="Clean Swift - 适用于 iOS 上的 Clean 架构"></a>Clean Swift - 适用于 iOS 上的 Clean 架构</h1><p>Clean Swift 架构起源于由 Uncle Bob 提出的 Clean 架构，他们之间有很多概念互通，例如 Components 组件，Boundaries 边界，以及 Models 模型。我将会实现一个由 Uncle Bob 谈过的“创建订单”用例。Uncle Bob 使用 Java 在 Web 应用程序中做了示范，我将会向你展示如何使用 Swift 将 Clean 架构应用到 iOS 项目中。</p>
<h2 id="“创建订单”-用例"><a href="#“创建订单”-用例" class="headerlink" title="“创建订单” 用例"></a>“创建订单” 用例</h2><p>这个用例由 Uncle Bob 在 <a href="https://skillsmatter.com/skillscasts/2437-uncle-bob-web-architecture" target="_blank" rel="external">Why can’t anyone get Web architecture right?</a> 中提出。它起源于 Ivar Jacobson 的 <a href="http://www.amazon.com/Object-Oriented-Software-Engineering-Approach/dp/0201544350" target="_blank" rel="external">Object Oriented Software Engineering</a> 一书。此用例包含了 Clean Swift 中除 routing 外的绝大多数特性，是一个非常好的例子。</p>
<p><strong>Data 数据:</strong><br>– Customer-id<br>– Customer-contact-info<br>– Shipment-destination<br>– Shipment-mechanism<br>– Payment-information  </p>
<p><strong>Primary Course:</strong><br>1.用上面的数据命令 clerk 发出“创建订单”命令。<br>2.系统验证所有数据。<br>3.系统创建订单并确定订单 ID。<br>4.系统将订单 ID 传达给 clerk。  </p>
<p><strong>Exception Course:</strong><br>Validation Error 验证错误，由系统将错误信息送达给 clerk。</p>
<p>我们将给这个用例中的数据建模到我们的模型层，并且创建特定的 request（请求）、response（响应）和 view models（视图模型）来在 view controller（视图控制器）、interactor（交互器）和 presenter （展示器）这些组件的边界中传递数据。</p>
<p>首先来看一下我们如何在 Xcode 项目中组织我们的代码。</p>
<h2 id="在-Xcode-中组织你的代码"><a href="#在-Xcode-中组织你的代码" class="headerlink" title="在 Xcode 中组织你的代码"></a>在 Xcode 中组织你的代码</h2><p>我们将创建一个新的 Xcode 项目，将其命名为 <strong>CleanStore</strong>。为了简单起见选择“Single View Application” 和 “仅 iPhone” 就行，并确定在语言中选择了 Swift。接下来，创建一个嵌套的子 Group: <strong>Scene -&gt; CreateOrder</strong>。当我们稍后开始实现删除订单的用例时，再创建一个新的子 Group 叫做 <strong>Scenes -&gt; DeleteOrder</strong>。</p>
<p>在一个典型的 Xcode 项目中，我们通常会见到文件被组织成 <strong>Model（模型）</strong>、<strong>View（视图）</strong>和 <strong>Controller（控制器）</strong> 三个组。每个 iOS 开发者都知道 MVC 架构，但让并没有告诉你任何关于项目更明确具体的信息。如 Uncle Bob 所指出，group（组）和 file names （文件命名）应当展现出你对此用例的意图，而不应该是反映底层框架结构。所以我们将在 Scene 下嵌套一个新的 group 来管理我们的每一个用例。</p>
<p>在 <strong>CreateOrder</strong> 组中，你可以预计到这里所有文件要做的事情都会和创建订单有关。同样的如果在 <strong>DeleteOrder</strong> 组下你将发现所有的代码都在处理关于删除订单的事务。如果你看到一个由其他开发者创建的新的 <strong>ViewOrderHistory</strong> 组，你就已经能预计到这是做什么的。<br>这种结构能够告诉你相比以往使用的 Model, View, Controller 分组来说的更多信息。长此以往，你累计了 15 个 models, 27 个 view controllers，和 17 个 views。它们是做什么的？在一一查看这些文件前，你大概会什么都不清楚。</p>
<p>也许你会问，那些被 <strong>CreateOrder</strong>, <strong>DeleteOrder</strong> 以及 <strong>ViewOrderHistory</strong> 所共用的类和协议该怎么办？实际上你可以将他们放到一个单独的组中，并取名为 <strong>Common -&gt; Order</strong>。为什么不简单明了一些呢？</p>
<p>回到我们的用例。</p>
<p>在 <strong>CreateOrder group</strong> 下面，我们将创建符合 Clean Swift 架构的组件。当我们继续完成用例时，我们将在这些组件的输入输出协议中添加方法，然后实现他们。</p>
<h2 id="VIP-循环"><a href="#VIP-循环" class="headerlink" title="VIP 循环"></a>VIP 循环</h2><p><img src="http://www.roczhang.com/images/cleanSwift/vipCycle.png" alt="Markdown preferences pane"><br>ViewController（视图控制器），interactor（交互器）和 presenter （展示器）是 Clean Swift 中的三个主要组件。他们彼此互相作为其他组件的输入和输出，正如下面的图表所展示：<br>视图控制器的输出连接着交互器的输入，交互器的输出连接着展示器的输入，展示器的输出连接着视图控制器的输入。我们将创建特定的对象来在这些组件的边界间传递数据。这能使我们把底层数据结构从组件中解耦。这些特定的对象仅由原始类型组成，如 Int, Double 和 String。我们可以创建结构体、类和枚举来重新表达数据，但在这些实体的内部应该仅包含原始类型。</p>
<p>这一点非常重要。因为一旦业务逻辑改变，底层的数据模型也需要改变。我们不需要去更新全部的代码。Components （组件）在 Clean Swift 中充当插件的角色。这就意味着我们可以将不同的组件交换使用，只要他们能够遵循 Input （输入）和 Output （输出）协议，应用仍然可以按照我们的预期正常工作。</p>
<p>一种典型的情况是这样的：用户点击了应用界面中的一个按钮，Tap Gesture 点击手势通过 IBActions 进入 ViewController 视图控制器，View Controller 构造一个请求对象并将其发送给 Interactor 交互器。Interactor 接受这个请求对象去执行一些任务，然后将执行结果放入 Response 响应对象中并将其发送给 Presenter 展示者。Presenter 将接收 Response 响应对象并格式化结果，然后将格式化的结果放到一个 ViewModel 视图模型对象中，并将其发回给 ViewController。最后，由 ViewController 将结果展示给用户。</p>
<h2 id="1-View-Controller"><a href="#1-View-Controller" class="headerlink" title="1.View Controller"></a>1.View Controller</h2><p>一个 ViewController 视图控制器应当在 iOS App 中承担着怎样的角色？基类 UITableViewController 应当可以给我们一些启示。我们想要使用代码来控制 UITableView 和 UIView 的子类，但这里的的控制代码应当是什么样？怎样的代码能有资格被称作控制代码而怎样的代码不能呢？</p>
<p>让我们深入来看。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CreateOrderViewControllerInput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">displaySomething</span><span class="params">(viewModel: CreateOrderViewModel)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CreateOrderViewControllerOutput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(request: CreateOrderRequest)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderViewController</span>: <span class="title">UITableViewController</span>, <span class="title">CreateOrderViewControllerInput</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">var</span> output: <span class="type">CreateOrderViewControllerOutput</span>!</div><div class="line">  <span class="keyword">var</span> router: <span class="type">CreateOrderRouter</span>!</div><div class="line"></div><div class="line">  <span class="comment">// MARK: Object lifecycle</span></div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">super</span>.awakeFromNib()</div><div class="line">    <span class="type">CreateOrderConfigurator</span>.sharedInstance.configure(<span class="keyword">self</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// MARK: View lifecycle</span></div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    doSomethingOnLoad()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// MARK: Event handling</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doSomethingOnLoad</span><span class="params">()</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Ask the Interactor to do some work</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> request = <span class="type">CreateOrderRequest</span>()</div><div class="line">    output.doSomething(request)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// MARK: Display logic</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">displaySomething</span><span class="params">(viewModel: CreateOrderViewModel)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Display the result from the Presenter</span></div><div class="line"></div><div class="line">    <span class="comment">// nameTextField.text = viewModel.name</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="CreateOrderViewControllerInput-和-CreateOrderViewControllerOutput-协议"><a href="#CreateOrderViewControllerInput-和-CreateOrderViewControllerOutput-协议" class="headerlink" title="CreateOrderViewControllerInput 和 CreateOrderViewControllerOutput 协议"></a>CreateOrderViewControllerInput 和 CreateOrderViewControllerOutput 协议</h2><p><code>CreateOrderViewControllerInput</code> 协议指明了 <code>CreateOrderViewController</code> 组件（它遵循这个协议）的输入。<code>CreateOrderViewControllerOutput</code> 协议指明了输出。稍后你将在 interactor 和 presenter 上看到相同的模式。</p>
<p>在 output 协议中有一个方法叫做 <code>doSomething()</code> ，如果有另一个组件想要成为 <code>CreateOrderViewController</code> 的输出，则需要在它的输入中支持 <code>doSomething()</code> 方法。</p>
<p>从之前你看到的 VIP 循环中，我们知道这个 output 是 interactor。但请注意在 <code>CreateOrderViewController.swift</code> 中，没有提及到 <code>CreateOrderInteratcor</code>，这就意味着我们可以将另一个组件替换成为 <code>CreateOrderViewController</code> 的输出，只要这个组件在他的 input 协议中支持 <code>doSomething()</code> 。<br><code>doSomething()</code> 方法中的参数是一个由 view controller 传递到 interactor 的请求对象。这个请求对象是一个 <code>CreateOrderRequest</code> 结构体。它由原始类型构成，而不是之前我们确定的全部的订单数据。这意味着我们可以将底层订单数据模型从 view controller 和 interactor 中解耦出来。所以当我们将来要对订单数据模型做修改的时候（例如在其中增加一个“订单 ID” 的字段），我们不需要去更新 Clean Swift 组件中任何其他的内容。</p>
<p>稍后我们完成了 VIP 循环之后，我们会再回到输出协议中的 displaySomething() 方法。</p>
<h2 id="output-和-router-变量"><a href="#output-和-router-变量" class="headerlink" title="output 和 router 变量"></a>output 和 router 变量</h2><p>输出变量是个遵循 <code>CreateOrderViewControllerOutput</code> 协议的对象。虽然我们已经知道在这里它实际上是 interatcor，但也可以不是（因为可以将它替换成其他组件）。</p>
<p>router 变量是一个对 <code>CreateOrderRouter</code> 的引用，它被用来导航到不同的场景。</p>
<h2 id="configure-方法"><a href="#configure-方法" class="headerlink" title="configure() 方法"></a>configure() 方法</h2><p>我们将在 <code>awakeFromNid()</code> 方法中调用 <code>CreateOrderConfigurator.sharedInstance.configure(self)</code> 去让 configurator 来配置好 VIP 链。在 Uncle Bob 的 Clean 架构或者 VIPER（他将所有的配置工作放在 AppDelegate 中）里没有 configurator （配置器）的存在。由于我真的不想让这些无关的配置代码打乱我们的 VIP 代码，所以我将其提取出来放入到了 configurator 中。稍后我们会来看一下 configurator。</p>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>在 <code>viewDidLoad()</code> 中，我们需要去运行一些业务逻辑，所以调用 <code>doSomethingOnLoad()</code>。在 <code>doSomethingOnLoad()</code> 中，我们创建一个 <code>CreateOrderRequest()</code> 对象并在 output（the interactor）上调用 <code>doSomething()</code>。就是这样啦。我们要求 output 来执行我们的业务逻辑，view controller 不用也不应该关心谁来做，以及它如何完成。</p>
<h2 id="See-you-in-the-next"><a href="#See-you-in-the-next" class="headerlink" title="See you in the next"></a>See you in the next</h2><p>第一篇先翻译到这里，下次我们再接着 Interactor 继续。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;节选翻译来自 Clean Swift iOS Architecture for Fixing Massive View Controller 系列第一篇。&lt;br&gt;原作者：Raymond&lt;br&gt;翻译者：Roc Zhang&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>跨越大三</title>
    <link href="http://www.roczhang.com/%E8%B7%A8%E8%B6%8A%E5%A4%A7%E4%B8%89.html"/>
    <id>http://www.roczhang.com/跨越大三.html</id>
    <published>2017-11-25T16:37:26.000Z</published>
    <updated>2018-06-05T22:02:18.149Z</updated>
    
    <content type="html"><![CDATA[<p>大三早已结束了。对于名义上大四却已经实习了一个多月的我来说，大学生活好像真的已然过去了。</p>
<a id="more"></a>
<h3 id="16年7月-～-16年8月，实习"><a href="#16年7月-～-16年8月，实习" class="headerlink" title="16年7月 ～ 16年8月，实习"></a>16年7月 ～ 16年8月，实习</h3><p>距离上一次写生活日志已经过去一年多了，而上篇落笔时我还身处北京，体验第一次实习的各种新鲜感。并且不仅是实习，也是第一次见到如此多的在网络上 follow 已久的 stars 们。在多点的那个暑假非常开心，每天能和师傅、友才还有马老师一起工作，还可以和 JustZht、Cee 一起看电影吃饭，听 Kevin 说了很多人生经验。而更重要的是我看到了更优秀同行业的同龄人和前辈是如何工作和生活的。</p>
<h3 id="16年9月-～-16年11月，返校"><a href="#16年9月-～-16年11月，返校" class="headerlink" title="16年9月 ～ 16年11月，返校"></a>16年9月 ～ 16年11月，返校</h3><p>回到学校之后的日子渐渐平淡下来。而感激于 Kevin 给我继续远程工作的机会，得以给我每天平淡的校园生活以一些机会去做自己喜爱的事。记得有阵子每天晚上都会 coding 到凌晨，饿了就吃吐司面包，累了就看一看 B 站上的食彩之国。虽然有时候通宵 coding 完还要继续去上早上的课困到撑不出，但第一次有一种用力工作用力生活的感觉。而这一段时间也是我有史以来技术学习最快最积极的一段时间了。  </p>
<p>想起这段生活至今依然感到非常充实幸福，我感到非常幸运，真的很感谢 Kevin。</p>
<p>有了一份得以持续的实习工作，除了让我的精神生活得以充实之外，也让我第一次经济上更加独立了。搬出了在学校闹人的寝室，租住了学校旁的学生公寓，终于也有了一点独立的个人空间。</p>
<p>有阵子每天晚上我会一个人关掉所有灯听把音响开到最大反复听 Cornfield Chase，感觉自己好像虚无的飘在宇宙里，让我对未来的一切不确定都没那么恐慌了。</p>
<h3 id="16年12月-～-17年4月，前前前世和-WWDC"><a href="#16年12月-～-17年4月，前前前世和-WWDC" class="headerlink" title="16年12月 ～ 17年4月，前前前世和 WWDC"></a>16年12月 ～ 17年4月，前前前世和 WWDC</h3><p>十二月你的名字上线，追漫画不多的我感动到连刷两场，果然梦是只有少年才有的。期末结束去长沙见了小萌师傅，和师傅聊了一整天，听了些师傅对未来的打算。寒假回家见到了一些高中同学，他们也已经有了自己的规划，或是出国读研，或是选择考公务员。而自己已经意识到在学校的时间不多了，当时的我还对自己考不考研的事情依旧举棋不定。  </p>
<p>四月准备了一个音乐小游戏申请 WWDC 奖学金，虽然是第一次参与但自己却对此心生执念很久了。虽然最后没过，但看到一些冒泡排序可视化或者一个 collectionView 翻牌记忆都可以过，并且一个有 Apple iOS 俱乐部合作的学校就有几个人都过了的时候，实话说确实是有些不服气的。</p>
<h3 id="17年5月-～-17年6月，提前的毕业照和-Mr-Weather"><a href="#17年5月-～-17年6月，提前的毕业照和-Mr-Weather" class="headerlink" title="17年5月 ～ 17年6月，提前的毕业照和 Mr.Weather"></a>17年5月 ～ 17年6月，提前的毕业照和 Mr.Weather</h3><p>转眼五月，迎来了我院特色提前拍毕业照。穿上学士服想到马上就可以踏出校园的那一刻还是挺开心的，毕竟虽然不知道自己在学校算不算的上异类，我确实已经自己做自己的事太久了。并且长久以来自己在学校聊的来的朋友不多，看到其他同龄小伙伴在做各种精彩的事情总让我感到无可奈何，更早已开始让我期望自己能够去做自己喜爱的工作。此时我也开始放弃今年考研的打算，一方面是自己并不想在国内读研，因为咨询到不少朋友最后发现国内 CS 专业研究生似乎就是给导师打工，与其如此还不如去公司工作来积累经验。另一方面则是考虑到自己和自己家庭目前的情况，尤其是经济情况，似乎也并不允许。</p>
<p>而最后在学校的这段日子时间上也相对自由宽松，因此也得以做出了我的第一款个人应用 Mr.Weather，五月上架到了 AppStore。结果还是有些意外，得到了一些媒体的推荐，在 AppStore 上最高排到了国区天气免费榜 13 名，并且也因此认识了不少新朋友。当时每天早晨起床后第一件事就是打开邮箱查看用户发来的各类邮件，总让我能有一种被人认可的喜悦。</p>
<p>最后在学校的几周几乎每天都会和朋友骑车，也突然感觉这个被我吐槽了三年的城市好像也挺好的。</p>
<h3 id="17年7月，深圳香港"><a href="#17年7月，深圳香港" class="headerlink" title="17年7月，深圳香港"></a>17年7月，深圳香港</h3><p>七月回家带了一阵子之后去了深圳和香港。在港中大住了阵子，参与和体验了他们日常学习和工作的方式。而看到自己的同龄人在如此规范成熟的协作，也让我感到钦佩。<br>第一次来到大家都称赞开放的深圳，确实是到处充满了南方的气息，也顺带参与了一次 Swift <t> 沙龙。而对于香港我则是一直心有好感，一方面是小时候经常看 TVB 剧听粤语歌，另一方面则是香港的文化环境和社会制度的吸引。我羡慕香港的法治，羡慕香港在今天依然能够享有的那么一点小小自由。</t></p>
<h3 id="17年8月-～-17年9月，生命脆弱"><a href="#17年8月-～-17年9月，生命脆弱" class="headerlink" title="17年8月 ～ 17年9月，生命脆弱"></a>17年8月 ～ 17年9月，生命脆弱</h3><p>在深圳的时候得知姥姥病危，赶紧赶回家。看到之前每次回去都问我吃饱穿暖没有的姥姥躺在病床上连话都说不清的时候，心里非常难受。并且姥姥病情恶化的速度也超出所有人的想象，先后转院多次，姥姥却已经进入昏迷状态了。最后几天姥姥进了 ICU，我和家人坐在 ICU 和手术室中间的走廊，看着来来往往的病床推来推去，自己却又无可奈何，终于体会到“医院的墙不知听到了多少人的祷告”这句话的含义，而最后，姥姥还是走了。第一次在心智成熟之后面对生离死别，最后姥姥昏迷之后真的让我思考到底什么才能定义活着。想到之后姥姥再也不会坐在床上问我吃没吃饭呢，心情就会酸楚沉重起来。</p>
<h3 id="17年10月-～-现在"><a href="#17年10月-～-现在" class="headerlink" title="17年10月 ～ 现在"></a>17年10月 ～ 现在</h3><p>待家中事情办完，自己意识到该考虑校招的事情了。Mr.Weather 发布之后收到了一些 Offer，而面对校招自己还是想参与尝试一次的。也没有做什么别特的准备，做了一份简历，复习了一下算法 / 数据结构 / OC 方面的问题。但却发现一些公司的校招已经结束，而另一些校招笔试之后的进度又慢的离奇。最后还是在先拿到的几个 Offer 中决定去上海了，毕竟在家已经呆了挺久并且考虑到现在的经济状况也想去尽快工作。而新员工入职培训的时候，还接到了其他公司的电话，然而决定了就决定了。开始实习至今已经有一个多月了，每天十点上班八点下班的工作时间还是让我感觉挺累的，并且和去年相比，似乎少了一些兴奋，也许是因为去年实习时我意识到自己暑假结束后终究要回学校，也许是因为有 Kevin、小萌、马老师，而现在只有我一个人。<br>每天去掉工作、通勤、洗漱之外的时间，能留下给自己支配的时间已经非常少了，难免感到有些压抑与担忧，但至少我身处在自己喜爱的行业中。不过自己依然在努力融入新环境中，11 月初第一次参加了 Hackathon，与队友们一起组队 coding。也参加了一期 Sketch Meetup，最后一个似乎是培训班老师，一番抄袭无罪的理论让我三观不适。不过看到了丁一和 JASKNi，然而人很多并没有机会也没好意思上前打扰打招呼。<br>在家准备面试的之前开始了自己的新项目 Adonis，经过了好久好久的 TF 前几天终于上架了，关于 Adonis 的故事还是单独再谈。</p>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>落笔的时候脑中闪过了很多东西，甚至高考。现在大四的我大学生活基本已经算是结束了，我不得不说高考之后每件事似乎都和高考可以扯得上关系，而面对自己的高考我当然有遗憾但是没什么好后悔的。大一的时候我还没日没夜不停的想着复读的问题，看着周边一些每天连续游戏的同学和合不来的室友甚至很害怕自己变成那样。所以现在看起来自己的大学三年似乎一直过的很焦虑，虽然我对自己的学校并不满意，但也从来没有沉溺于抱怨，总是想着自己可以改变些什么，到发现环境改变不了的时候便开始专心改变自己。从大一大二每天泡实验室到寝室关门，到大三沉心于自己的事情，至少我一直向着自己的方向尝试努力。大一大二的时候急着在学校证明自己，拿一等奖学金，去评各类奖项，但后来我发现在学校里追逐这些对我而言并没有什么实际意义，我在学校之外开始看到了更多更优秀的同龄人在做什么，我开始关心自己应该要去做什么。甚至于私以为读大学的目的学专业倒是其次，因为该用的东西自己迟早会学，而至于大学人脉什么就更是胡诹。对我而言最重要的可能就是给我一个环境和足够的时间思考自己认识和处理世界的方式，想好了，就专心去做吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大三早已结束了。对于名义上大四却已经实习了一个多月的我来说，大学生活好像真的已然过去了。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.roczhang.com/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>Mr.Weather 的故事</title>
    <link href="http://www.roczhang.com/Mr.Weather%20%E7%9A%84%E6%95%85%E4%BA%8B.html"/>
    <id>http://www.roczhang.com/Mr.Weather 的故事.html</id>
    <published>2017-05-30T07:47:32.000Z</published>
    <updated>2018-06-05T22:02:18.146Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.roczhang.com/images/mrWeatherStory/banner.png" alt="Markdown preferences pane"></p>
<p>Mr.Weather 是第一个从 0 到 1 完全由我自己完成的 App，因此我也在这个过程中体验到了产品、设计、开发甚至是客服等各个角色。从构建 Mr.Weather 首版雏形至今已经超过一年，我想不如就从这几个身份来聊聊 Mr.Weather 的故事。</p>
<a id="more"></a>
<h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><h3 id="思路的雏形与改变"><a href="#思路的雏形与改变" class="headerlink" title="思路的雏形与改变"></a>思路的雏形与改变</h3><p>坦白说，开始动手做 Mr.Weather时我甚至没想好到底要做个怎样的产品，这也是为什么中间花费了如此长的时间。甚至于今天看来，雏形和现在的版本完全是两个不同的产品。最开始是在突发奇想下决定要做一个程序员风格的天气 app，实际上就是类似于 Terminal ，直接输入各种命令，完成查询某个城市天气之类的动作。而在这种奇特的思想驱动下，甚至还加入了类似聊天机器人的对话功能。整体风格也是尽力模仿像素风，甚至字体也是用的 Xcode 默认的 Menlo。当时还在大二的我觉得这种感觉很酷，而现如今看起来则是有些惨不忍睹了。<br><img src="http://www.roczhang.com/images/mrWeatherStory/2.png" alt="Markdown preferences pane"></p>
<p>之后大二暑假实习期间的一个晚上去 Kevin 家吃饭，我掏出手机给 Kevin 看了当时的 Mr.Weather。依稀记得 Kevin 说挺有趣但感觉有些自嗨，我认真一想感觉还真的是。就算是程序员，也不会每次想要查温度都要输入一个 weather -temp 呀。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>在实习结束后，我开始认真考虑究竟应该做一个怎样的天气应用。如同买钻头的人需要的往往不是钻头而是洞，大部分用户查看天气都不是为了研究天气数据，而是想要知道这些数据会怎样影响到自己，自己需要做出怎样的决定。<br>在仔细观察自己和朋友的使用习惯之后，初步将需求划分成两部分：一是经常发生的，有规律的动作，比如我们会在早晨出门前查询天气，通过降雨概率决定要不要带伞，或者通过空气质量指数决定要不要戴口罩，再或者在周五晚上看看周末的天气适不适合安排出游之类。而另一部分则是相对随机的，没有太多规律的动作。比如临出门时天色暗下来了查查当前天气。于是根据这两类需求，我开始重新考虑 Mr.Weather 的 feature。对于第一类规律性的动作，我做了 Mr.Weather 中最重要的一个功能，自定义天气通知。你可以自定义触发通知的条件、监测时间与通知发送时间，如 “当天的空气质量指数大于100时，在早晨提醒我带口罩”，又或是“第二天的降雨概率大于 50% 时，在晚上提醒我装好伞”。这些规律性的动作，就可以完全交给 Mr.Weather 来监控，用户不必每次手动查看了。而对于另一方面的需求，我给出的解决方案是当用户主动查看时，以最直观的方式告诉他所需要的信息。如 App 中包涵了分为四大类别的可定制卡片，拥有实时播报和天气动画的 Widget。并且尽量更直接的告诉用户天气变化趋势以及将带来怎样的影响，而不单是天气数据。<br><img src="http://www.roczhang.com/images/mrWeatherStory/4.png" alt="Markdown preferences pane"></p>
<p>每一次增改 feature 都可能让已经完成的设计和代码被放弃重来，甚至让完成进度变成遥遥不可期。在经历了第一版的 Mr.Weather 之后，我也学着更谨慎的面对每一个设想和功能。</p>
<h3 id="克制"><a href="#克制" class="headerlink" title="克制"></a>克制</h3><p>在考虑其他功能点时我也相对保持克制，引用 Alan 的话说，我非常讨厌 “航母级应用”，所有的生活需求被一个 App 接管是一种非常可怕的事。相比而言我更喜欢目的明确的产品，用起来干脆利落。少即是多的道理谁都会讲，而增加功能却经常是一个思考成本相对更低的选择。而由于 Mr.Weather 是个人作品，所以也有机会更加纯粹，无需面对所谓的 「 KPI 压力 」 吧。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>我很敬佩那些设计优秀重视细节的产品，这样的产品处处都会充满着设计者的巧思与灵魂。同时我很享受做设计的过程，打开 Sketch 看到一个个 Artboard 排列在屏幕上的感觉总会让人非常愉悦。从自己画下 Mr.Weather 中用到的每一个小图标，到设计调整各个天气动画，甚至是通知提示音，很多细节都需要时间和精力打磨。<br><img src="http://www.roczhang.com/images/mrWeatherStory/5.png" alt="Markdown preferences pane"></p>
<h3 id="气质与迭代"><a href="#气质与迭代" class="headerlink" title="气质与迭代"></a>气质与迭代</h3><p>设计的理念倒不像产品一样，从开始时我就希望 Mr.Weather 的设计干净明晰。Mr.Weather 的整体配色相对克制，也尽量注意留白。整体由信息驱动，寻求干净开阔。由于在产品构思上的更新导致整个产品有过数次推翻重来，我自己又稍稍有些强迫症，经常会和一个图标、界面死磕，找不到想要的感觉就会再来。单一个设置界面就反反复复改了数版，而至于引导界面、主界面之类则更甚，经常是自己看着不舒服就推倒再来。不过除去做个人作品怕是很难会有这样的时间成本可以让自己打磨了。好在最后的结果自己总体还算比较满意，当然还是有很多不足（比如不少用户甚至都没能找到设置入口）。<br><img src="http://www.roczhang.com/images/mrWeatherStory/6.png" alt="Markdown preferences pane"></p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>配合 Mr.Weather 整体的气质，我为 Mr.Weather 的英文与数字选择了 Gill Sans 这款字体。Gill Sans 被誉为英国的 Helvetica，甚至在 SHERLOCK 电影前的 BBC 片头里还能见到他的身影。虽然我对字体的了解还非常浅薄，但我很喜欢这款字体那种相对谨慎且平和的气质。在 Sketch 和 iPhone 屏幕上反复比较之后，我觉得 Gill Sans 相对 Open Sans 、Helvetica 等字体与 Mr.Weather 整体更加契合，于是选定了使用 Gill Sans。而中文字体由于考虑到对应用整体大小的控制，所以算是在妥协之下选择了系统默认的苹方。</p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>Mr.Weather 的天气动画依然在寻求自然干净的感觉，晴天、阴天、雨天及下雪等场景的动画也遵循 Mr.Weather 整体的配色。 除去较大的天气动画之外，在 App 中我也加入了很多细小的动画。比如下拉菜单时后面背景的逐渐模糊，添加卡片时类似一推滑动的 toggle 动画，天气卡片下方展开分类筛选时的提示用户可以滑动的动画，以及各类 alert 动画等等，都希望能营造出一种自然、干净、利落的体验。<br>Mr.Weather 中的动画在少数地方使用了 Facebook 的 pop 与 Airbnb 的 Lottie，而 95% 以上的动画还是使用了 CoreAnimation 来完成。<br><img src="http://www.roczhang.com/images/mrWeatherStory/7.png" alt="Markdown preferences pane"></p>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>由于自己程序员的主要身份，所以整体开发上的烦恼基本只剩下 Xcode 经常崩溃的自动提示与 Swift 越来越长的编译等待时间。但最重要的天气通知则还是遇到了一些问题。对于如何处理天气通知想过非常多的办法，甚至于一开始打算把所有用户的通知设置保存在 Server 上，由 Server 来处理判断再给客户端发通知。而这种办法对于目前的 Mr.Weather 来说基本不可行。后来还是采取了后台应用刷新和远程静默通知结合的方式来解决。</p>
<h3 id="数据源与运营压力"><a href="#数据源与运营压力" class="headerlink" title="数据源与运营压力"></a>数据源与运营压力</h3><p>另一件比较烦心的则是天气数据源的选择。先后比较了几个数据源，最后还是选择了一个付费数据源。毕竟准确、及时的数据对于一个天气应用至关重要，也会在很多时候影响用户体验。而在上架时，考虑到 Mr.Weather 目前的完善状况，觉得现在收费还是对用户不太负责的行为，所以选择了免费也没有添加内购选项。后来 Mr.Weather 的日访问突然增长，按次收费的天气接口费用让我措手不及。非常感动的是不少用户都给予了捐助支持，也帮助我在想清 Mr.Weather 的未来之前缓解了不少压力。</p>
<h3 id="内测"><a href="#内测" class="headerlink" title="内测"></a>内测</h3><p>在 Mr.Weather 上架之前，我先通过 TestFlight 发布了数个测试版本。由于开发者使用时的一些惯性非常容易忽略掉不少问题，所以进行测试非常必要。 Mr.Weather 先后从 0.1 测到 0.7，其中数次都是凌晨新版本通过审核后交由朋友们测试一天，我在当天晚上就会做修改调整，再提交下一版本审核。朋友们给了很多反馈与建议，数次下来 Mr.Weather 的问题也少了很多，方提交到了 AppStore。<br>值得一提的是，作为自己第一次提交给 AppStore 的应用，一次就通过审核了，而且前后一共也只用了两三天的时间，非常意外。</p>
<h3 id="上架后与用户反馈"><a href="#上架后与用户反馈" class="headerlink" title="上架后与用户反馈"></a>上架后与用户反馈</h3><p>Mr.Weather 于 5 月 18 日上架到了 AppStore ，至今差不多两周的时间。期间最佳排名为国区天气类免费榜第 25 名。而上架之后，阅读每日的反馈与来信也变成一件非常有趣的事情，也正是通过这个渠道，结识到了不少用户甚至是设计师和开发者，感觉非常奇妙。</p>
<h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>从大二开始参与过大大小小的项目开发，在团队中每个人各司其职，相互配合与学习的过程让我非常快乐。而第一次通过 Mr.Weather 完整体验了从 0 到 1 制作一款产品，自己独立掌控产品的方方面面则别有一番感触。这两种体验都让我投入且着迷。<br>我曾想过做设计对一个程序员而言会不会是不务正业，然而上面提到的每一个角色努力的目的都是为了打造出一个更好的产品，之间并没有冲突。而将我的所学所想杂糅并倾注到一款产品中去，不断打磨完善，再实现新的想法，这个过程我想我永远不会觉得无趣。</p>
<p>我是 Roc Zhang，这就是我的首个独立作品 Mr.Weather。<br>Mr.Weather 官网与下载地址：<a href="http://www.roczhang.com/mr.weather/">http://www.roczhang.com/mr.weather/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.roczhang.com/images/mrWeatherStory/banner.png&quot; alt=&quot;Markdown preferences pane&quot;&gt;&lt;/p&gt;
&lt;p&gt;Mr.Weather 是第一个从 0 到 1 完全由我自己完成的 App，因此我也在这个过程中体验到了产品、设计、开发甚至是客服等各个角色。从构建 Mr.Weather 首版雏形至今已经超过一年，我想不如就从这几个身份来聊聊 Mr.Weather 的故事。&lt;/p&gt;
    
    </summary>
    
      <category term="Product" scheme="http://www.roczhang.com/categories/Product/"/>
    
    
  </entry>
  
  <entry>
    <title>&#39;===&#39; &amp; &#39;!==&#39; in Swift</title>
    <link href="http://www.roczhang.com/in-Swift.html"/>
    <id>http://www.roczhang.com/in-Swift.html</id>
    <published>2017-03-28T14:21:43.000Z</published>
    <updated>2018-06-05T22:02:18.148Z</updated>
    
    <content type="html"><![CDATA[<p>一篇简短的小记。<br><a id="more"></a></p>
<h1 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h1><p>由于最近比较多的用了 IGListKit 来写新的模块和重构旧的模块，其中 IGListKit 要求模型遵遁 IGListDiffable 协议，其中需要你实现一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public func isEqual(toDiffableObject object: IGListDiffable?) -&gt; Bool</div></pre></td></tr></table></figure>
<p>来告诉 IGList 接收到的和给定的 object 是否相等。一般情况用模型里的 hash id 来判断就可以解决，但今天和师傅讨论到如果是一个数组，而且数组里的模型又没有 ID 属性，该如何判断相等。</p>
<p>由此想到了 ‘===’ &amp; ‘!==’ 运算符。</p>
<h1 id="‘-’-amp-‘-’"><a href="#‘-’-amp-‘-’" class="headerlink" title="‘===’ &amp; ‘!==’"></a>‘===’ &amp; ‘!==’</h1><p>比起常用的 == 和 != ，这两个运算貌似使用的频度非常低，其实用法倒是很简单的， === 和 !== 用于比较 引用类型（Reference Type）是否是相同的引用。</p>
<p>不过随便查看几个搜索结果会发现好像有这么一段说法：</p>
<p>“Check whether two arrays or subarrays share the same storage and elements by comparing them with the identity operators (=== and !==).”</p>
<p>嗯嗯嗯？还可以比较数组或者子数组的？原生支持？如此方便？<br>在 Playground 中简单一试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let array1 = [1, 2, 3]</div><div class="line">var array2 = array1</div><div class="line"></div><div class="line">array1 !== array2</div></pre></td></tr></table></figure>
<p>马上就会 “Error: binary operator ‘!==’ cannot be applied to…”。</p>
<p>不过等等，Swift 中的 Array 不是 Value Type 吗，是应该不能用这个啊，那为什么会有可以比较数组这种说法？难道记错了？</p>
<p>“Array and Dictionary in Swift are implemented as structs.”</p>
<p>没记错， Array 是 Value Type.</p>
<p>后来发现，之所以有比较数组这种说法是因为，在 2014 年 Swift beta 3 之前，Swift 中的 Array 有一些小小的不同，引用喵神以前的博客里的一句话：</p>
<p>“Swift 考虑到实际使用的情景，对 Array 做了特殊的处理。除非需要（比如 Array 的大小发生改变，或者显式地要求进行复制），否则 Array 在传递的时候会使用参照。”</p>
<p>而之后</p>
<p>“对于 Array 中元素的改变，在 beta 3 中发生了变化。现在不再存在作为一个值类型但是却在赋值和改变时表现为参照类型的 Array 的特例，而是彻头彻尾表现出了值类型的特点。”</p>
<p>所以， ‘===’ &amp; ‘!==’ 用于比较数组的这种说法也是很早之前的老文档中存在的，现在并不能用啦。</p>
<p>等等，谁说不能？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let array1 = NSArray(array: [A, B])</div><div class="line">var array2 = array1</div><div class="line"></div><div class="line">array1 !== array2</div></pre></td></tr></table></figure>
<p>用 Cocoa 中的容器类自然没问题，因为是引用类嘛。</p>
<p>但这就没有 Swift 的 “钦定” 感了! 🙃</p>
<p>善变的 Swift! 🙃</p>
<h1 id="Swift-3-1"><a href="#Swift-3-1" class="headerlink" title="Swift 3.1"></a>Swift 3.1</h1><p>Xcode 8.3 出来了！ Swift 3.1 出来了！<br>Apple 还说 “Faster builds for large projects that mix Objective-C and Swift code”!<br>赶紧一试！</p>
<p><img src="http://i1.piimg.com/577817/dc057c7c28ef5d73.jpg" alt="Markdown preferences pane"></p>
<p>120 秒… 还有 Swift 3.1 附赠的爆炸多的警告… 🙃<br>也许还是在提示我电脑不行了。 🙃</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-ID82" target="_blank" rel="external">Apple - Classes and Structures</a><br><a href="https://onevcat.com/2014/06/walk-in-swift/" target="_blank" rel="external">OneV’s Den - 行走于 Swift 的世界中</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇简短的小记。&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>3D Touch for iOS 10 适配指南</title>
    <link href="http://www.roczhang.com/3D-Touch-for-iOS-10-%E9%80%82%E9%85%8D%E6%8C%87%E5%8D%97.html"/>
    <id>http://www.roczhang.com/3D-Touch-for-iOS-10-适配指南.html</id>
    <published>2017-03-26T02:31:03.000Z</published>
    <updated>2018-06-05T22:02:18.146Z</updated>
    
    <content type="html"><![CDATA[<p>好不容易起个大早的居然就突然停电了，翻看到好久之前的 WWDC 学习笔记，想起来之前好像打算稍稍整理一下 3D Touch 相关内容的，趁着 MacBook 还有电顺手写一下。<br><a id="more"></a></p>
<p>对应的是 WWDC 16 - Session 228。先记录 Session 上的相关内容。</p>
<h1 id="Home-Screen-Quick-Actions"><a href="#Home-Screen-Quick-Actions" class="headerlink" title="Home Screen Quick Actions"></a>Home Screen Quick Actions</h1><p>这就是 iOS SpringBoard 上用力点按 App Icon 弹出的快捷操作菜单了。此类菜单分为两类，静态和动态。</p>
<h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><p>静态 action 被定义在 app 的 info.plist 文件中。定义之后，用户在安装了你的 app 后就可以生效使用。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-UIApplicationShortcutItems</div><div class="line">--Item 0</div><div class="line">---UIApplicationShortcutItemType      String    com.company.app.XXX</div><div class="line">---UIApplicationShortcutItemTitle    String    New Chat</div><div class="line">---UIApplicationShortcutItemIconType  String    UIApplicationShortcutIconTypeMessage(system type)</div></pre></td></tr></table></figure>
<p>最后的 ShortcutIconType 可以使用系统提供的一些类型。而关于 Item 总数的问题，除去 iOS 10 开始系统增加的 “分享” 项外，最多只能设置 4 个（包括动静态项全部）。顺带一提，貌似大多数 app 的做法都是一个静态项外加三个动态生成项。</p>
<h2 id="Dynamic"><a href="#Dynamic" class="headerlink" title="Dynamic"></a>Dynamic</h2><p>与上面静态项所对应的就是 dynamic item，动态项是你的 App 在运行时创建的，所以只有在你的 app 第一次启动后才可以生成并可用。并且顺序上 dynamic item 是展示在 static item（看 action 列表展开的方向嘛，动态项会比静态项离手指更远）。但是动态项除了可以使用上面提到的系统提供的 icon 外，还可以使用自定义的 icon，以及通讯录中联系人的头像👦。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">let contactName = &quot;RocZhang&quot;</div><div class="line">var contactIcon: UIApplicationShortcutIcon? = nil</div><div class="line"></div><div class="line">// Make sure to request access to the user&apos;s contacts first</div><div class="line">if CNContactStore.authorizationStatue(for: .contacts) == .authorized &#123;</div><div class="line">    let predicate = CNContact.predicateForContacts(matchingName: contactName)</div><div class="line">    let contacts = try? CNContactStore().unifiedContacts(matching: predicate, keysToFecth: [])</div><div class="line"></div><div class="line">    if let contact = contacts?.first &#123;</div><div class="line">        contactIcon = UIApplicationShortcutIcon(contact: contact)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Fallback</div><div class="line">let icon = contactIcon ??  UIApplicationShortcutIcon(type: .message)</div><div class="line"></div><div class="line">// Create a Dynamic quick action using the icon</div><div class="line">let type = &quot;com.company.app.sendMessageTo&quot;</div><div class="line">let subtitle = &quot;Send a message&quot;</div><div class="line">let shortcutItem1 = UIApplicationShortcutItem(type: type, localizedTitle: contactName, localizedSubTitle: subtitle, icon: icon)</div><div class="line"></div><div class="line">// Repeat ...</div><div class="line"></div><div class="line">let shortcutItems = [shortcutItem1, shortcutItem2, shortcutItem3]</div><div class="line"></div><div class="line">// Register the Dynamic quick actions to display on the home Screen</div><div class="line">UIApplication.shared.shortcutItems = shortcutItems</div></pre></td></tr></table></figure>
<h2 id="Handing"><a href="#Handing" class="headerlink" title="Handing"></a>Handing</h2><p>设置好这些快捷操作项后我们当然要处理相应点击后的操作。没啥特别好说的，两种情况：</p>
<h3 id="On-app-activation"><a href="#On-app-activation" class="headerlink" title="On app activation"></a>On app activation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func application(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: Bool -&gt; Void) &#123;</div><div class="line">    let didHandle: Bool =  handle the quick action using shortcutItem</div><div class="line">    completionHandler(didHandle)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="On-app-launch"><a href="#On-app-launch" class="headerlink" title="On app launch"></a>On app launch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool &#123;</div><div class="line">    var performAdditionalHandling = true</div><div class="line">    if let shortcutItem = launchOptions?[UIApplicationLaunchOptionsShortcutItemKey] as? UIApplicationShortcutItem &#123;</div><div class="line">        handle the quick action using shortcutItem</div><div class="line">        performAdditionalHandling = false</div><div class="line">    &#125;</div><div class="line">    return performAdditionalHandling</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Best-Practices"><a href="#Best-Practices" class="headerlink" title="Best Practices"></a>Best Practices</h2><p>关于上述的 Quick Actions，Apple 提供了一些建议：</p>
<ul>
<li>每个 app 都应该提供 quick actions(我想这可能就是 iOS 10 系统全部加上 “分享” 的原因之一🤗)</li>
<li>好钢用在刀刃上（因为总数只有 4 个，所以 Apple 建议应该给具有高价值的任务创建快捷进入项）</li>
<li>确保你设置的项目是可被用户预知的（嗯我感觉我用力按了这个图标应该会出现…诶诶诶你怎么不按套路出牌！）</li>
<li>做好版本升级后依然能处理前一个版本生成的动态快捷项的准备</li>
</ul>
<h1 id="Peek-amp-Pop"><a href="#Peek-amp-Pop" class="headerlink" title="Peek &amp; Pop"></a>Peek &amp; Pop</h1><p>如果你还不太了解 peek pop 是什么，建议去看一下超炫酷的 iPhone 6s 发布时介绍 3D Touch 的视频。<br><a href="https://www.youtube.com/watch?v=IfXB7SPbg9A" target="_blank" rel="external">iPhone 6s 3D touch feature video</a><br>简单说来，Peek &amp; Pop 提供了一种可供用户快速预览和在内容之间导航的方式。</p>
<h2 id="Adding-Peek-amp-Pop-to-your-app"><a href="#Adding-Peek-amp-Pop-to-your-app" class="headerlink" title="Adding Peek &amp; Pop to your app"></a>Adding Peek &amp; Pop to your app</h2><p>适配 Peek &amp; Pop 非常简单，但首先需要了解一下，CocoaTouch 中把这两个动作先后称之为 Preview 和 Commit。</p>
<p>适配的过程可分为以下几步：<br>一，让 ViewController 遵循 UIViewControllerPreviewingDelegate:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// MARK: - UIViewControllerPreviewingDelegate Methods</div><div class="line"></div><div class="line">extension ViewController: UIViewControllerPreviewingDelegate &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>二，是把 ViewController 注册 Previewing:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">override func viewDidLoad() &#123;</div><div class="line">    super.viewDidLoad()</div><div class="line"></div><div class="line">    registerForPreviewing(with: self, sourceView: tableView)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>三，实现 UIViewControllerPreviewingDelegate 中的 preview 和 commit 方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// MARK: - UIViewControllerPreviewingDelegate Methods</div><div class="line"></div><div class="line">extension ViewController: UIViewControllerPreviewingDelegate &#123;</div><div class="line">  func previewingContext(_ previewingContext: UIViewControllerPreviewing, viewControllerForLocation locatin: CGPoint) -&gt; UIViewContrller? &#123;</div><div class="line">    guard let indexPath = tableView.indexPathForRow(at: location) else &#123; return nil &#125;</div><div class="line"></div><div class="line">    let chatDetailViewController = ...</div><div class="line">    chatDetailViewController.chatItem = chatItem(at: indexPath)</div><div class="line">    let cellRect = tableView.rectForRow(at: indexPath)</div><div class="line">    let sourceRect = previewingContext.sourceView.convert(cellRect, from: tableView)</div><div class="line">    previewingContext.sourceRect = sourceRect</div><div class="line"></div><div class="line">    return chatDetailViewController</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  func previewingContext(_ previewingContext: UIViewControllerPreviewing, commit viewControllerToCommit: UIViewContrller) &#123;</div><div class="line">    show(viewControllerToCommit, sender: self)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Preview-quick-actions"><a href="#Preview-quick-actions" class="headerlink" title="Preview quick actions"></a>Preview quick actions</h2><p>这里你可以自己决定是否要提供一些预览时的快捷操作。并不是最开始说的主屏幕上的快捷操作，而是这里的：</p>
<p><img src="http://i4.buimg.com/577817/330ac8dc3e144f43.png" alt="Markdown preferences pane"></p>
<p>这里需要 override 一个 previewActionItems 的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">override func previewActionItems() -&gt; [UIPreviewActionItem] &#123;</div><div class="line">    let heart = UIPreviewAction(title: &quot;&quot;, style: .default) &#123; (action, viewController) in</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return [heart]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中的 style 除了 .default 还有 .selected 代表被选中，以及 .destructive 代表具有破坏性的操作。</p>
<h2 id="Best-Practices-1"><a href="#Best-Practices-1" class="headerlink" title="Best Practices"></a>Best Practices</h2><p>同样，关于 Peek &amp; Pop ，Apple 提供了一些建议：</p>
<ul>
<li>可以被点击的内容应该要考虑支持 Peek &amp; Pop （和上面那条 每个 app 都应该提供 quick actions 差不多，毕竟 3D Touch 用力点按之前用户并不知道会发生什么，有些可以响应 3D Touch 有些又不能就可能会让用户很不爽，久而久之就不愿意去使用 3D Touch 了）</li>
<li>不要在 previewing delegate 中花费太长的时间，因为是需要 peek 一下就显示出来，不能做太过费时的操作。</li>
</ul>
<h1 id="UIPreviewInteraction"><a href="#UIPreviewInteraction" class="headerlink" title="UIPreviewInteraction"></a>UIPreviewInteraction</h1><p>UIPreviewInteraction 似乎是用的比较少的，这是一个可以让我们的视图提供响应 3D Touch 交互动作的类。刚才提到 preview 和 commit，实际上这是使用 3D Touch preview 中包括的两个过程。由于从开始点按屏幕到响应 peek（preview 阶段结束） 再到响应 pop (commit 阶段结束)，力度是有变化的。通过 UIPreviewInteraction 我们就可以获取当前用户点按力度分别在这两个阶段中的进度（0-1），这两个阶段的关系使用 API 官网中的一张图就可以表示清楚：</p>
<p><img src="http://i2.buimg.com/577817/ee50a5a22bc56521.png" alt="Markdown preferences pane"></p>
<p>适配过程同样很简单，大致如下：<br>一，遵循 UIPreviewInteractionDelegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extension xxViewController: UIPreviewInteractionDelegate</div></pre></td></tr></table></figure></p>
<p>二，创建 UIPreviewInteraction 并设置 delegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private var previewInteraction: UIPreviewInteraction?</div><div class="line"></div><div class="line">override func viewDidLoad &#123;</div><div class="line">    super.viewDidLoad()</div><div class="line"></div><div class="line">    previewInteraction = UIPreviewInteraction(view: view)</div><div class="line">    previewInteraction?.delegate = self</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>三，就可以通过代理方法获取到当前的进度，然后做你需要的事情了。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func previewInteraction(_ previewInteraction: UIPreviewInteraction, didUpdatePreviewTransition  transitionProgress: CGFloat, ended: Bool) &#123;</div><div class="line">    // Do something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为通过 progress 获取到进度，所以我们可以通过这个值来驱动一些动画之类的，仔细想想这个应该会是蛮好玩的。</p>
<h1 id="Low-Level-Force-API"><a href="#Low-Level-Force-API" class="headerlink" title="Low-Level Force API"></a>Low-Level Force API</h1><p>此外，session 228 的最后也提及了一下低层级力度 API ，在支持 3D Touch 或 Apple Pencil 的设备上，你可以获取到规范化的力度数据。关于这方面的内容，可以参见另一个 session: Leveraging Touch input on iOS.</p>
<h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><p>下面是一些 session 中并没有提及的内容。<br>除去上面通过 UIViewControllerPreviewingDelegate 适配常见的 UITableView, UICollectionView 等的 peek 与 pop 操作，还有一种比较常见的场景是，我们希望在 3D Touch 发生在 cell 的每个部分上时，作出不同的响应（比如，3D Touch 了某个 feed 我们希望预览这个 feed 的详情，而点的时 feed 里的头像时，我们希望弹出的预览是 profile）。我们可以在上面的基础上进一步，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public func viewContainsFormSuperview(with view: UIView, location: CGPoint) -&gt; Bool &#123;</div><div class="line">        let location = view.convert(location, from: self)</div><div class="line">        return view.bounds.contains(location)</div><div class="line">&#125;</div><div class="line"></div><div class="line">public func previewingContext(_ previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -&gt; UIViewController? &#123;</div><div class="line">        guard let indexPath = tableView.indexPathForRow(at: location) else &#123; return nil &#125;</div><div class="line">        guard let cell = tableView.cellForRow(at: indexPath) as? xxCell else &#123; return nil &#125;</div><div class="line"></div><div class="line">        let avatarView = cell.avatarView</div><div class="line">        let location = avatarView.convert(location, from: tableView)</div><div class="line">        if avatarView.bounds.contains(location) &#123;</div><div class="line">            let viewRect = tableView.convert(avatarView.frame, from: avatarView.superview)</div><div class="line">            previewingContext.sourceRect = viewRect</div><div class="line"></div><div class="line">            return ProfileViewController()</div><div class="line">        &#125; else &#123;</div><div class="line">            return nil</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结，session 中方提到的适配 3D Touch 主要三个方面 – 主屏幕快捷操作可以使用户直接跳转进对应的动作，Peek &amp; Pop 允许用户快速预览并导航到内容，最后的 UIPreviewInteraction 也为 app 的交互提供了新的可能。这篇文章也就到这里啦，如有问题和疏漏，还请指出。</p>
<p>最后准备提交的时候发现 多说即将关闭 的消息，啊，有点可惜。</p>
<h2 id="See-you"><a href="#See-you" class="headerlink" title="See you"></a>See you</h2><p>Created by ROC Zhang on 2017-03-26.<br>Copyright © 2016-2017 ROC Zhang. All rights reserved.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好不容易起个大早的居然就突然停电了，翻看到好久之前的 WWDC 学习笔记，想起来之前好像打算稍稍整理一下 3D Touch 相关内容的，趁着 MacBook 还有电顺手写一下。&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>遇到的 XC 8 中的两个小坑</title>
    <link href="http://www.roczhang.com/%E9%81%87%E5%88%B0%E7%9A%84%20XC%208%20%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B0%8F%E5%9D%91.html"/>
    <id>http://www.roczhang.com/遇到的 XC 8 中的两个小坑.html</id>
    <published>2016-11-28T16:23:12.000Z</published>
    <updated>2018-06-05T22:02:18.150Z</updated>
    
    <content type="html"><![CDATA[<p>今天可能时运不济，一次碰到了两个小坑，趁着现在 pod repo update 的时候记一下。<br><a id="more"></a></p>
<h2 id="Background-Fetch"><a href="#Background-Fetch" class="headerlink" title="Background Fetch"></a>Background Fetch</h2><p>今天在一开始在写和 Background Fetch 相关的代码。把 performFetchWithCompletionHandler 写好，然后其他的配置做好之后，连上手机准备测试。因为一般 Background Fetch 发生都需要时间，而且这个调用的时间间隔是系统定的，即使设定了 setMinimumBackgroundFetchInterval(UIApplicationBackgroundFetchIntervalMinimum) 可能也要蛮久一段时间系统才会调用。所以一般都会点 Xcode -&gt; Debug -&gt; Simulate Background Fetch 让 Background Fetch 能立即执行来方便调试。</p>
<p>所以我当然也是要点的。<br>结果我期待的结果并没有和以前一样发生，程序居然奔溃退出了，就像这样。</p>
<p><img src="http://p1.bpimg.com/4851/100d68e61bc45fa2.png" alt="Markdown preferences pane"></p>
<p>我开始以为是自己代码有问题，于是调试了一会儿，最后发现即使我在方法里什么都不做调用的时候还是会奔溃。有点懵。然后我在模拟器上试了一发，结果发现并没有任何问题！调用是成功的！</p>
<p>Google 了一发，在 Apple Developer Forums 里看到了一篇贴 ( <a href="https://forums.developer.apple.com/thread/51361" target="_blank" rel="external">https://forums.developer.apple.com/thread/51361</a> )，也有人在 Xcode 8 上遇到了一样的情况：</p>
<p><img src="http://p1.bpimg.com/4851/544f7a16ca99aeee.png" alt="Markdown preferences pane"></p>
<p>然而最后是怎么解决的呢？当然不是等20分钟让他自然发生调用。你会发现在真机上点击后的奔溃是 Xcode 自己断开的，然后你再轻轻的点一下继续执行按钮，它就把我的 Background Fetch 执行好了。</p>
<p><img src="http://p1.bpimg.com/4851/6cef865f9bef302d.png" alt="Markdown preferences pane"></p>
<p>Fun.</p>
<h2 id="UNNotificationSound"><a href="#UNNotificationSound" class="headerlink" title="UNNotificationSound"></a>UNNotificationSound</h2><p>还有就是关于 UNNotificationSound 的问题。</p>
<p>我在尝试用 iOS 10 新的 UserNotification 来创建通知，一个本地通知，其他的一切都没有问题，然而自定义的提醒通知的声音就是无法播放。并且以前创建通知写法的代码是没有问题可以播放的。</p>
<p><img src="http://p1.bpimg.com/4851/960c9bffa8db51e8.png" alt="Markdown preferences pane"></p>
<p>从苹果的文档 ( <a href="https://developer.apple.com/reference/usernotifications/unnotificationsound" target="_blank" rel="external">https://developer.apple.com/reference/usernotifications/unnotificationsound</a> ) 看到 UNNotificationSound 支持由 Linear PCM ／ MA4 (IMA/ADPCM)／ µLaw ／ aLaw 封装成的 aiff, wav, caf 几种格式的文件。我也转换了几种格式都试了下想确定是不是格式的问题，而无论怎么测试，系统始终播放的是默认的三连音：哒哒哒。</p>
<p>然后我又遇到了一样处境的人（这次的人比较多），还是在 Apple Developer Forums 里的帖子（ <a href="https://forums.developer.apple.com/thread/49512" target="_blank" rel="external">https://forums.developer.apple.com/thread/49512</a> ）。</p>
<p>有人好像找到了暂时解决的方法：重启 iOS 设备，卸载 App ，然后重新安装，自定义的铃声就可以生效了。但是有人说这种方法在你使用 Xcode 再装 App 的时候又会失效了。</p>
<p><img src="http://p1.bpimg.com/4851/313c960e725367c2.png" alt="Markdown preferences pane"></p>
<p>但是无论如何，我的自定义铃声一直没有播出来。<br>Magic.</p>
<h3 id="？？？"><a href="#？？？" class="headerlink" title="？？？"></a>？？？</h3><p>天冷了，Macbook 的散热变好了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天可能时运不济，一次碰到了两个小坑，趁着现在 pod repo update 的时候记一下。&lt;br&gt;
    
    </summary>
    
      <category term="Code" scheme="http://www.roczhang.com/categories/Code/"/>
    
    
  </entry>
  
  <entry>
    <title>我的设计学习之旅</title>
    <link href="http://www.roczhang.com/%E6%88%91%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85.html"/>
    <id>http://www.roczhang.com/我的设计学习之旅.html</id>
    <published>2016-10-28T21:03:38.000Z</published>
    <updated>2018-06-05T22:02:18.148Z</updated>
    
    <content type="html"><![CDATA[<p>今晚逛 Dribbble 的时候突然又点开看了自己悲剧的 Debuts ，于是突然想到理理这个，正好可以也当作自己博客 Design 系列第一篇。<br><a id="more"></a></p>
<h2 id="大学前"><a href="#大学前" class="headerlink" title="大学前"></a>大学前</h2><p>大学前基本应该不懂啥是设计（现在应该也不懂）。</p>
<p>初中的时候机缘巧合参加了网页制作的比赛，那时候第一次开始用 Photoshop，做一些素材，修改排版。当时觉得来回折腾调整，或者这种在“制作／创作”的感觉非常有意思。而初高中时期除了偶尔帮班主任做一些班会的 PPT 也就没什么时间和机会做东西了。那会儿能算的上接触的设计作品也就算是各种主题了。</p>
<h2 id="大学后"><a href="#大学后" class="headerlink" title="大学后"></a>大学后</h2><h3 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h3><p>大一刚进大学那会儿除了日常写程序结果是做各种 PPT，居然还被班上同学嘲笑为 “PPT 小王子”。其实是根本没啥特别的，只不过我没有用 Office 艺术字而已。附上一个那会儿给一个小活动做的 Keynote。</p>
<p><img src="images/myDesignsStudyTour/1.jpeg" alt="Markdown preferences pane"></p>
<p>然后就开始算的上设计了第一个作品了– 真选！那时候还不是会做真正的 App 开发，就在 Photoshop 里面画设计稿。那时候完全不了解 App 设计的准则规范之类，完全凭借着自己的感觉来。从自己觉得丑到爆炸到后来慢慢改成觉得还行之间，也是改了很多个版本。</p>
<p>一开始几个版本是这样的，其实都挺辣眼睛的：<br><img src="images/myDesignsStudyTour/2.png" alt="Markdown preferences pane"></p>
<p>最后做成这样了：<br><img src="images/myDesignsStudyTour/3.png" alt="Markdown preferences pane"></p>
<p>还若有其事的做了一个 MockUp 当 Cover ：<br><img src="images/myDesignsStudyTour/4.PNG" alt="Markdown preferences pane"></p>
<p>后来非常幸运的认识了 Martin Waters ， 神奇的白开水兄。大一暑假的时候还和白开水见了面，一起继续做了真选参加了一小比赛。一开始是在一个编程开发的群认识了白开水，后来发现白开水设计的东西都惊人的漂亮。我那时会将我设计的一些不堪入目的东西交给白开水，他总是会画腐朽为神奇一般的 redesign 的非常棒。而且他总是会向我介绍一些非常神奇的工具，比如我第一次了解 Sketch 就是白开水介绍给我的，嗯，真是如同打开了新世界的大门。</p>
<p>当年暑假白开水兄画下的一些 Icon ：<br><img src="images/myDesignsStudyTour/5.png" alt="Markdown preferences pane"></p>
<h3 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h3><p>寒假的时候读了 About Face 和 设计心理学全系列的四册，算是第一次开始看设计类的书籍。后来开学之后大多数时间都在学习写 App，所以就在有了新 App 想法的时候会画上一些:</p>
<p>Roc Daily<br><img src="images/myDesignsStudyTour/6.png" alt="Markdown preferences pane"></p>
<p>教务助手<br><img src="images/myDesignsStudyTour/7.png" alt="Markdown preferences pane"></p>
<p>期间还画过一些小东西，比如图标还有小组件之类的：<br><img src="images/myDesignsStudyTour/8.png" alt="Markdown preferences pane"><br><img src="images/myDesignsStudyTour/9.PNG" alt="Markdown preferences pane"></p>
<p>实习的时候见到了之前仰慕已久大神们，在一旁观察他们做设计时的章法、理念、创意，还有和我们把 App 用程序写出来之后和设计稿仔细的比对调整，像素级的双眼和对细节的追求。嗯，我在钦佩的同时又开始感概道阻且长啦。</p>
<p>之后还得到了自己心心念念的 Dribbble 邀请码（我要再次再次感谢敬爱的马老师），本打算也画一波 Hello Dribbble 的我尝试了几稿后还是决定在原来的设计稿上修改一个提交，于是这就是我的 Debuts 了:</p>
<p><img src="images/myDesignsStudyTour/10.png" alt="Markdown preferences pane"></p>
<p>Dribbble 上的地址是：<a href="https://dribbble.com/shots/2969219-Hello-Dribbble" target="_blank" rel="external">https://dribbble.com/shots/2969219-Hello-Dribbble</a></p>
<p>现在感觉确实画的不好后悔把这个当 Debuts 啦。</p>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>想起来刚开始练习做设计的时候还怀疑过不写代码自己是不是跑偏了，后来觉得如果是自己想要做一个产品的话，设计和开发都是实现好产品的一种方式，本质是相同的。我想过做设计的目的是什么，嗯，应该是悦心，从设计产品的 look 到 work，好的设计总能让人感到愉悦。这太值得了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今晚逛 Dribbble 的时候突然又点开看了自己悲剧的 Debuts ，于是突然想到理理这个，正好可以也当作自己博客 Design 系列第一篇。&lt;br&gt;
    
    </summary>
    
      <category term="Design" scheme="http://www.roczhang.com/categories/Design/"/>
    
    
  </entry>
  
</feed>
